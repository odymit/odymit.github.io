<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A New Algorithm to Estimate the Similarity between the Intentions of the Cyber Crimes for Network Forensics</title>
    <url>/2021/07/13/A-New-Algorithm-to-Estimate-the-Similarity-between-the-Intentions-of-the-Cyber-Crimes-for-Network-Forensics/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This paper proposes a new algorithm called the Similarity of Attack Intention (SAI), which uses cosine similarity as a distance-based similarity measure to estimate similar cyber crime intentions. The algorithm is based on the Attack Intention Analysis (AIA) algorithm to predict new cyber crime intentions and assigned the probability values for these intentions. A similarity metric for the new cyber crimes intentions with others is generated in order to identify the similar intentions. The evaluation of example cyber crime results shows that our proposed algorithm provides better solutions and increases the possibility value of evidences.</span><br></pre></td></tr></table></figure>
<p>abstract中指出：</p>
<ul>
<li>提出一种新的算法，用来进行攻击意图的相似度的识别，该算法使用余弦相似性作为基于距离的相似性度量来估计网络攻击意图</li>
<li>该算法基于攻击意图分析算法来预测网络攻击意图和意图的可能性</li>
<li>为了识别相似性生成了新网络攻击意图的相似度矩阵</li>
</ul>
<span id="more"></span>
<h2 id="算法执行流程">算法执行流程</h2>
<p>介绍了网络攻击意图相似度识别算法的组成部分：</p>
<ul>
<li>识别：此部分会采集流量并且进行告警分析，并识别可能意图</li>
<li>攻击意图相似性矩阵生成：使用 <code>AIA</code> 算法来进行攻击意图可能性计算，根据相关攻击类型生成攻击意图矩阵</li>
<li>选择相似意图：选择新攻击最匹配的攻击意图，</li>
</ul>
<h2 id="算法介绍">算法介绍</h2>
<p>算法定义了：</p>
<ul>
<li><code>Ak</code>：新的攻击，假定 <code>Ak</code> 属于 <code>PA</code>，该攻击包含的意图集合表示为 <code>AkIx (x &gt;= 1)</code></li>
<li><code>PA</code>：预定义的攻击</li>
<li><code>AI</code>：预定义的攻击意图</li>
</ul>
<p><img src="/2021/07/13/A-New-Algorithm-to-Estimate-the-Similarity-between-the-Intentions-of-the-Cyber-Crimes-for-Network-Forensics/algorithm.jpg" alt="算法伪代码"></p>
<p>该算法首先计算每次攻击中与相关意图可能性，将其求和，然后通过全部攻击意图可能性除以特定攻击意图数目，得到攻击意图 <code>Ak</code> 的相似度。</p>
<p><img src="/2021/07/13/A-New-Algorithm-to-Estimate-the-Similarity-between-the-Intentions-of-the-Cyber-Crimes-for-Network-Forensics/similarity.jpg" alt="攻击相似度"></p>
<p>如上图所示，新的攻击与预定义攻击 <code>A2</code> 最为相似。</p>
<h2 id="实验结果分析">实验结果分析</h2>
<p><img src="/2021/07/13/A-New-Algorithm-to-Estimate-the-Similarity-between-the-Intentions-of-the-Cyber-Crimes-for-Network-Forensics/similarity_matrix.jpg" alt="攻击相似度"></p>
<p>上图解释：</p>
<ul>
<li><code>A11</code> 为新的攻击，<code>A1 - A10</code> 为预定义攻击</li>
<li><code>A11</code> 被检测到有四种意图 <code>&#123;i1, i2, i4, i6&#125;</code></li>
<li><code>A11</code> 也就是新的攻击意图的概率来自 <code>AIA</code> 算法</li>
<li><code>&#123;i1, i2&#125;</code> 为新攻击的潜在意图，二者有最大概率值 <code>0.68</code></li>
</ul>
<p><img src="/2021/07/13/A-New-Algorithm-to-Estimate-the-Similarity-between-the-Intentions-of-the-Cyber-Crimes-for-Network-Forensics/similarity_1.jpg" alt="I1_I2相似度"></p>
<p>确定潜在意图后，可以对 <code>A11</code> 计算意图相似性。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>意图识别</tag>
        <tag>聚类算法</tag>
      </tags>
  </entry>
  <entry>
    <title>A Unified Framework for Analyzing and Detecting Malicious Examples of DNN Models</title>
    <url>/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/</url>
    <content><![CDATA[<p>A Unified Framework for Analyzing and Detecting Malicious Examples of DNN Models abstract。</p>
<span id="more"></span>
<h2 id="Contribution">Contribution</h2>
<ul>
<li>从防御的角度系统研究了对抗样本和后门样本的区别，确定了对抗性和后门示例在对模型突变、激活空间和特征空间中的行为的敏感性方面的异同。</li>
<li>应用四种方法检测对抗样本攻击和后门攻击，取得了较好的效果</li>
<li></li>
</ul>
<h3 id="对抗样本与后门攻击">对抗样本与后门攻击</h3>
<p><img src="/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/illustration.png" alt="两种攻击对比"><br>
<img src="/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/visualization.png" alt="两种攻击对比"><br>
两种攻击的比较：</p>
<ul>
<li>对抗样本是与输入样本绑定的，输入一个样本就需要计算一次扰动；</li>
<li>相反，后门攻击中的扰动是固定的；</li>
<li>对于特定模型而言，对抗样本攻击是消极的，假设该模型无法被修改。</li>
<li>而后门攻击则假设可以修改模型参数，当然修改后的模型在分类正常样本上性能不会受到影响这一点是需要保证的</li>
<li>对抗样本是通过添加扰动使得该样本逼近决策边界导致分类错误（扰动根据样本不同而不同的</li>
<li>后门攻击的扰动是固定偏移，通过修改模型参数改变决策边界，并通过扰动修改样本点位置，使得分类错误，如可视化图所示</li>
</ul>
<h2 id="缓解措施">缓解措施</h2>
<h4 id="对抗样本缓解措施">对抗样本缓解措施</h4>
<p>对抗样本大致有四种缓解措施：</p>
<ul>
<li>将对抗样本也做为训练数据训练模型</li>
<li>设计 AEs-aware 的网络结果或者损失函数</li>
<li>模型训练/预测前进行预处理</li>
<li>检测对抗样本</li>
</ul>
<h4 id="后门攻击缓解措施">后门攻击缓解措施</h4>
<ul>
<li>检测/消除后门（边界异常值检测/元神经分析/人工脑刺激</li>
<li>识别训练集中的污染数据</li>
<li>检测后门样本（得需要后门触发特征已知</li>
</ul>
<h2 id="workflow">workflow</h2>
<p><img src="/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/mutation-detect-workflow.png" alt="mutation"><br>
<img src="/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/activation-space.png" alt="activation-space"><br>
<img src="/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/kde.png" alt="kernel density estimation"><br>
<img src="/2022/04/09/A-Unified-Framework-for-Analyzing-and-Detecting-Malicious-Examples-of-DNN-Models/lid.png" alt="local intrinsic deimensionality"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>对抗样本检测</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Sec 简介</title>
    <url>/2022/03/25/AI-Sec-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>华为 AI 安全白皮书读书笔记，AI Sec 简介。</p>
<span id="more"></span>
<h2 id="AI-安全风险">AI 安全风险</h2>
<p>根据华为 AI 安全白皮书中所述，AI 系统在设计上面临五大安全挑战：</p>
<ul>
<li>软硬件安全（从软件到硬件到模型，都可能存在漏洞或者后门，攻击者能够利用这些漏洞实施高级攻击）</li>
<li>数据完整性（训练时可能被添加了恶意数据，查询数据被添加了恶意噪声，导致模型误判）</li>
<li>模型保密性（服务提供者只提供查询服务，不直接公布模型及参数，但是攻击者通过多次查询能够生成相似的模型）</li>
<li>模型鲁棒性（训练模型时样本往往覆盖性不足，使得模型的鲁棒性不足；面对恶意样本时，无法给出正确的判断结果）</li>
<li>数据隐私（在用户提供训练数据的场景下，攻击者能够通过反复查询训练好的模型获得用户的隐私信息）</li>
</ul>
<h2 id="AI-模型面临的典型攻击方式">AI 模型面临的典型攻击方式</h2>
<h3 id="闪避攻击">闪避攻击</h3>
<p>闪避攻击是指通过修改输入，让 AI 模型无法对其正确识别。闪避攻击是学术绝研究最多的一类攻击，下面是学术界提出的最具代表性的三种闪避攻击：<br>
**对抗样本：**深度学习系统容易受到精心设计的输入样本的影响，通常是在正常样本上添加人眼难以察觉的微小扰动，欺骗模型误判。<br>
**物理世界中的攻击：**在模型应用后，对真实世界中的路标进行涂改，也可以使得模型产生识别错误。<br>
**传递性与黑盒攻击：**生成对抗样本需要知道AI模型参数，但是攻击者有可能无法得到模型参数。但是研究发现，针对使用相同数据集进行训练的模型，对一个模型生成对抗样本也能欺骗另一个模型。</p>
<h3 id="药饵攻击（数据投毒）">药饵攻击（数据投毒）</h3>
<p>AI 系统通常用运行期间收集的新数据进行重训练，以适应数据分布的变化。在这种情况下，攻击者可能通过注入精心设计的样本，即药饵来使得训练数据被污染，危害整个系统的正常功能，例如逃逸AI的安全分类等。</p>
<p>并且有研究表明，即使在训练样本中掺杂少量的恶意样本，也能很大程度干扰AI模型准确率。</p>
<h3 id="后门攻击">后门攻击</h3>
<p>AI模型可以被嵌入后门，并且只有制造后门的人知道如何出发，其他人很难发现。<br>
该类后门十分隐蔽，神经网络由参数构成，不具有可读性。<br>
例如，在图分类模型中，只有输入图像包含特定图案才能触发后门。<br>
此类攻击多发于模型生成和传输过程中。</p>
<h3 id="模型窃取攻击">模型窃取攻击</h3>
<p>多次调用模型接口，构建相似的模型，将 AI 模型窃取出来。</p>
<h2 id="安全防御手段">安全防御手段</h2>
<p>安全手段主要分为三个层次</p>
<h3 id="攻防安全">攻防安全</h3>
<p>针对已知的攻击进行，有针对性的防御。</p>
<ul>
<li>防闪避攻击</li>
<li>防药饵攻击</li>
<li>防后门攻击</li>
<li>防模型窃取</li>
</ul>
<h3 id="模型安全">模型安全</h3>
<p>通过模型验证等手段提升模型健壮性。</p>
<ul>
<li>数据可解释</li>
<li>可验证模型</li>
<li>模型健壮性</li>
<li>可解释模型</li>
</ul>
<h3 id="架构安全">架构安全</h3>
<p>在AI部署的业务中设计不同的安全机制保证架构安全。</p>
<ul>
<li>隔离与检测</li>
<li>冗余与熔断</li>
<li>多模型架构</li>
<li>数据自洽性</li>
</ul>
<h2 id="防御技术">防御技术</h2>
<h3 id="闪避攻击防御技术">闪避攻击防御技术</h3>
<ul>
<li>网络蒸馏</li>
<li>对抗训练</li>
<li>对抗样本检测</li>
<li>输入重构</li>
<li>DNN模型验证</li>
</ul>
<h3 id="数据投毒防御技术">数据投毒防御技术</h3>
<ul>
<li>训练数据过滤</li>
<li>回归分析</li>
<li>集成分析</li>
</ul>
<h3 id="后门攻击防御技术">后门攻击防御技术</h3>
<ul>
<li>输入与出来</li>
<li>模型剪枝</li>
</ul>
<h3 id="模型-数据防窃取技术">模型/数据防窃取技术</h3>
<ul>
<li>隐私聚合教师模型（PATE）</li>
<li>差分隐私</li>
<li>模型水印</li>
</ul>
<h2 id="AI-模型可解释性">AI 模型可解释性</h2>
<p>除了针对已知攻击做防御外，还应增强AI模型本身安全性。</p>
<h3 id="模型可检测性">模型可检测性</h3>
<p>前溃检测进行恶意样本过滤，后溃检测模块减少误判。</p>
<h3 id="模型可验证性">模型可验证性</h3>
<p>模型验证一般需要约束输入空间(input space)与输出空间(output space)的对应关系,从而验证输出在一定的范围内。但是基于统计优化(optimization)的学习及验证方法总还是无法穷尽所有数据分布,而极端攻击则有机可乘,这样在实际应用中较难实施具体的保护措施。只有在对DNN模型内部工作机理充分理解的基础上才能进一步解决机制性防御(principled defense)问题。</p>
<h3 id="模型可解释性">模型可解释性</h3>
<p>有些业务需要 AI 系统给出判断依据，但是现在还是一个黑盒子。</p>
<p>学术界正在对 AI 模型的可解释性进行积极探索：</p>
<ul>
<li>建模前的数据可解释</li>
<li>构建可解释模型</li>
<li>对已构建的模型进行解释性分析</li>
</ul>
<h2 id="AI业务的安全架构">AI业务的安全架构</h2>
<p>设计安全的 AI 业务架构，需要综合利用隔离、检测、熔断和冗余等安全机制。</p>
<ul>
<li>隔离</li>
<li>检测</li>
<li>熔断</li>
<li>冗余</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>AI安全</tag>
      </tags>
  </entry>
  <entry>
    <title>A Survey on Neural Trojans</title>
    <url>/2022/07/20/A-Survey-on-Neural-Trojans/</url>
    <content><![CDATA[<p>A Survey on Neural Trojans abstract。</p>
<span id="more"></span>
<h2 id="论文整体思路">论文整体思路</h2>
<p>该论文将后门攻击大致分为了两类：</p>
<ul>
<li>数值级</li>
<li>二进制级</li>
</ul>
<h2 id="数值后门-Numeric-Level-Backdoor">数值后门 Numeric-Level Backdoor</h2>
<p>数值级别后门是通过修改模型的神经元权重来改变模型的行为的，通常通过嵌入污染的训练数据来达到此效果。<br>
数值级别后门又可以细分为以下几类：</p>
<ul>
<li>通过训练数据投毒嵌入后门 Trojan Insertion by Training Data Poisoning</li>
<li>通过修改网络计算操作嵌入后门 Trojan Insertion without Poisoning</li>
<li>隐藏后门触发特征 Hiding Trojan Triggers</li>
<li>通过迁移学习嵌入后门 Neural Trojan Insertion in Transfer Learning</li>
</ul>
<h2 id="二进制后门-Binary-Level-Backdoor">二进制后门 Binary-Level Backdoor</h2>
<p>二进制级别后门则是通过直接修改控制神经网络训练的代码实现后门嵌入的。<br>
文章给出两个基于供应链的后门嵌入研究，两项研究都是将后门嵌入代码伪装成为正常的插件，然后通过该插件控制模型训练行为，达到嵌入模型后门的效果。<br>
除此之外，本部分还给出一种位翻转的后门嵌入方法，该方法有以下步骤：</p>
<ul>
<li>使用梯度排名从最后一层神经元中找出对结果影响最大的 bit 位</li>
<li>使用最小优化技术获得 trigger</li>
<li>比较原权重矩阵和优化后的恶意权重矩阵决定要翻转的 bit 位</li>
<li>然后在主存中使用 raw-hammer 技术将特定的 bit 位翻转</li>
</ul>
<h2 id="其他攻击">其他攻击</h2>
<p>文章还研究了针对神经网络的其他攻击，大致可以将其他攻击分为：</p>
<ul>
<li>数据投毒攻击</li>
<li>探索性攻击</li>
</ul>
<h3 id="数据投毒攻击-Poisoning-Attack">数据投毒攻击 Poisoning Attack</h3>
<p>大多数机器学习算法假定了训练数据集的完整性，然而该假设是容易被打破的。数据投毒攻击的主要目标是<strong>降低模型的准确率</strong>。这也是后门攻击与投毒攻击的主要区别：</p>
<ul>
<li>投毒：降低模型准确率</li>
<li>后门：在不降低模型准确率的前提下，嵌入恶意后门，使得存在后门的样本被误分类</li>
</ul>
<h3 id="探索性攻击-Exploratory-Attack">探索性攻击 Exploratory Attack</h3>
<p>此处文章给出两种探索性攻击：</p>
<ul>
<li>白盒条件</li>
<li>黑盒条件</li>
</ul>
<h4 id="白盒-white-box">白盒 white-box</h4>
<p>白盒下的攻击通常是利用 FGSM 等方法生成对抗性样本。</p>
<h4 id="黑盒-black-box">黑盒 black-box</h4>
<p>黑盒下的攻击通常是首先通过模型萃取攻击，在本地生成一个替代模型，然后基于该模型进行对抗样本的生成。</p>
<p>这是基于对抗样本的可转移性。</p>
<h2 id="防御手段-Defense-Techniques">防御手段 Defense Techniques</h2>
<p>针对后门的防御手段可以大致被分为四类：</p>
<ul>
<li>神经网络验证 Neural Network Verification</li>
<li>后门特征检测 Trojan Trigger Detection</li>
<li>后门网络复原 Compromised Neural Network Restoratioin</li>
<li>后门绕过方案 Trojan Bypass Schemes</li>
</ul>
<h3 id="神经网络验证-Neural-Network-Verification">神经网络验证 Neural Network Verification</h3>
<p>通过验证神经网络的有效性可以识别任何后门造成的异常，基于此文章给出了两个相关工作：</p>
<ul>
<li>NPAQ:给定一组参数 P 和训练好的网络 N，可以确定 P 在 N 上的效果，以此识别后门</li>
<li>Sensitive-Sample Fingerprinting:给定一组对于网络参数十分敏感的样本，以此类样本的分类结果判断是否存在后门</li>
</ul>
<h3 id="后门特征检测-Trojan-Trigger-Detection">后门特征检测 Trojan Trigger Detection</h3>
<p>由于后门触发特征的特异性（可以指定），因此给后门触发特征的检测带来很大的挑战。但是现有工作 <code>Yuntao Liu, Yang Xie, and Ankur Srivastava. 2017. Neural trojans.</code> 也证明了使用先进的异常检测分类器也可以检测到后门触发特征，尽管代价是提高误报率。</p>
<p>其一是，通过评估训练输入对神经模型准确性的影响来检测木马触发器。</p>
<p>其二是，最近的研究使用 <code>provenance data</code> 也就是 <code>meta-data</code> 元数据，根据样本是后门触发概率或者有毒输入的概率来对训练数据进行分组。然后进行分组训练验证是否对模型准确率有损害，如果是则是既有可能该组存在后门触发特征样本。</p>
<p>其他如 <code>ABS</code>、<code>RONI</code>、<code>PS</code> 也是与二相似。</p>
<p>其三是，<code>DeepInspect</code> 在最小化模型知识与无训练数据的情况下进行后门检测，具体步骤为三步如下：</p>
<ul>
<li>翻转神经网络，获得一个训练数据集，替代原训练数据集</li>
<li>条件 GAN 网络重建可能的后门触发特征</li>
<li>为已识别的触发特征计算异常检测值，该值表示一个数据点所属类别与网络返回类别不同的可能性</li>
</ul>
<p>其四是，<code>STRIP</code> 向样本添加了强扰动，添加扰动前后类别保持一致的被认为是包含后门触发特征的样本，不同的则是良性样本。</p>
<p>其五是，<code>ULPs</code> 通过优化输入图像使其成为可以作为模型是否包含后门的标识器，因此不需要训练数据即可检测后门。</p>
<p>其六是，<strong><code>Detecting AI Trojans Using Meta Neural Analysis</code></strong> 提出使用元神经元分析（meta neural analysis）来检测后门。提出了两种技术来训练一个元分类器（meta-classifier）：</p>
<ul>
<li>仅使用良性网络来拟合元分类器的 one-class learning</li>
<li>拟合近似后门网络通用分布，并对其采样来训练元分类器的 jumbo learning</li>
</ul>
<p>其七是，无监督异常检测，在对训练数据无访问的条件下，通过控制训练好的网络和良性样本，通过诱导分类器误分类，学习其最小扰动来进行后门的检测。</p>
<h3 id="后门网络复原-Restoring-Compromised-Neural-Models">后门网络复原 Restoring Compromised Neural Models</h3>
<p>在此部分介绍了两种复原方式：</p>
<ul>
<li>模型修正 Model Correction</li>
<li>基于触发特征的后门逆向 Trigger-based Trojan Reversing</li>
</ul>
<p>详见原文。</p>
<h3 id="后门网络绕过-Bypassing-Neural-Trojans">后门网络绕过 Bypassing Neural Trojans</h3>
<p>此类方法主要是通过预处理的方法移除数据集中的后门特征。</p>
<p>详见原文。</p>
<h3 id="良性后门利用-Using-Neural-Trojans-for-Good">良性后门利用 Using Neural Trojans for Good</h3>
<p>也存在良性的后门利用方式，具体如下：</p>
<ul>
<li>模型水印 watermark</li>
<li>后门蜜罐</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Survey</tag>
        <tag>AI Backdoor Attacks</tag>
      </tags>
  </entry>
  <entry>
    <title>AIQL: Enabling Efficient Attack Investigation from System Monitoring Data</title>
    <url>/2022/04/13/AIQL-Enabling-Efficient-Attack-Investigation-from-System-Monitoring-Data/</url>
    <content><![CDATA[<p>AIQL: Enabling Efficient Attack Investigation from System Monitoring Data abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>出于对抗 APT 攻击的需要，系统调用监控和即时溯源分析得到人们的重视。然而，现有的基于关系和图的查询系统缺乏对攻击活动关键属性的刻画，并且查询效率低下，因为他们语义无关的设计无法利用系统监控数据的属性来加速查询执行。<br>
因此本文针对此问题提出解决方案。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/13/AIQL-Enabling-Efficient-Attack-Investigation-from-System-Monitoring-Data/arch.png" alt="arch"></p>
<p>为了解决上述问题，提出了一种建立在现有的监控工具和数据库之上的新型查询系统，该系统采用新型优化设计支持及时的攻击调查。</p>
<p>提供：</p>
<ul>
<li>特定领域的数据模型来拓展存储</li>
<li>特定领域的查询语言，AIQL，集成了用于攻击调查的关键原语</li>
<li>基于数据特征和查询语义的优化查询引擎</li>
</ul>
<p>系统提供了特殊的结构来表示：</p>
<ul>
<li>多步骤攻击</li>
<li>攻击依赖追溯</li>
<li>异常系统行为</li>
</ul>
<p><img src="/2022/04/13/AIQL-Enabling-Efficient-Attack-Investigation-from-System-Monitoring-Data/types.png" alt="major types"></p>
<h2 id="数据模型和存储">数据模型和存储</h2>
<h3 id="数据模型">数据模型</h3>
<p><img src="/2022/04/13/AIQL-Enabling-Efficient-Attack-Investigation-from-System-Monitoring-Data/model.png" alt="data model"><br>
<img src="/2022/04/13/AIQL-Enabling-Efficient-Attack-Investigation-from-System-Monitoring-Data/model1.png" alt="data model"></p>
<h3 id="存储">存储</h3>
<h4 id="时空分区-time-and-space-partitioning">时空分区 time and space partitioning</h4>
<p>采集到的数据具有时空特点，查询一般查询某一段时间内的记录，所以对于数据存储从时间和空间上来进行分区：将agents组划分成表分区，以天为单位生成数据库，并对频繁查询的属性建立各种类型的索引。</p>
<h4 id="超表-hypertable">超表 hypertable</h4>
<p>使用 MPP(massively parallel processing) 来管理大规模数据。</p>
<h4 id="时间同步">时间同步</h4>
<p>通过 网络时间协议 来进行时间偏移修正。</p>
<h3 id="查询语言设计">查询语言设计</h3>
<h3 id="查询执行引擎">查询执行引擎</h3>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源分析管理平台</tag>
      </tags>
  </entry>
  <entry>
    <title>ALchemist: Fusing Application and Audit Logs for Precise Attack Provenance without Instrumentation</title>
    <url>/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/</url>
    <content><![CDATA[<p>ALchemist: Fusing Application and Audit Logs for Precise Attack Provenance without Instrumentation abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>网络攻击变得越来越复杂和持久，很多当前最先进的方法不是要求源码注释或者软件应用的指令 就是依赖高质量的执行配置文件作为基础，进行异常检测。<br>
为解决此问题，提出 ALchemist。</p>
<h2 id="Architecutre">Architecutre</h2>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/arch.png" alt="arch"></p>
<p>提出的 ALchemist 基于：</p>
<ul>
<li>内置的应用程序日志可以提供关键的高层级语义</li>
<li>审计日志可以提供低层级细粒度的信息</li>
<li>而两者共享大量的基本元素</li>
</ul>
<h2 id="思路与具体实现">思路与具体实现</h2>
<h3 id="日志数据处理">日志数据处理</h3>
<p>本文提出的溯源图和NoDoze生成的溯源图的区别：</p>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/cp-g.png" alt="comparasion"></p>
<p>两种日志的对比：</p>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/eg-0.png" alt="two logs"></p>
<p>统一模型：</p>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/eg-1.png" alt="unified model"></p>
<p>归一化的数据：</p>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/eg-norm.png" alt="normalized data"></p>
<h3 id="审计日志融合">审计日志融合</h3>
<p>基于规则的审计日志融合，具体的规则如下：</p>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/rules.png" alt="rules"></p>
<p>对火狐浏览器日志进行融合的案例：</p>
<p><img src="/2022/04/18/ALchemist-Fusing-Application-and-Audit-Logs-for-Precise-Attack-Provenance-without-Instrumentation/eg-2.png" alt="eg rules"></p>
<h3 id="需求驱动的数据日志推理">需求驱动的数据日志推理</h3>
<p>输入一个 POI 事件，然后针对这个事件进行反向传播分析。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>forensic</tag>
      </tags>
  </entry>
  <entry>
    <title>ATLAS: A Sequence-based Learning Approach for Attack Investigation</title>
    <url>/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this paper, we present ATLAS, a framework that constructs an end-to-end attack story from off-the-shelf audit logs. Our key observation is that different attacks may share similar abstract attack strategies, regardless of the vulnerabilities exploited and payloads executed. ATLAS leverages a novel combination of causality analysis, natural language processing, and machine learning techniques to build a sequence-based model, which establishes key patterns of attack and non-attack behaviors from a causal graph. At inference time, given a threat alert event, an attack symptom node in a causal graph is identified. ATLAS then constructs a set of candidate sequences associated with the symptom node, uses the sequence-based model to identify nodes in a sequence that contribute to the attack, and unifies the identified attack nodes to construct an attack story.</span><br></pre></td></tr></table></figure>
<p>文章abstract中指出：</p>
<ul>
<li>提出一个端到端攻击事件构建框架，该框架基于审计日志来进行攻击事件的构建；</li>
<li>此框架的主要原理是不同的技术用于实现相同的战术目的；</li>
<li>ATLAS框架集成了因果分析、自然语言处理和机器学习来构建基于序列的模型，该序列模型是从因果图中识别攻击的主要特征；</li>
<li>在推理阶段，给出威胁告警，该框架可以在因果图上识别出攻击节点（attack symptom node）；</li>
<li>使用识别出的攻击节点可以构建攻击事件和攻击因果图。</li>
</ul>
<p>本文是发表在信安顶会 USENIX 2021 上的文章，结合了自然语言处理、机器学习方法，值得借鉴学习。源码和数据在：<a href="https://github.com/purseclab/ATLAS">https://github.com/purseclab/ATLAS</a>.</p>
<span id="more"></span>
<h2 id="通过案例来解释框架">通过案例来解释框架</h2>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/casual_grpah.png" alt="因果图"></p>
<p>如上图<code>a</code> 所示，框架首先会构建因果图，然后基于因果图进行攻击行为的识别，如虚线红框中的 <code>alpha</code> 虚线所代表的行为即为识别出的攻击。</p>
<p>作者认为在一系列攻击中每个攻击都跟上下文有关，这跟自然语言中每一句话都跟上下文有关是相同的。基于此原理，他们认为提取出的三元组序列可以训练获得在不同APT攻击上有效的模型。因为即使底层的审计记录不同，他们还是拥有相同的上下文语义，或者说战术目的。</p>
<p>在推理阶段会定义攻击节点（attack symptom node），表示这些节点出现在攻击告警中，可能发动攻击行为。以攻击节点为基础，拓展攻击节点的候选节点序列，这些候选节点是跟攻击节点相邻的节点，然后使用模型来识别这些节点是否有助于完成进一步攻击。</p>
<p>如上图中 <code>b</code> 所示，通过这些攻击节点就可以构建攻击事件记录了。而图中 <code>c</code> 则是攻击事件的因果图表示，为完整因果图的子图，描述攻击行为因果关系。</p>
<h2 id="ATLAS架构">ATLAS架构</h2>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/ATLAS_architecture.png" alt="架构图"></p>
<p>整个 <code>ATLAS</code> 分为两个部分，一个部分是训练，另一个部分是使用该模型进行攻击识别。</p>
<p>在训练部分：</p>
<ul>
<li>审计记录作为输入，从审计记录中抽取实体和关系构建因果图</li>
<li>从图中抽取并构建序列</li>
<li>对序列进行词形还原</li>
<li>选择性序列抽样</li>
<li>序列嵌入，将序列转换成数值向量的表示形式</li>
<li>将向量送入 <code>LSTM</code> 中进行训练得到模型</li>
</ul>
<h2 id="设计中存在的挑战">设计中存在的挑战</h2>
<ol>
<li>
<p>如何构建序列来对合法活动和可以活动建模</p>
<p>目的是找到更好的序列表示方式，可以更好地区分合法活动和恶意攻击，并且从不同的审计日志类型中提取出来。</p>
<p>在传统的序列提取方式中，存在两个问题，一个是存在着大量的单一实体，比如一个进程具有多个实例；相同的攻击特征出现在不同的进程中会导致不同的序列会出现相同或者极度相似的上下文。</p>
<p>这两个问题会影响模型收敛和学习的精度，可能导致梯度消失或者梯度爆炸。</p>
<p><code>ATLAS</code> 对此进行了图优化，来降低图的复杂度。</p>
</li>
<li>
<p>攻击模型训练时数据集中的非攻击序列过多而攻击序列过少，这是由于攻击和日志的特点导致的</p>
<p>在这样数据集下训练出来的模型会倾向于非公集序列，会导致大量攻击序列未被检测到。</p>
<p>对于此问题，<code>ATLAS</code> 对非攻击序列欠采样对攻击序列过采样，平衡两类攻击的比例。</p>
</li>
<li>
<p>尽管训练好的模型可以进行任意序列的预测，但是输入的序列是专家临时生成的，可能需要大量的序列发现</p>
<p>对于此问题，<code>ATLAS</code> 引入了攻击调查阶段（attack investigate phase），在该阶段将会对审计日志进行攻击识别等操作。</p>
<p>因此可以恢复出攻击实体来帮助进行构建攻击事件。</p>
</li>
</ol>
<h2 id="审计日志预处理">审计日志预处理</h2>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/graph_preprocess.png" alt="因果图优化"></p>
<p>此处解决挑战1中提出的问题，存在大量单一实体，例子是同一个进程具有多个线程实例。在此处将多个节点聚合为一个节点，降低图的复杂度。</p>
<p>为了优化因果图的复杂度，<code>ATLAS</code> 使用了三种方法：取消所有不跟攻击节点相连的点和边；去除所有重复的边；合并同类节点和边。</p>
<h2 id="序列构建和训练学习">序列构建和训练学习</h2>
<p>在本步骤内会进行：打标签、攻击序列提取、数据平衡采样、词嵌入，然后训练学习。</p>
<h3 id="因果图构建与攻击序列提取">因果图构建与攻击序列提取</h3>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/sequence_extraction.png" alt="攻击序列提取"></p>
<p>攻击实体子集，集合中全为因果图中攻击实体的集合，且实体个数 <code>&lt;= 2</code>  .</p>
<p>因果图构建与攻击序列提取步骤如下：</p>
<ul>
<li>对于每一个攻击实体子集中的攻击实体， 获得他们的邻居图，此步骤将会使 <code>ATLAS</code> 捕获所有与攻击实体有因果关系的实体</li>
<li><code>ATLAS</code> 从邻居图中获取带有时间戳的攻击事件</li>
<li>将提取出来的带有时间戳的攻击事件转化成攻击序列</li>
</ul>
<p>非攻击序列的提取与攻击序列相似，但是由于非攻击序列非常多，所以会遇到处理时指数爆炸的问题。而 <code>ATLAS</code> 不会从非攻击序列上学习特征，只会学习攻击学列和非攻击序列的边界。因此在攻击序列中添加一个非攻击节点，这样子会提取出一个非攻击序列。这样子 <code>ATLAS</code> 不但能够获得非攻击序列，而且能够准确地学习到攻击序列和非攻击序列的相似性和不同点。</p>
<p>如上图 <code>c</code> 部分，序列 <code>&#123;A, B&#125;</code> 不跟任何事件匹配，所以标记为非攻击序列。</p>
<h3 id="词形还原">词形还原</h3>
<p><code>ATLAS</code> 使用词形还原的方式将序列转化为归一化的文本来表示序列特征。词形还原在自然语言中常用来处理同一个词的不同形式。如：将 <code>drove</code> 处理为 <code>drive</code>，将 <code>driving</code> 处理为 <code>drive</code>。</p>
<p>这个处理将会获得序列的原始语义，有利于基于序列的模型学习。</p>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/lemmatization.png" alt="词形还原表"></p>
<p>举个例子：<code>&lt;/system/process/malicious.exe read /user/secret.pdf&gt; is transformed to &lt;system_process read user_file&gt;</code></p>
<p>这些类型足以捕获因果图中实体的上下文、语义和句法相似性以及与其他单词的关系。</p>
<h3 id="选择性序列取样">选择性序列取样</h3>
<p>为了平衡训练集，<code>ATLAS</code> 首先使用相似度欠采样了非攻击序列，然后使用过采样机制随机变异了攻击序列，最后使得攻击序列数量和非攻击序列数量基本相同。</p>
<p>当然最简单的方法是随机去除非攻击序列和重复攻击序列，但是论文中提及，这样处理会导致模型对攻击序列过拟合并且丢失了重要的非攻击序列的特征。</p>
<p>具体的欠采样的做法如下：</p>
<ul>
<li>欠采样做法通过编辑距离（Levenshtein Distance）来进行样本欠采样，编辑距离用于两个字符串的差异程度的量化测量。以此确保了数据集中去除的是冗余的重复样本。</li>
<li>编辑距离通常比较两个字符串之间的差异，在此处 <code>ATLAS</code>  计算的是编辑步骤的数量，例如在序列中添加或删除词汇表中的单词，来将序列转换为另一个词形还原序列。以此获得序列的编辑距离。</li>
<li>实验发现 <code>80%</code> 准确率下的能获得好的采样比和去除高度相似的甚至相同的序列。</li>
</ul>
<p>具体的过采样方法如下：</p>
<ul>
<li>为了给训练用的攻击序列提供更好的多样性，采用了基于变异的过采样方法。</li>
<li>在此项还原表中，有同一类型下的不同子类，如 <code>system_process， program_process</code>。在攻击序列进行词形还原后，将会对其中的实体进行同类型子类的替换。</li>
<li>这不会从根本上改变攻击序列，但是增加了在用于模型训练的攻击中未触发的类似序列的数量，由于上下文差异，在其他攻击中仍可能发生。</li>
</ul>
<h3 id="序列嵌入和模型训练">序列嵌入和模型训练</h3>
<h3 id="序列嵌入">序列嵌入</h3>
<p><code>ATLAS</code> 在模型训练时结合词嵌入将词形还原后的序列转化成数值向量。常用的词嵌入方式有 <code>word-representing、word2vec</code>，由此生成的词向量可以准确地表示不同词之间的语义关系。序列的向量可以定义了序列实体表中特定域之间的语义关系，有助于在模型训练时突出不同序列的特征。</p>
<p>训练词向量的语料库包含所有从审计日志中提取出来的攻击序列和非攻击序列。</p>
<p>这种序列嵌入的方法相比其他的比如 <code>one-hot-encoding</code> 的方法具有更好的效果。</p>
<h3 id="基于序列的模型训练">基于序列的模型训练</h3>
<p><code>ATLAS</code> 使用了 <code>LSTM</code> 网络来学习序列特征。<code>LSTM</code> 是一种常用的模型，并且已经证明在很多基于序列的学习中具有良好的效果。</p>
<p>模型同样包含一个 <code>CNN</code> 网络，该网络可以帮助模型捕获具有隐蔽性和动态变化性的 <code>APT</code> 攻击。模型使用了 <code>dropout</code> 层来降低过拟合并提高泛化性，使用了带 <code>Max pooling</code> 的 <code>Conv1D</code> 层来处理序列，带 <code>Sigmoid</code> 激活函数的全连接层来预测攻击序列关联的可能性。这个模型在试验中获得了相比其他架构更好的准确率。</p>
<h2 id="攻击调查">攻击调查</h2>
<p>在此部分就是部署模型进行攻击调查，攻击调查包含攻击实体识别、攻击事件恢复和涉及多主机攻击的处理。</p>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/attack_recovery.png" alt="攻击事件还原"></p>
<h2 id="具体效果">具体效果</h2>
<p>数据集：</p>
<ul>
<li>缺少公开数据集，根据公开数据集记录做的 <code>APT</code> 攻击复现，并且模拟了正常用户的活动</li>
</ul>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/results.png" alt="试验结果"></p>
<p>最后，作者分析了结果中的假阳性和假阴性，并且分析了各个组成部分的优化和对于最后结果的支撑。</p>
<h3 id="因果图">因果图</h3>
<p>定制的因果图生成算法，降低了图的复杂性，有助于改进序列构造的算法。</p>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/graph_optimization.png" alt="图优化效果"></p>
<p>###　选择性序列采样</p>
<p><img src="/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/sampling.png" alt="采样优化"></p>
<p>测试结果显示，采样优化后训练时间减少了约 <code>87%</code>。并且非攻击序列的抽取，抽取了初始序列的 <code>22%</code> 左右作为高代表性的训练集，这有效的提高了模型准确率。</p>
<h2 id="总结">总结</h2>
<p>作者详细介绍了整个模型的搭建过程和原理，并给出了源码和实验数据：<a href="https://github.com/purseclab/ATLAS">https://github.com/purseclab/ATLAS</a>.</p>
<p>得出结果后，给出了结果假阳性和假阴性的分析，以及模型有效性的分析。</p>
<p>可以参考其模型设计和优化思路，特别是机器学习相关模型中的数据预处理和数据集比例等。最近也在做图神经网络相关的工作，图的设计和生成可以参考此文的优化思路。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
        <tag>自然语言处理</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ATT&amp;CK相关项目调研</title>
    <url>/2021/07/02/ATT-CK%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<p>最近想基于 <code>ATT&amp;CK</code> 的模型做一个分析工具，<code>ATT&amp;CK</code> 本身有几个相关的工具，于是看一下能不能作为参考。</p>
<p><code>ATT&amp;CK</code> 相关项目链接为：<a href="https://attack.mitre.org/resources/related-projects/">https://attack.mitre.org/resources/related-projects/</a></p>
<p>主要了解的项目是：</p>
<ul>
<li><a href="https://car.mitre.org/">CAR</a></li>
<li><a href="https://github.com/mitre/cascade-server">CASCADE</a></li>
<li><a href="https://github.com/mitre/caldera">CALDERA</a></li>
</ul>
<span id="more"></span>
<h2 id="CAR">CAR</h2>
<p><code>The Cyber Analytics Repository (CAR) is a knowledge base of analytics developed by MITRE based on the ATT&amp;CK® adversary model.</code></p>
<p><code>CAR</code> 是MITRE公司基于 <code>ATT&amp;CK</code> 攻击者模型发展出来的网络攻击行为分析仓库，该仓库包含各种应用 <code>ATT&amp;CK</code> 攻击实例分析数据。</p>
<p><code>CAR</code> 定义了一个使用伪代码表示的数据模型，每一个模型表示一个攻击利用，针对不同的具体应用还会有不同实现。</p>
<p>说明文档指出，存储在 <code>CAR</code> 里的实例分析数据还包括以下信息：</p>
<ul>
<li>用来解释攻击思路的推断</li>
<li>分析对象所在域（比如主机、网络、进程等）</li>
<li>分析发现的 <code>ATT&amp;CK</code> 技术和战术</li>
<li><code>CAR</code> 的字段解释 <a href="https://car.mitre.org/Glossary">the Glossary</a></li>
<li>实施分析的伪代码</li>
<li>触发分析的单元测试</li>
</ul>
<p>总之，<code>CAR</code> 是攻击案例的分析数据库，分析包括攻击的技术、战术，攻击检测方法和单元测试等信息。</p>
<h2 id="CASCADE">CASCADE</h2>
<p><code>CASCADE is a research project at MITRE which seeks to automate much of the investigative work a “blue-team” team would perform to determine the scope and maliciousness of suspicious behavior on a network using host data.</code></p>
<p><code>CASCADE</code> 是用来帮助分析高级攻击行为的一个平台，可以识别和搜索已知的攻击行为。<code>CASCADE</code> 可以通过上下文使部分分析操作自动化，比如进程捕获和 <code>ATT&amp;CK</code> 技术识别。</p>
<p>本质上 <code>CASCADE</code> 的工作是查询分析，并且输出结果，<code>CASCADE</code> 需要定义数据模型作为输入，此处的数据模型基于 <code>CAR</code> 中的数据模型，主要包括：</p>
<ul>
<li><code>object</code>：已更改、访问或操作的资源的名称，可以包括操作系统级别的实体，例如进程、文件、网络连接和线程</li>
<li><code>action</code>：描述资源实际发生了什么，例如创建或者终止进程，可以创建、写入、读取或删除文件</li>
<li><code>field</code>：描述事件的属性名称，如果创建了一个进程，那么可以保存进程的ID或者执行文件的路径或命令参数</li>
</ul>
<p>分析是基于会话的，每一个会话就是一个时间窗，分析将在时间窗上进行。</p>
<h3 id="分析方法">分析方法</h3>
<p><code>Analytics are essentially queries created to detect specific behaviors.</code></p>
<p><code>CASCADE</code> 的分析方法本质上是对不同的特定行为的查询。可以理解为基于规则的查询。</p>
<p>在给出的示例 <code>brawl-demo</code> 中，有选择分析规则的配置：</p>
<p><img src="/2021/07/02/ATT-CK%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%A0%94/cascade_analytics.png" alt="规则配置"></p>
<p>外部分析部分对应的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExternalAnalytic</span>(<span class="params">Analytic</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param List[str] fields: A list of all of the fields to be expected in each row of output</span></span><br><span class="line"><span class="string">    :param List[ObjectMapping] mapped_objects: A list of all of the mapped objects</span></span><br><span class="line"><span class="string">    :param str query_name: The name of the query saved on the target platform (i.e. Splunk)</span></span><br><span class="line"><span class="string">    :param str car: Optional. The corresponding CAR analytic (car.mitre.org)</span></span><br><span class="line"><span class="string">    :param str car_summary: Optional. The summary name of the CAR analytic</span></span><br><span class="line"><span class="string">    :param str platform: The target platform (Splunk, ElasticSearch, etc.)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fields = ListField(StringField())</span><br><span class="line">    query_name = StringField()</span><br><span class="line">    car = StringField()</span><br><span class="line">    car_summary = StringField()</span><br><span class="line">    platform = StringField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_events</span>(<span class="params">self, result</span>):</span></span><br><span class="line">        state = result[<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Generalize this capability for CASCADE analytics as well</span></span><br><span class="line">        <span class="keyword">for</span> mapping <span class="keyword">in</span> self.mapped_events:</span><br><span class="line">            object_type = mapping.object_type</span><br><span class="line">            action = mapping.action</span><br><span class="line">            <span class="keyword">if</span> mapping.is_mappable(state):</span><br><span class="line">                fields = mapping.from_result(state)</span><br><span class="line">                <span class="comment"># return a list of DataModelQuery objects (which will be run as jobs)</span></span><br><span class="line">                <span class="keyword">yield</span> object_type.search(action, **fields)</span><br></pre></td></tr></table></figure>
<p>代码中 <code>platform</code> 部分对应的平台就是配置的外部数据库，在 <code>brawl-demo</code> 中是配置的 <code>ElasticSearch</code> 数据库，连接数据库创建会话后执行上图中的分析，调用的代码即为上述代码。</p>
<h2 id="CALDERA">CALDERA</h2>
<p><code>CALDERA is an automated adversary emulation system that performs post-compromise adversarial behavior within Windows Enterprise networks.</code></p>
<p><code>CALDERA</code> 是一个自动攻击仿真系统，模拟攻击者攻入网络后的行为。</p>
<p><code>CALDERA</code> 可以模拟攻击者协助红队实施手动渗透并且实施自动化事件响应。</p>
<p>启动该服务器后可以进行代理 <code>agent</code> 配置，红队的 <code>agent</code> 用于控制和通信，蓝队的 <code>agent</code> 用于检测和相应，还可以配置攻击者，让攻击者自主发动攻击。攻击者具有攻击决定引擎判断接下来是用什么攻击。</p>
<h2 id="总结">总结</h2>
<p><code>CAR</code> 中主要问攻击分析的案例数据，对于分析工具的开发启发不大，如果分析基于结构化数据，可以考虑使用该仓库中的数据。</p>
<p><code>CASCADE</code> 基于 <code>CAR</code> 中的数据进行时间窗分析，使用基于规则的方法，输入的是结构化的数据，根据规则进行分析和事件关联。可以考虑使用结构化数据，在此基础上考察一下其他分析方法。</p>
<p><code>CALDERA</code> 是攻击者模拟仿真系统，如果要开发仿真系统，可以参考其思路和具体实际方法。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>survey</category>
      </categories>
      <tags>
        <tag>ATT&amp;CK</tag>
        <tag>CALDERA</tag>
        <tag>CASCADE</tag>
        <tag>CAR</tag>
      </tags>
  </entry>
  <entry>
    <title>APT 攻击检测相关工作总结</title>
    <url>/2021/09/03/APT-%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本文将会总结过去几篇有关 APT 攻击检测相关的论文中提到的相关工作，从而能够较为清晰地认识当前在该领域内的前人工作和前沿技术，具体会总结以下几篇论文中的相关工作：</p>
<ul>
<li><a href="https://omitedy.github.io/2021/08/27/UNICORN-Runtime-Provenance-Based-Detector-for-Advanced-Persistent-Threats/">UNICORN: Runtime Provenance-Based Detector for Advanced Persistent Threats</a></li>
<li><a href="https://omitedy.github.io/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/">DeepHunter: A Graph Neural Network Based Approach for Robust Cyber Threat Hunting</a></li>
<li><a href="https://omitedy.github.io/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/">HOLMES: Real-time APT Detection through Correlation of Suspicious Information Flows</a></li>
<li><a href="https://omitedy.github.io/2021/08/11/ATLAS-A-Sequence-based-Learning-Approach-for-Attack-Investigation/">ATLAS: A Sequence-based Learning Approach for Attack Investigation</a></li>
</ul>
<span id="more"></span>
<h3 id="威胁狩猎方法（DeepHunter）">威胁狩猎方法（DeepHunter）</h3>
<p>Poirot [1] 是跟 DeepHunter 相关的工作，在相关工作中提及，并在文章的 7.2 节中详细介绍后进行了性能对比。该章节中提到， Poirot 是当前威胁狩猎方法的前沿技术之一。Poirot 是一种基于启发式图特征匹配的算法，可以计算查询图和溯源图之间的图对齐分数。Poirot 根据查询图中的信息流在溯源图中搜索对齐的节点，在搜索的过程中忽略了攻击者不可能采取的路径。</p>
<p>RapSheet [2] 是一种可以使用溯源图分析提升 EDR 威胁狩猎能力的方法，但是 RapSheet 需要攻击者攻击的完全路径都被保存在溯源图上进行告警关联。显然，断开连接的攻击溯源图无疑会降低 RapSheet 的性能。</p>
<p>HOLMES [12] 和 NoDoze [3] 都采用了溯源图告警关联的方式进行 APT 检测和调查。</p>
<p>为了检测隐蔽的恶意软件，ProvDetector [4] 提出了一种图表示学习方法来进行溯源图上的进程正常行为建模。</p>
<p>然而以上这些方法，都会假设一个精确的正常行为数据库来减少错误告警。我们知道，随着良性行为的概念漂移，正常行为模型中有出现中毒攻击风险。此外，所有这些方法都是基于路径的方法，他们的健壮性可能会受到攻击溯源图不连通的影响。</p>
<p>有些方法使用 IOC 或者威胁警报作为识别攻击行为的线索，如 zero-day [5] 和 C&amp;C [6]，但是这些方法忽略了指示器或者警报之间的关系，因此，可能带来高误报率。</p>
<h3 id="溯源图分析（DeepHunter）">溯源图分析（DeepHunter）</h3>
<p>溯源图分析广泛应用于 APT 攻击检测 [7]，取证分析 [8] 和攻击场景重建 [9, 10] 等领域。</p>
<p>近期的工作有 [11, 12] 想要寻找关联低层系统事件和高层行为之间语义的方法。</p>
<p>很多近期的工作，如 Morse [8], BEEP [13], MPI [14], and OmegaLog [11] 等，是为了解决溯源图中依赖爆炸的问题。</p>
<p>SteamSpot [15] 将溯源图视为具有类型化节点和边的时态图，然后提出一种用于异常检测的图绘制算法。</p>
<h3 id="图匹配算法（DeepHunter）">图匹配算法（DeepHunter）</h3>
<p>图特征匹配和图相似度计算已经在许多实际应用中得到了应用，如二元函数相似性搜索 [16] 和硬件安全 [17]。在过去的几十年中，定义了许多图匹配度量，如图编辑距离/图同构等。其他基于 GNN 的图匹配算法有：MatchGNet [18]， SimGNN [19] and GMN [16]，在 DeepHunter 的第 7 章中有跟此三种算法的对比评估。</p>
<p>DeepHunter 设计的图嵌入网络表示溯源图，并采用 GCN [20] 来表示溯源图。最后使用了一个强大的关系学习网络 NTN [21]，来学习计算匹配分数的度量。通过这种新的设计实践，可以建立用用于图模式匹配的 GNN 模型，该模型对威胁搜索中查询图和溯源图之间不同程度的不一会具有识别健壮性。</p>
<h3 id="ATLAS">ATLAS</h3>
<p>近期工作，从审计日志构建因果依赖图的研究成果有 [13, 22]，使用查询系统定位关键攻击阶段，如受损进程和恶意负载 [8, 12]。还有一些研究志于将机器学习技术应用在从日志中提取特征或者序列来进行自动攻击检测和失败接测 [10, 23]，而其他人也构建了通过事件关联发现不同日志事件之间的关联 [44]。</p>
<h3 id="因果分析-ATLAS">因果分析 (ATLAS)</h3>
<p>基于审计日志的因果方面，已经有很多先前的工作了，包括优化溯源图和报告一个简短的攻击故事 [13, 22, 25]. 这些研究方法需要在运行时通过源代码插装/静态二进制插装和动态程序插装进行系统修改。</p>
<p>由于软件许可证的原因，源码级别的检测适用于专有软件，而静态和动态检测会给用户系统带来额外的开销，最近的工作提出了无需插装的方法 [2, 3, 11, 12, 26]，不需要对用户系统进行任何更改以进行起源跟踪。然而，这些方法中的大多数都是启发式的或者基于规则的，这需要花费大量的精力来开发和维护规则或者启发式算法。</p>
<p>Holmes 和 RapSheet 依赖于对抗战术/技术和程序（TTP）的知识库 [27]，相比之下， ATLAS只需要攻击训练数据，就可以通过时序序列了解攻击步骤的共现情况。</p>
<h3 id="基于异常检测的分析（ATLAS）">基于异常检测的分析（ATLAS）</h3>
<p>基于异常的方法 [3, 4, 28, 29] 学习正常系统的异常系统行为来识别异常行为。基于异常的方法可以检测到未知攻击，但由于用户行为随时间变化以及缺乏足够的训练数据，他们很容易出现误报。例如：</p>
<p>一个基于主机的入侵检测框架 UNICORN [30] 从正常的溯源图中学习到了正常行为模型来检测异常。</p>
<p>PrioTracker [29] 使用统计信息对节点重要性进行排序，以更准确地报告真实的攻击事件。</p>
<p>NoDoze [3] 通过在依赖关系图中计算和传播异常分数来减少假警报。</p>
<p>Winnower [28] 通过注意多个集群实例之间的差异，为集群审计提供威胁警报。</p>
<p>ProvDetector[4]通过从来源图中学习应用程序的正常执行路径序列来识别隐蔽恶意软件。</p>
<p>Deeplog [23] 将现有审计日志建模为自然语言序列，并检测异常事件。</p>
<p>最后，Log2vec [31] 提出了一个聚类框架，用于从系统日志中识别未发现的异常序列。</p>
<p>ATLAS 类似于只学习用户行为的基于异常的方法，它学习攻击和非攻击（用户）序列，并利用它们的时间和因果关系来减少误报和漏报。</p>
<h3 id="基于学习的分析（ATLAS）">基于学习的分析（ATLAS）</h3>
<p>基于学习的攻击调查方法 [10, 32, 33] 使用机器学习技术对日志中的攻击事件进行建模。</p>
<p>HERCULE [10] 使用社区检测算法关联攻击事件。与ATLAS相似，最近的一些著作 [32, 33] 使用单词 embedding 将文本信息（即序列）转换为向量，以促进其学习过程。但是，这些方法仅限于在日志中识别和报告单个攻击事件。与这些方法不同，ATLAS旨在定位攻击实体，并通过将每个实体与其事件关联来构建攻击故事。</p>
<h3 id="UNICORN">UNICORN</h3>
<p>最近很多工作 [12, 15, 34, 35, 36, 37] 指出对于 APT 检测来说，溯源图可能是一种更好的数据源。</p>
<p>事实上，现在也有可用框架来进行溯源图构建 [38]，但是由于并发性，这种 post-hoc 方法很难确保图的正确性 [39]. 由于很容易绕过基于库包装器的系统调用捕获机制 [41]，而用户空间机制，例如ptrace，会产生不可接受的运行时性能开销 [40]，并且容易受到竞争条件的影响 [41]。同样的竞争条件问题也困扰着内核机制（如，systrace [42]，janus [43]），导致从检查到使用时间（TOCTOU）/从审计到使用时间（TOATOU）以及从更换到使用时间（TORTTOU）的错误。</p>
<p>整个系统源代码收集在操作系统级别运行，捕获所有系统活动以及他们之间的交互 [39]。Hi-Fi [39]/ LPM [44] 和 CamFlow [36]等操作系统出处系统为信息流捕获提供了强大的安全性和完整性保证。这种完整性在 APT 场景中十分重要，因为它捕获了远距离因果关系，从而支持上下文分析，即使恶意代理操纵安全敏感内核对象来进行隐蔽，也能够根据上下文来进行关联发现。</p>
<p>文章参照了 CamFlow [36] 作为参考实施，在第六章中可以知道，UNICORN 也可以和其他捕获机制一同工作。CanFlow 接受 Linux Security Modules(LSM) 框架[45] 的数据来确保高质量/可靠地记录数据对象之间的信息流[46, 47]。LSM通 过在内核内部而不是在系统调用接口处放置中介点来消除竞争条件（例如TOCTTOU攻击）。</p>
<h3 id="基于图的异常检测（UNICORN）">基于图的异常检测（UNICORN）</h3>
<p>Akoglu 等人根据图的属性（即静态与动态、普通与属性化）通过分类图确定异常检测的图或子图相似性[48]。</p>
<p>Ding 等人 [30] 采用基于割点识别网络流量图中的恶意网络源识别方法，使用相似性度量（如介数）检测跨社区通信行为。</p>
<p>Liu 等人 [50] 构建了一个软件行为图来描述程序执行，并使用支持向量机（SVM）根据闭合子图和频繁子图对非崩溃错误（不会导致程序崩溃的逻辑错误）进行分类。</p>
<p>这些系统和许多其他图形挖掘算法 [51]、[52] 以及图形相似性度量（例如，图形内核[53]）仅针对静态图形设计，难以适应流式设置。</p>
<p>Papadimitriou 等人 [54] 提出了五种用于动态网络图的相似性方案，NetSimile [55] 使用分布矩来聚合基于 egonet 的特征（例如，邻居的数量），从而对社交网络进行聚类。Aggarwal 等人 [56] 使用结构连接性模型来定义异常值，并设计一种储层取样方法，该方法能够可靠地维护同质图形流的结构abstract。</p>
<p>然而，这些方法和其他面向流的方法 [57, 58, ]，要么是特定领域的（例如，书目网络的结构与来源图不同），要么主要适用于同质图.</p>
<p>在恶意软件分类和入侵检测领域，Classy [59] 对调用图流进行聚类，以便于基于图形编辑距离（GED）[60] 对使用改进版模拟退火的图形对进行恶意软件分析。尽管其运行时复杂性适合于图流，但经验评估仅限于顶点不超过3000个的图；实际系统执行产生的图形数量级更大[47]。</p>
<p>StreamSpot [15] 分析流式信息流图以检测异常活动。然而，StreamSpot的图形功能受到局部约束，在 UNICORN 的包含在执行上下文中。情境化图分析对检测性能有很大影响。此外，StreamSpot 只对每个训练图的一个快照建模，在测试期间动态维护其集群。但是，它会导致大量错误警报，从而为攻击者创建一个合适的时间窗口。我们也考虑这样的方法在 APT 场景中是不合适的，其中持久攻击者可以操作模型来逐渐地和缓慢地改变系统行为以避免检测。UNICORN充分利用其不断总结演进图的能力，对其监控的系统执行的相应演进进行建模。FRAPpuccino [61] 是另一种基于图形的入侵检测尝试。它使用一种窗口化方法来实现高效的图形分析。自然地，以这种方式分割溯源图会产生更有限的系统执行视图，不适合跨窗口的长期检测。</p>
<h3 id="基于溯源图的安全分析">基于溯源图的安全分析</h3>
<p>各种与安全相关的应用程序利用溯源图，主要用途有取证分析和攻击归因 [48]。</p>
<p>BackTracker [62] 使用溯源图分析入侵，以识别入侵的入口点，而 Priorttracker [29] 优化了这一过程，并启用了前向跟踪功能，以便及时进行攻击因果关系分析。</p>
<p>HERCULE [10] 通过发现溯源图中嵌入的攻击社区来分析入侵。</p>
<p>Winnower [28] 通过对溯源图的语法推理来加速系统入侵调查，同时在不影响出处数据质量的情况下减少存储和网络开销。</p>
<p>NoDoze [3] 在溯源图中执行攻击分类，以识别异常路径。Bates等人 [44] 是第一个使用源代码来防止数据丢失的人，Park等人 [63] 正式提出了基于源代码的访问控制（PBAC）的概念。Ma等人 [22] 设计了一个轻量级起源跟踪系统 ProTracer，以缓解依赖性爆炸问题，减少空间和运行时开销，促进基于起源的实际攻击调查。Pasquier等人 [47] 介绍了一种称为CamQuery的通用框架，该框架支持内联实时来源分析，展示了未来基于来源的安全应用的巨大潜力。</p>
<p>最近，随着APT攻击日益突出，许多系统利用数据来源进行APT攻击分析。Holmes [12] 和 Sleuth [9] 主要关注利用数据来源提供的信息流进行攻击重建。他们的方法类似于Tariq等人 [64] 提出的一种架构，该架构使用数据源关联网格应用程序中的异常活动。异常检测模块本身使用一个简单的预定义模型，该模型依赖于现有APT杀伤链的专家知识，将可能利用漏洞的先验规范与图中的局部组件相匹配。</p>
<p>Poirot [1] 产生了另一种形式的攻击重建。它将一系列折衷指标（由其他系统发现）关联起来，以识别APT。根据现有网络威胁情报报告和危害描述中的专家知识构建攻击查询图，Poirot在来源图上执行离线图模式匹配，以发现潜在的APT。例如，它使用红队的攻击描述手动绘制查询图，以关联第六章节评估中使用的DARPA数据集中的异常。这是一个关键的限制，因为编写一个新的APT类别的足够详细的描述需要大量的取证工作 [34]。</p>
<p>UNICORN与这些基于规则的系统的不同之处在于，它是一个基于异常的系统，不需要APT攻击模式和行为的先验专家知识。尽管基于规则的方法与当今的商业实践密切相关（即，它们基本上是企业安全供应商提供的端点检测和响应（EDR）工具的源代码版本），但先前的研究表明，基于规则的EDR系统是“威胁疲劳问题”的主要贡献者。最近关于起源分析的工作（例如，NoDoze[3]）表明，历史上下文文本对于缓解这一问题至关重要；相反，UNICORN研究如何将上下文作为重要部分纳入 HIDS，而不是仅仅作为分类工具。</p>
<p>Gao等人 [65] 利用复杂的事件处理平台，设计了一种特定于领域的查询语言 SAQL 来分析大规模流式来源数据。该系统结合了各种异常模型（例如，基于规则的异常）并跨多台主机聚合数据流，但最终需要专家领域知识来识别与查询匹配的元素/模式。我们还注意到，我们的溯源图分析能够隐式地（无需领域知识）合并其大多数异常模型（例如，基于不变量、时间序列和基于离群值）。Barre等人[34]挖掘数据来源以检测异常。他们的工作目标主要是识别可能与APT攻击相关的重要流程特征（例如，流程的生命周期和路径信息）。使用随机森林模型和手工挑选的过程特征，他们的系统的检测率只有50%左右。如此低的性能表明，在不考虑图拓扑的情况下对溯源图进行简单的特征工程，不足以检测隐藏的APT攻击。Berrada等人[35]提出了分数聚集技术，将来自不同异常检测器的异常分数结合起来，以提高检测性能。尽管他们的工作目标是APT检测的溯源图，但它与UNICORN（或任何其他检测器）的工作是相关的，因为它只作为现有异常检测系统的聚合器。</p>
<h3 id="告警关联（Holmes）">告警关联（Holmes）</h3>
<p>从历史上看，智能决策支持系统往往会产生对操作员来说数量太多、级别太低的警报。需要开发技术来总结这些低级警报，并大大减少它们的数量。</p>
<p>有几种方法使用报警相关性，通过聚类相似报警和识别报警之间的因果关系来执行检测[66]、[67]、[68]、[69]、[70。例如，BotHunter[71]采用基于异常的方法来关联网络中内部和外部主机之间的对话。HERCULE [10] 使用社区发现技术关联可能分散在多个日志中的攻击步骤.</p>
<p>此外，业界使用类似的方法来构建SIEMs [72]、[73]、[74]，以便基于来自不同数据源的日志进行警报关联和实施。这些方法依赖于在用户空间中运行的第三方应用程序生成的日志。此外，基于警报时间戳等统计特征的警报相关性无助于准确检测多阶段APT攻击，因为它们通常持续时间较长。</p>
<p>与这些方法不同，HOLMES基于存在于不同攻击步骤之间的信息流来进行警报关联。在这种情况下使用内核审计数据是在[75]中首次提出的。然而，与HOLMES不同的是，这项工作纯粹是基于误用的，其重点是利用事件之间的相关性来检测IDS遗漏的攻击步骤。</p>
<p>HOLMES使用了相同的内核审计数据，但采用了不同的方法，即构建内存占用率低的主内存依赖关系图，然后根据TTP的高级规范推导HSG以引发警报，最后根据警报之间的信息流关联警报。关于警报相关性的另一项工作依赖于警报在时间上的接近程度 [76]。相比之下，HOLMES依靠信息流和因果关系连接来关联警报，因此甚至能够检测执行步骤非常缓慢的攻击。</p>
<h3 id="场景重建（Holmes）">场景重建（Holmes）</h3>
<p>大量研究工作集中于在取证分析、调查和恢复中生成和使用系统调用级日志[13]、 [14]、[22]、[29]、[38]、[39]、[44]  、[55]、[77]、[78]、[79]、[80]、[81]。</p>
<p>大多数取证分析方法可追溯到给定的攻击事件，以确定该攻击的原因。其中，BEEP[13]、ProTracer[22]和MPI[14]使用培训和代码工具和注释将流程执行划分为更小的单元，以解决依赖性爆炸问题，并提供更好的取证分析。PrioTracker[29]通过量化事件罕见性的概念来进行及时的因果关系分析，以确定异常因果依赖性调查的优先级。相比之下，HOLMES使用系统事件跟踪来执行实时检测，在检测框架中集成了取证功能，以高级攻击步骤的形式进行，而不需要仪器。</p>
<p>最近的研究[9]、[47]、[82]使用系统调用级别日志进行实时分析。SLEUTH[9]介绍了用于攻击检测和现场取证的基于标签的技术。HOLMES在侦查方面取得了几项重大进展。首先，它展示了如何通过使用最小祖先覆盖的概念来解决依赖爆炸问题，并为其增量计算开发了一个有效的算法。其次，SLEUTH的场景图与溯源图处于同一抽象级别，对于许多分析师来说，溯源图的抽象级别可能太低，而且缺乏HSGs中的可操作信息。第三，在长时间运行的攻击中，SLEUTH的图可能变得太大，而HOLMES通过使用降噪和优先级技术生成紧凑的HSG。</p>
<h3 id="攻击粒度">攻击粒度</h3>
<p>有时，审计日志的粗粒度可能会限制对信息流的推理。例如，如果具有先前加载的敏感文件的进程被破坏，攻击者可以在其内存区域内搜索敏感内容，而无需使用系统调用。但是，当这些信息被过滤时，HOLMES会将过滤与该进程敏感文件（读取）的其他操作关联起来，并最终引发异常。此外，HOLMES还可以通过附加指令[83]、[84]或去耦污点跟踪[85]、[86]、[87]、[88]，利用附加工作，以更精细的粒度跟踪信息流。这种细粒度的信息流跟踪可以提供更精确的起源信息，但代价是性能开销。</p>
<h3 id="参考文献">参考文献</h3>
<p>[1] Milajerdi, S.M., Eshete, B., Gjomemo, R., Venkatakrishnan, V.: Poirot: Aligning attack behavior with kernel audit records for cyber threat hunting. In: Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. pp. 1795–1812 (2019)</p>
<p>[2] Hassan, W.U., Bates, A., Marino, D.: Tactical provenance analysis for endpoint detection and response systems. In: Proceedings of the IEEE Symposium on Security and Privacy (2020)</p>
<p>[3] Hassan, W.U., Guo, S., Li, D., Chen, Z., Jee, K., Li, Z., Bates, A.: Nodoze: Combatting threat alert fatigue with automated provenance triage. In: NDSS (2019)</p>
<p>[4] Wang, Q., Hassan, W.U., Li, D., Jee, K., Yu, X., Zou, K., Rhee, J., Chen, Z., Cheng, W., Gunter, C., et al.: You are what you do: Hunting stealthy malware via data provenance analysis. In: Proc. of the Symposium on Network and Distributed System Security (NDSS) (2020)</p>
<p>[5] Sun, X., Dai, J., Liu, P., Singhal, A., Yen, J.: Using bayesian networks for proba- bilistic identification of zero-day attack paths. IEEE Transactions on Information Forensics and Security 13(10), 2506–2521 (2018)</p>
<p>[6] Oprea, A., Li, Z., Yen, T.F., Chin, S.H., Alrwais, S.: Detection of early-stage en- terprise infection by mining large-scale log data. In: 2015 45th Annual IEEE/IFIP International Conference on Dependable Systems and Networks. pp. 45–56. IEEE (2015)</p>
<p>[7] Xiong, C., Zhu, T., Dong, W., Ruan, L., Yang, R., Chen, Y., Cheng, Y., Cheng, S., Chen, X.: Conan: A practical real-time apt detection system with high accuracy and efficiency. IEEE Transactions on Dependable and Secure Computing (2020)</p>
<p>[8] Hossain, M.N., Sheikhi, S., Sekar, R.: Combating dependence explosion in forensic analysis using alternative tag propagation semantics. In: 2020 IEEE Symposium on Security and Privacy (SP). IEEE (2020)</p>
<p>[9] Hossain, M.N., Milajerdi, S.M., Wang, J., Eshete, B., Gjomemo, R., Sekar, R., Stoller, S., Venkatakrishnan, V.: {SLEUTH}: Real-time attack scenario recon- struction from {COTS} audit data. In: 26th {USENIX} Security Symposium ({USENIX} Security 17). pp. 487–504 (2017)</p>
<p>[10] Pei, K., Gu, Z., Saltaformaggio, B., Ma, S., Wang, F., Zhang, Z., Si, L., Zhang, X., Xu, D.: Hercule: Attack story reconstruction via community discovery on correlated log graph. In: Proceedings of the 32Nd Annual Conference on Computer Security Applications. pp. 583–595 (2016)</p>
<p>[11] Hassan, W.U., Noureddine, M.A., Datta, P., Bates, A.: Omegalog: High-fidelity attack investigation via transparent multi-layer log analysis. In: Proc. NDSS (2020)</p>
<p>[12] Milajerdi, S.M., Gjomemo, R., Eshete, B., Sekar, R., Venkatakrishnan, V.: Holmes: real-time apt detection through correlation of suspicious information flows. In: 2019 IEEE Symposium on Security and Privacy (SP). pp. 1137–1152. IEEE (2019)</p>
<p>[13] Lee, K.H., Zhang, X., Xu, D.: High accuracy attack provenance via binary-based execution partition. In: NDSS (2013)</p>
<p>[14] Ma, S., Zhai, J., Wang, F., Lee, K.H., Zhang, X., Xu, D.: {MPI}: Multiple per- spective attack investigation with semantic aware execution partitioning. In: 26th {USENIX} Security Symposium ({USENIX} Security 17). pp. 1111–1128 (2017)</p>
<p>[15] Manzoor, E., Milajerdi, S.M., Akoglu, L.: Fast memory-efficient anomaly detection in streaming heterogeneous graphs. In: Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. pp. 1035–1044 (2016)</p>
<p>[16] Li, Y., Gu, C., Dullien, T., Vinyals, O., Kohli, P.: Graph matching networks for learning the similarity of graph structured objects. In: Chaudhuri, K., Salakhutdi- nov, R. (eds.) Proceedings of the 36th International Conference on Machine Learn- ing. Proceedings of Machine Learning Research, vol. 97, pp. 3835–3845. PMLR, Long Beach, California, USA (09–15 Jun 2019), <a href="http://proceedings.mlr.press/v97/li19d.html">http://proceedings.mlr.press/v97/li19d.html</a></p>
<p>[17] Fyrbiak, M., Wallat, S., Reinhard, S., Bissantz, N., Paar, C.: Graph similarity and its applications to hardware security. IEEE Transactions on Computers 69(4), 505–519 (2019)</p>
<p>[18] Wang, S., Chen, Z., Yu, X., Li, D., Ni, J., Tang, L.A., Gui, J., Li, Z., Chen, H., Yu, P.S.: Heterogeneous graph matching networks for unknown malware detection. In: Proceedings of the 28th International Joint Conference on Artificial Intelligence. pp. 3762–3770. AAAI Press (2019)</p>
<p>[19] Bai, Y., Ding, H., Bian, S., Chen, T., Sun, Y., Wang, W.: Simgnn: A neural network approach to fast graph similarity computation. In: Proceedings of the Twelfth ACM International Conference on Web Search and Data Mining. pp. 384–392 (2019)</p>
<p>[20] Kipf, T.N., Welling, M.: Semi-supervised classification with graph convolutional networks. arXiv preprint arXiv:1609.02907 (2016)</p>
<p>[21] Socher, R., Chen, D., Manning, C.D., Ng, A.: Reasoning with neural tensor net- works for knowledge base completion. In: Advances in neural information process- ing systems. pp. 926–934 (2013)</p>
<p>[22] Shiqing Ma, Xiangyu Zhang, and Dongyan Xu. Protracer: Towards practical provenance tracing by alternating between logging and tainting. In Network and Distributed Systems Security Symposium, 2016.</p>
<p>[23] Min Du, Feifei Li, Guineng Zheng, and Vivek Srikumar. Deeplog: Anomaly detection and diagnosis from system logs through deep learning. In ACM SIGSAC Conference on Com- puter and Communications Security, 2017.</p>
<p>[24] Riyanat Shittu, Alex Healing, Robert Ghanea-Hercock, Robin Bloomfield, and Muttukrishnan Rajarajan. Intrusion alert pri- oritisation and attack detection using post-correlation analysis. Computers &amp; Security, 50:1–15, 2015.</p>
<p>[25] Yonghwi Kwon, Fei Wang, Weihang Wang, Kyu Hyung Lee, Wen-Chuan Lee, Shiqing Ma, Xiangyu Zhang, Dongyan Xu, Somesh Jha, Gabriela Ciocarlie, et al. Mci: Modeling-based causality inference in audit logging for attack investigation. In Network and Distributed Systems Security Symposium, 2018.</p>
<p>[26] Runqing Yang, Shiqing Ma, Haitao Xu, Xiangyu Zhang, and Yan Chen. Uiscope: Accurate, instrumentation-free, and visi- ble attack investigation for gui applications. In Network and Distributed Systems Symposium, 2020.</p>
<p>[27] MITRE. Mitre att&amp;ck. <a href="https://attack.mitre.org/">https://attack.mitre.org/</a>, 2020. Accessed: 2020-06-06.</p>
<p>[28] Wajih Ul Hassan, Mark Lemay, Nuraini Aguse, Adam Bates, and Thomas Moyer. Towards scalable cluster auditing through grammatical inference over provenance graphs. In Network and Distributed Systems Security Symposium, 2018.</p>
<p>[29] Yushan Liu, Mu Zhang, Ding Li, Kangkook Jee, Zhichun Li, Zhenyu Wu, Junghwan Rhee, and Prateek Mittal. Towards a timely causality analysis for enterprise security. In Network and Distributed Systems Security Symposium, 2018.</p>
<p>[30] Xueyuan Han, Thomas Pasquier, Adam Bates, James Mick- ens, and Margo Seltzer. Unicorn: Runtime provenance- based detector for advanced persistent threats. arXiv preprint arXiv:2001.01525, 2020.</p>
<p>[31] Fucheng Liu, Yu Wen, Dongxue Zhang, Xihe Jiang, Xinyu Xing, and Dan Meng. Log2vec: A heterogeneous graph em- bedding based approach for detecting cyber threats within en- terprise. In Proceedings ofthe 2019 ACM SIGSAC Conference on Computer and Communications Security, 2019.</p>
<p>[32] Yun Shen, Enrico Mariconti, Pierre Antoine Vervier, and Gi- anluca Stringhini. Tiresias: Predicting security events through deep learning. In ACM SIGSAC Conference on Computer and Communications Security, 2018.</p>
<p>[33] Yun Shen and Gianluca Stringhini. Attack2vec: Leveraging temporal word embeddings to understand the evolution of cy- berattacks. In USENIX Security Symposium, 2019.</p>
<p>[34] M. Barre, A. Gehani, and V. Yegneswaran, “Mining data provenance to detect advanced persistent threats,” in 11th International Workshop on Theory and Practice of Provenance (TaPP), 2019.</p>
<p>[35] G. Berrada and J. Cheney, “Aggregating unsupervised provenance anomaly detectors,” in 11th International Workshop on Theory and Practice of Provenance (TaPP), 2019.</p>
<p>[36] T. Pasquier, X. Han, M. Goldstein, T. Moyer, D. Eyers, M. Seltzer, and J. Bacon, “Practical whole-system provenance capture,” in Symposium on Cloud Computing. ACM, 2017, pp. 405–418.</p>
<p>[37] L. Carata, S. Akoush, N. Balakrishnan, T. Bytheway, R. Sohan, M. Seltzer, and A. Hopper, “A primer on provenance,” ACM Queue, vol. 12, no. 3, p. 10, 2014.</p>
<p>[38] A. Gehani anSadegh M. Milajerdi, Birhanu Eshete, Rigel Gjomemo, and V.N. Venkatakrishnan. Propatrol: Attack investigation via extracted high- level tasks. In International Conference on Information Systems Security. Springer, 2018.d D. Tariq, “Spade: support for provenance auditing in distributed environments,” in Middleware Conference. ACM/I- FIP/USENIX, 2012, pp. 101–120.</p>
<p>[39] D. J. Pohly, S. McLaughlin, P. McDaniel, and K. Butler, “Hi-fi: col- lecting high-fidelity whole-system provenance,” in Computer Security Applications Conference. ACM, 2012, pp. 259–268.</p>
<p>[40] T. Garfinkel et al., “Traps and pitfalls: Practical problems in system call interposition based security tools.” in NDSS, vol. 3, 2003, pp. 163–176.</p>
<p>[41] K. Jain and R. Sekar, “User-level infrastructure for system call interposition: A platform for intrusion detection and confinement.” in NDSS, 2000.</p>
<p>[42] N. Provos, “Systrace-interactive policy generation for system calls,” 2006.</p>
<p>[43] I. Goldberg, D. Wagner, R. Thomas, E. A. Brewer et al., “A secure environment for untrusted helper applications: Confining the wily hacker,” in USENIX Security Symposium, vol. 6, 1996, pp. 1–1.</p>
<p>[44] A. M. Bates, D. Tian, K. R. Butler, and T. Moyer, “Trustworthy whole-system provenance for the linux kernel.” in USENIX Security Symposium, 2015, pp. 319–334.</p>
<p>[45] J. Morris, S. Smalley, and G. Kroah-Hartman, “Linux security mod- ules: General security support for the linux kernel,” in USENIX Security Symposium, 2002.</p>
<p>[46] L. Georget, M. Jaume, F. Tronel, G. Piolle, and V. V. T. Tong, “Veri- fying the reliability of operating system-level information flow control systems in linux,” in International Workshop on Formal Methods in Software Engineering. IEEE/ACM, 2017, pp. 10–16.</p>
<p>[47] T. Pasquier, X. Han, T. Moyer, A. Bates, O. Hermant, D. Eyers, J. Ba- con, and M. Seltzer, “Runtime analysis of whole-system provenance,” in Conference on Computer and Communications Security (CCS’18). ACM, 2018.</p>
<p>[48] L. Akoglu, H. Tong, and D. Koutra, “Graph based anomaly detection and description: a survey,” Data mining and knowledge discovery, vol. 29, no. 3, pp. 626–688, 2015.</p>
<p>[49] Q. Ding, N. Katenka, P. Barford, E. Kolaczyk, and M. Crovella, “Intrusion as (anti) social communication: characterization and detection,” in International Conference on Knowledge Discovery and Data Mining. ACM, 2012, pp. 886–894.</p>
<p>[50] C. Liu, X. Yan, H. Yu, J. Han, and P. S. Yu, “Mining behavior graphs for backtrace of noncrashing bugs,” in International Conference on Data Mining. SIAM, 2005, pp. 286–297.</p>
<p>[51] J. Gao, F. Liang, W. Fan, C. Wang, Y. Sun, and J. Han, “On community outliers and their efficient detection in information networks,” in International Conference on Knowledge Discovery and Data Mining. ACM, 2010, pp. 813–822.</p>
<p>[52] B. Perozzi, L. Akoglu, P. Iglesias S´anchez, and E. M¨uller, “Focused clustering and outlier detection in large attributed graphs,” in Interna- tional Conference on Knowledge Discovery and Data Mining. ACM, 2014, pp. 1346–1355.<br>
[53] S. V. N. Vishwanathan, N. N. Schraudolph, R. Kondor, and K. M. Borgwardt, “Graph kernels,” Journal of Machine Learning Research, vol. 11, no. Apr, pp. 1201–1242, 2010.</p>
<p>[54] P. Papadimitriou, A. Dasdan, and H. Garcia-Molina, “Web graph similarity for anomaly detection,” Journal of Internet Services and Applications, vol. 1, no. 1, pp. 19–30, 2010.</p>
<p>[55] MS. T. King and P. M. Chen, “Backtracking intrusions,” ACM SIGOPS Operating Systems Review, vol. 37, no. 5, pp. 223–236, 2003… Berlingerio, D. Koutra, T. Eliassi-Rad, and C. Faloutsos, “Netsim- ile: A scalable approach to size-independent network similarity,” arXiv preprint arXiv:1209.2684, 2012.</p>
<p>[56] C. C. Aggarwal, Y. Zhao, and S. Y. Philip, “Outlier detection in graph streams,” in International Conference on Data Engineering (ICDE). IEEE, 2011.</p>
<p>[57] M. Gupta, C.Sadegh M. Milajerdi, Birhanu Eshete, Rigel Gjomemo, and V.N. Venkatakrishnan. Propatrol: Attack investigation via extracted high- level tasks. In International Conference on Information Systems Security. Springer, 2018. C. Aggarwal, J. Han, and Y. Sun, “Evolutionary clustering and analysis of bibliographic networks,” in Conference on Advances in Social Networks Analysis and Mining. IEEE, 2011, pp. 63–70.</p>
<p>[58] M. Mongiovi, P. Bogdanov, R. Ranca, E. E. Papalexakis, C. Faloutsos, and A. K. Singh, “Netspot: Spotting significant anomalous regions on dynamic networks,” in International Conference on Data Mining. SIAM, 2013, pp. 28–36.</p>
<p>[59] O. Kostakis, “Classy: fast clustering streams of call-graphs,” Data mining and knowledge discovery, vol. 28, no. 5-6, pp. 1554–1585, 2014.<br>
[60] X. Gao, B. Xiao, D. Tao, and X. Li, “A survey of graph edit distance,” Pattern Analysis and applications, vol. 13, no. 1, pp. 113–129, 2010.<br>
[61] X. Han, T. Pasquier, T. Ranjan, M. Goldstein, and M. Seltzer, “Frappuccino: fault-detection through runtime analysis of provenance,” in Workshop on Hot Topics in Cloud Computing (HotCloud’17). USENIX Association, 2017.</p>
<p>[62] S. T. King and P. M. Chen, “Backtracking intrusions,” ACM SIGOPS Operating Systems Review, vol. 37, no. 5, pp. 223–236, 2003.</p>
<p>[63] J. Park, D. Nguyen, and R. Sandhu, “A provenance-based access control model,” in International Conference on Privacy, Security and Trust. IEEE, 2012, pp. 137–144.</p>
<p>[64] D. Tariq, B. Baig, A. Gehani, S. Mahmood, R. Tahir, A. Aqil, and F. Zaffar, “Identifying the provenance of correlated anomalies,” in Symposium on Applied Computing. ACM, 2011, pp. 224–229.</p>
<p>[65] P. Gao, X. Xiao, D. Li, Z. Li, K. Jee, Z. Wu, C. H. Kim, S. R. Kulkarni, and P. Mittal, “Saql: A stream-based query system for real- time abnormal system behavior detection,” in 27th USENIX Security Symposium (USENIX Security 18), 2018, pp. 639–656.</p>
<p>[66] Herv´e Debar and Andreas Wespi. Aggregation and correlation of intrusion-detection alerts. In RAID. Springer, 2001.</p>
<p>[67] Peng Ning and Dingbang Xu. Learning attack strategies from intrusion alerts. In CCS. ACM, 2003.</p>
<p>[68] Correlating intrusion events and building attack scenarios through attack graph distances.</p>
<p>[69] Xinzhou Qin and Wenke Lee. Statistical causality analysis of infosec alert data. In RAID. Springer, 2003.</p>
<p>[70] Wei Wang and Thomas E Daniels. A graph based approach toward network forensics analysis. Transactions on Information and System Security (TISSEC), 2008.</p>
<p>[71] Guofei Gu, Phillip Porras, Vinod Yegneswaran, and Martin Fong. Bothunter: Detecting malware infection through ids-driven dialog cor- relation. In 16th USENIX Security Symposium (USENIX Security 07). USENIX Association, 2007.</p>
<p>[72] IBM QRadar SIEM.<br>
<a href="https://www.ibm.com/us-en/marketplace/">https://www.ibm.com/us-en/marketplace/</a><br>
ibm-qradar-siem.<br>
[73 ] Logrhythm, the security intelligence company. <a href="https://logrhythm.com/">https://logrhythm.com/</a>. [<br>
[74] SIEM, AIOps, Application Management, Log Management, Machine Learning, and Compliance. <a href="https://www.splunk.com/">https://www.splunk.com/</a>.<br>
[75] Yan Zhai, Peng Ning, and Jun Xu. Integrating ids alert correlation and os-level dependency tracking. In International Conference on Intelligence and Security Informatics, pages 272–284. Springer, 2006.</p>
<p>[76] Christopher Kruegel, Fredrik Valeur, and Giovanni Vigna. Intrusion de- tection and correlation: challenges and solutions, volume 14. Springer Science &amp; Business Media, 2004.</p>
<p>[77] Momeni Milajerdi, S., Gjomemo, R., Eshete, B., Sekar, R., &amp; Venkatakrishnan, V. N. (2019). HOLMES: Real-time APT detection through correlation of suspicious information flows. <em>Proceedings - IEEE Symposium on Security and Privacy</em>, <em>2019</em>-<em>May</em>, 1137–1152. <a href="https://doi.org/10.1109/SP.2019.00026">https://doi.org/10.1109/SP.2019.00026</a></p>
<p>[78] Ashvin Goel, Kenneth Po, Kamran Farhadi, Zheng Li, and Eyal de Lara. The taser intrusion recovery system. SIGOPS Oper. Syst. Rev., 2005.</p>
<p>[79] Samuel T King, Zhuoqing Morley Mao, Dominic G Lucchetti, and Peter M Chen. Enriching intrusion alerts through multi-host causality. In NDSS, 2005.</p>
<p>[80] Sadegh M. Milajerdi, Birhanu Eshete, Rigel Gjomemo, and V.N. Venkatakrishnan. Propatrol: Attack investigation via extracted high- level tasks. In International Conference on Information Systems Security. Springer, 2018.</p>
<p>[81] Qi Wang, Wajih Ul Hassan, Adam Bates, and Carl Gunter. Fear and logging in the internet of things. In Network and Distributed Systems Symposium, 2018.</p>
<p>[82] Xiaokui Shu, Frederico Araujo, Douglas L. Schales, Marc Ph. Stoecklin, Jiyong Jang, Heqing Huang, and Josyula R. Rao. Threat intelligence computing. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS ’18, pages 1883–1898, New York, NY, USA, 2018. ACM.</p>
<p>[83] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bodden, Alexan- dre Bartel, Jacques Klein, Yves Le Traon, Damien Octeau, and Patrick McDaniel. Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for android apps. SIGPLAN Not., 2014.<br>
[84] Vasileios P. Kemerlis, Georgios Portokalidis, Kangkook Jee, and Ange- los D. Keromytis. Libdft: Practical Dynamic Data Flow Tracking for Commodity Systems. SIGPLAN Not., 2012.</p>
<p>[85] Jim Chow, Tal Garfinkel, and Peter M Chen. Decoupling dynamic program analysis from execution in virtual environments. In USENIX 2008 Annual Technical Conference on Annual Technical Conference, pages 1–14, 2008.</p>
<p>[86] Yang Ji, Sangho Lee, Evan Downing, Weiren Wang, Mattia Fazzini, Taesoo Kim, Alessandro Orso, and Wenke Lee. Rain: Refinable attack investigation with on-demand inter-process information flow tracking. In Proceedings ofthe 2017 ACM SIGSAC Conference on Computer and Communications Security, pages 377–390. ACM, 2017.</p>
<p>[87] Yonghwi Kwon, Fei Wang, Weihang Wang, Kyu Hyung Lee, Wen- Chuan Lee, Shiqing Ma, Xiangyu Zhang, Dongyan Xu, Somesh Jha, Gabriela Ciocarlie, et al. Mci: Modeling-based causality inference in audit logging for attack investigation. In Proc. of the 25th Network and Distributed System Security Symposium (NDSS18), 2018.</p>
<p>[88] Jiang Ming, Dinghao Wu, Jun Wang, Gaoyao Xiao, and Peng Liu. Straighttaint: Decoupled offline symbolic taint analysis. In Proceedings ofthe 31st IEEE/ACM International Conference on Automated Software Engineering, pages 308–319. ACM, 2016.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
        <tag>APT</tag>
        <tag>相关工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Accurate, Low Cost and Instrumentation-Free Security Audit Logging for Windows</title>
    <url>/2022/04/15/Accurate-Low-Cost-and-Instrumentation-Free-Security-Audit-Logging-for-Windows/</url>
    <content><![CDATA[<p>Accurate, Low Cost and Instrumentation-Free Security Audit Logging for Windows abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>传统审计日志缺乏准确率，并且需要大量计算和分析二进制命令。<br>
因此提出一种基于 Windows 的日志审计技术来提高准确率和降低计算消耗。</p>
<h2 id="main-contribution">main contribution</h2>
<ul>
<li>基于 ETW 的新型无工具审计日志记录技术，可以自动识别其 迭代表示自动执行单元的事件循环</li>
<li>基于单元的准确的因果推理，可以进行有效地数据去冗余</li>
</ul>
<h2 id="具体实现">具体实现</h2>
<p>基本溯源图和本文生成的精简溯源图表示：</p>
<p><img src="/2022/04/15/Accurate-Low-Cost-and-Instrumentation-Free-Security-Audit-Logging-for-Windows/graph.png" alt="arch"></p>
<p>方法总体架构图下：</p>
<p><img src="/2022/04/15/Accurate-Low-Cost-and-Instrumentation-Free-Security-Audit-Logging-for-Windows/arch.png" alt="arch"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Adversarial Robustness Toolbox</title>
    <url>/2023/03/12/Adversarial-Robustness-Toolbox/</url>
    <content><![CDATA[<p>Contribution analysis of adverarial robustness toolbox.</p>
<span id="more"></span>
<h2 id="Summary-in-a-word">Summary in a word</h2>
<p><a href="https://adversarial-robustness-toolbox.readthedocs.io/en/latest/">Adversarial Robustness Toolbox (ART)</a> is Python library providing tools to build and deploy defences and test defences with adversarial attack.<br>
It includes state-of-the-art attacks, defences, evaluation metrics and other useful tools.<br>
The architecture of ART:<br>
<img src="/2023/03/12/Adversarial-Robustness-Toolbox/art_architecture.png" alt="art-arch"></p>
<h2 id="Conclusion">Conclusion</h2>
<p>It’s a tool framework with attacks, defences and evaluation integrated.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>backdoor</tag>
        <tag>toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>AttacKG: Constructing Technique Knowledge Graph from Cyber Threat Intelligence Reports</title>
    <url>/2022/04/20/AttacKG-Constructing-Technique-Knowledge-Graph-from-Cyber-Threat-Intelligence-Reports/</url>
    <content><![CDATA[<p>AttacKG: Constructing Technique Knowledge Graph from Cyber Threat Intelligence Reports abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>网络攻击越来越复杂和多样，为了对抗这些攻击，安全分析人员总结和交换了关于系统的知识，也就是威胁情报（cyber threat intelligence）。然而，用自然语言文本编写成的CTI报告不是为自动分析而构建的，因此报告的使用需要人工进行网络情报恢复的繁琐工作。此外，个别高高通常仅涵盖攻击模式等有限方面，因此不足以提供具有多变体的攻击全景图。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/20/AttacKG-Constructing-Technique-Knowledge-Graph-from-Cyber-Threat-Intelligence-Reports/arch.png" alt="arch"><br>
为了利用 cti 的优势，我们提出了 AttacKg 来自动从 cti 报告中提取结构化的攻击行为图并识别采用的技术。</p>
<p>然后，我们在报告中汇总网络情报，以手机技术的不同方面的信息，并将攻击行为图增强为技术知识图（technique knowledge graphs, TKGs）。TKGs 可以为下游依赖技术细节的任务提供攻击技术层级的知识，诸如 APT 检测。</p>
<h2 id="思路和方法">思路和方法</h2>
<h3 id="从-CTI-报告提取攻击图">从 CTI 报告提取攻击图</h3>
<p>从 CTI 报告中提取出攻击图，提出了一个包含五个步骤的管道处理方式：</p>
<ul>
<li>IoC protection, 注意 IoC 为 indicator of compromise 的简写，为 ATT&amp;CK 框架中探针的专有名词</li>
<li>Attack entities extraction</li>
<li>Attack dependency extraction</li>
<li>Attack graph generation</li>
<li>Attack graph simplification</li>
</ul>
<p>该管道包含两个输入：</p>
<ul>
<li>MITRE ATT&amp;CK 攻击知识</li>
<li>CTI 报告</li>
</ul>
<h3 id="使用模板识别攻击技术">使用模板识别攻击技术</h3>
<p>单独报告在技术特征方面具有片面性，无法提供全面的有效特征，因此在此部分提出了一个攻击技术模板来聚合不同报告中出现的攻击技术特征，并且提出了一个基于模板的改进的图对齐算法来识别攻击图中的技术以实现这一目标。</p>
<p>经过此步骤，可以获得两个输出：</p>
<ul>
<li>汇集了大量CTI报告中攻击技术特征的技术模板</li>
<li>汇聚了大量CTI报告中攻击链的TKGs</li>
</ul>
<h3 id="CTI-报告解析器">CTI 报告解析器</h3>
<p>报告解析器的难点在于准确地从自然语言书写的报告中提取攻击行为。<br>
在解析器中，我们主要解决了一下难题：</p>
<ul>
<li>领域专有名词</li>
<li>非IoC实体的提取</li>
<li>依赖提取</li>
<li>共同指向解决</li>
</ul>
<h4 id="基于正则表达式的-IoC-识别和保护">基于正则表达式的 IoC 识别和保护</h4>
<h4 id="攻击实体提取">攻击实体提取</h4>
<p><img src="/2022/04/20/AttacKG-Constructing-Technique-Knowledge-Graph-from-Cyber-Threat-Intelligence-Reports/attack-entities-extraction.png" alt="attack entities extraction"></p>
<h4 id="攻击依赖提取">攻击依赖提取</h4>
<h4 id="攻击图生成和简化">攻击图生成和简化</h4>
<h3 id="技术模板和图对齐算法">技术模板和图对齐算法</h3>
<h4 id="技术模板设计">技术模板设计</h4>
<p><img src="/2022/04/20/AttacKG-Constructing-Technique-Knowledge-Graph-from-Cyber-Threat-Intelligence-Reports/eg-template.png" alt="template"></p>
<h4 id="用于识别攻击技术和攻击技术知识图构建的图对齐">用于识别攻击技术和攻击技术知识图构建的图对齐</h4>
<p><strong>节点对齐</strong>和<strong>图对齐</strong></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源图构建</tag>
        <tag>威胁情报</tag>
      </tags>
  </entry>
  <entry>
    <title>Backdoor Attacks and Countermeasures on Deep Learning: A Comprehensive Review</title>
    <url>/2022/07/14/Backdoor-Attacks-and-Countermeasures-on-Deep-Learning-A-Comprehensive-Review/</url>
    <content><![CDATA[<p>Backdoor Attacks and Countermeasures on Deep Learning: A Comprehensive Review abstract。</p>
<span id="more"></span>
<h2 id="abstract">abstract</h2>
<p>文章通过目录和表格等多种形式对相关文献进行分类，看起来相对清晰。具体 如下图：</p>
<p><img src="/2022/07/14/Backdoor-Attacks-and-Countermeasures-on-Deep-Learning-A-Comprehensive-Review/summary.png" alt="summary"></p>
<h2 id="目录">目录</h2>
<p><img src="/2022/07/14/Backdoor-Attacks-and-Countermeasures-on-Deep-Learning-A-Comprehensive-Review/categories-1.png" alt="categories-1"><br>
<img src="/2022/07/14/Backdoor-Attacks-and-Countermeasures-on-Deep-Learning-A-Comprehensive-Review/categories-2.png" alt="categories-2"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Survey</tag>
        <tag>AI Backdoor Attacks</tag>
      </tags>
  </entry>
  <entry>
    <title>Back-Propagating System Dependency Impact for Attack Investigation</title>
    <url>/2022/04/18/Back-Propagating-System-Dependency-Impact-for-Attack-Investigation/</url>
    <content><![CDATA[<p>Back-Propagating System Dependency Impact for Attack Investigation abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>系统审计日志上的因果分析成为了攻击调查的重要方法，给定一个事件（point-of-interest event, POI event），通过因果分析可以构建该事件的因果依赖图，使用因果依赖图来进行攻击序列的发现。<br>
然而因果分析同行会产生一张极大的图，这会对安全专家的分析造成困难。<br>
针对以上问题，提出解决方案。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/18/Back-Propagating-System-Dependency-Impact-for-Attack-Investigation/arch.png" alt="arch"></p>
<p>从不同攻击的依赖图中，我们观察到一下特点：</p>
<ul>
<li>与 POI 事件高度相关的依赖项与 不太相关的依赖项相比，通常表现出不同的一组属性（eg. 数据流和时间）</li>
<li>POI 事件通常与一些攻击条目相关（eg. 下载文件）</li>
</ul>
<p>基于上述观察，提出 DEPIMPACT 来识别依赖图中的关键部分，该框架通过以下方法实现：</p>
<ul>
<li>为边分配可以判断依赖重要性的权重</li>
<li>将依赖影响从 POI 事件反向传播到入口点</li>
<li>根据依赖影响排名，从排名靠前的入口节点执行前向因果关系分析，过滤掉前向因果关系分析中未找到的边</li>
</ul>
<p><img src="/2022/04/18/Back-Propagating-System-Dependency-Impact-for-Attack-Investigation/eg.png" alt="eg"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击调查</tag>
      </tags>
  </entry>
  <entry>
    <title>An Overview of Backdoor Attacks Against Deep Neural Networks and Possible Defences</title>
    <url>/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/</url>
    <content><![CDATA[<p>An Overview of Backdoor Attacks Against Deep Neural Networks and Possible Defences abstract。</p>
<span id="more"></span>
<h2 id="abstract">abstract</h2>
<p>文章首先介绍了威胁模型，然后根据攻击者对模型训练过程不同的控制程度，分类而成的各种攻击方式，最后是防御方式与公开讨论。本文主要讨论能够控制训练过程的后门攻击，而不包括那些可以直接修改参数的后门攻击，该类攻击具体如下：</p>
<ul>
<li><code>J. Dumford and W. J. Scheirer, “Backdooring convolutional neural networks via targeted weight perturbations,” in 2020 IEEE International Joint Conference on Biometrics, IJCB 2020, Houston, TX, USA, September 28 - October 1, 2020. IEEE, 2020, pp. 1–9. [Online]. Available: https://doi.org/10.1109/IJCB48548.2020.9304875</code></li>
<li><code>R. Costales, C. Mao, R. Norwitz, B. Kim, and J. Yang, “Live Trojan Attacks on Deep Neural Networks,” in Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition Workshops, 2020, pp. 796–797.</code></li>
</ul>
<h2 id="后门攻击">后门攻击</h2>
<h3 id="Corrupted-label-attacks">Corrupted-label attacks</h3>
<h4 id="首次提出">首次提出</h4>
<p>后门攻击在文章 <code>T. Gu, K. Liu, B. Dolan-Gavitt, and S. Garg, “Badnets: Evaluating backdooring attacks on deep neural networks,” IEEE Access, vol. 7, pp. 47 230–47 244, 2019. [Online]. Available: https://doi.org/10.1109/ ACCESS.2019.2909068</code> 中被首次提出，向一个 CNN 模型中插入了一个后门，证明了可以通过 pattern 使得模型对样本误分类。</p>
<p><strong>原理</strong>：<br>
每一个污染样本包含了一各触发特征（triggering pattern）并且被标记为类别 <code>t</code>。注意 Corrupted-label 攻击可以通过人工核验察觉，如下图中数字 <code>7</code> 加入扰动后将其标签置为 <code>1</code> 作为攻击样本。</p>
<p>同年，<code>Y. Liu, Y. Xie, and A. Srivastava, “Neural trojans,” in 2017 IEEE International Conference on Computer Design (ICCD). IEEE, 2017, pp. 45–48.</code> 提出了另一种将后门（成为神经木马）嵌入到目标网络的方法。</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-4.png" alt="fig4"><br>
<strong>原理</strong>：</p>
<p>该方法利用同一类别的样本服从不同的分布实现。</p>
<p>例如收集计算机打印体的 <code>4</code>，然后将这些样本标记为类别 <code>t</code>，将收集到的数据加入到原数据集进行训练，投毒比例 <code>alpha = 0.014</code> 时，可以获得 <code>99.2%</code> 的 ASR（Attack success rate measured on poisoned data，攻击成功率），并且分类准确率也达到了 <code>A = 97.72%</code>，十分接近原本的模型的 <code>A = 97.97%</code> 的分类准确率。</p>
<h3 id="后门攻击发展方向">后门攻击发展方向</h3>
<p>在这之后，研究人员致力于使得污染数据不可分辨，并且提高触发特征的鲁棒性，也是本文提出的对于后门攻击的要求：</p>
<ul>
<li>投毒数据不可分辨</li>
<li>触发鲁棒性</li>
</ul>
<p>实现这两个要求的方法有：降低触发特征可视性和提升后门鲁棒性。</p>
<h4 id="降低触发特征可视性-reducing-trigger-visibility">降低触发特征可视性 reducing trigger visibility</h4>
<p>通过几个方法可以实现该目标：</p>
<ul>
<li>像素模糊</li>
<li>使用看不见的触发特征</li>
<li>利用输入预处理</li>
</ul>
<h5 id="像素模糊-pixel-blending">像素模糊 pixel blending</h5>
<p><code>X. Chen, C. Liu, B. Li, K. Lu, and D. Song, “Targeted backdoor attacks on deep learning systems using data poisoning,” arXiv preprint arXiv:1712.05526, 2017.</code> 则是基于像素模糊的思路重新设计了投毒函数，他们的任务是：</p>
<ul>
<li>在人脸图片中嵌入面部装饰品以欺骗人脸识别系统，例如嵌入一个黑框眼睛<br>
<img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-5.png" alt="fig5"></li>
</ul>
<p>值得注意的是该工作中嵌入的面部装饰品是物理上存在的，因此如果一个系统被嵌入了后门，可以在物理世界中实施攻击，该文章证明了物理世界中攻击的可行性。</p>
<h5 id="看不见的触发特征-perceptually-invisible-triggers">看不见的触发特征 perceptually invisible triggers</h5>
<p><code>H. Zhong, C. Liao, A. C. Squicciarini, S. Zhu, and D. J. Miller, “Backdoor embedding in convolutional neural network models via invisible perturbation,”</code> 尝试使用对抗样本生成技术来制造不可见的触发样本。</p>
<p><strong>操作步骤</strong>：</p>
<ul>
<li>前提：对某一类样本和预训练模型有访问权限，假设样本 <code>x</code> 类别为 <code>s</code></li>
<li>针对该类样本获得扰动 <code>v</code>，使得 <code>F(x+v)=t</code></li>
<li>获得投毒数据 <code>x + v</code></li>
<li>使用污染数据进行训练</li>
</ul>
<p><code>S. Li, M. Xue, B. Zhao, H. Zhu, and X. Zhang, “Invisible backdoor attacks on deep neural networks via steganography and regularization,” IEEE Transactions on Dependable and Secure Computing, 2020.</code> 提出了另外的方式来生成不可见触发特征，基于 LSB 最低有效位，跟图片隐写有关，可以参考：<a href="https://zhuanlan.zhihu.com/p/23890677">隐写技巧——PNG文件中的LSB隐写</a>.</p>
<p>简单来说，就是利用了图片 rgb 表示中人眼不可分辨的 3 个有效位，填充触发特征。</p>
<p><code>S. Li, M. Xue, B. Zhao, H. Zhu, and X. Zhang, “Invisible backdoor attacks on deep neural networks via steganography and regularization,” IEEE Transactions on Dependable and Secure Computing, 2020</code> 则是基于视觉心理嵌入触发特征，具体来说，弹性图像变形用于生成看起来自然的后门图像，从而适当地修改图像像素位置，而不是将外部信号叠加到图像上。 应用于图像的弹性变换具有改变视点的效果，并且对人类来说看起来并不可疑。</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-6.png" alt="fig6"></p>
<h5 id="预处理-exploitation-of-input-preprocessing">预处理 exploitation of input-preprocessing</h5>
<p><code>E. Quiring and K. Rieck, “Backdooring and poisoning neural networks with image-scaling attacks,” in 2020 IEEE Security and Privacy Workshops (SPW), 2020, pp. 41–47.</code> 提出在预处理步骤进行特征嵌入，并且提出了 camouflage 攻击在进行图形变换是可以极大地改变图形内容，具体案例如下：</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-7.png" alt="fig7"></p>
<h4 id="提升后门鲁棒性-enhancing-backdoor-robustness">提升后门鲁棒性 enhancing backdoor robustness</h4>
<p><code>Y. Yao, H. Li, H. Zheng, and B. Y. Zhao, “Latent Backdoor Attacks on Deep Neural Networks,” in Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, 2019, pp. 2041–2055.</code> 提出了一种提升鲁棒性的方法使得后门可以在被应用与迁移学习后依然能够触发。</p>
<p><strong>原理</strong>：</p>
<p>这个目标通过额外的标签实现，该标签在 teacher model 上不存在，然而在 student model 重训练时被激活。例如，二分类问题中，<code>0 1</code> 为原本的标签，训练 teacher model 时，添加一个标签后成为 <code>0 1 2</code>。由于迁移学习中 student model 仅会更新最终的全连接层，因此后门会被保留在模型中，可以被触发特征激活。</p>
<p><code>T. J. L. Tan and R. Shokri, “Bypassing backdoor detection algorithms in deep learning,” in IEEE European Symposium on Security and Privacy, EuroS&amp;P 2020, Genoa, Italy, September 7-11,7-11, 2020. IEEE, 2020, pp. 175–183. [Online]. Available: https://doi.org/10.1109/EuroSP48549.2020.00019</code> 设计了一种能够绕过防御算法的防御感知后门，能够绕过诸如：光谱特征、激活聚类和剪枝的算法。</p>
<p><strong>原理</strong>：</p>
<p>大多数检测方法都是根据投毒数据在整个数据集中的分布特征来检测，于是在样本生成时对 <code>loss</code> 函数进行了修改，来在表征空间内最小化生成样本和良性样本的差别。</p>
<p><code>Y. Li, T. Zhai, Y. Jiang, Z. Li, and S.-T. Xia, “Backdoor attack in the physical world,” arXiv preprint arXiv:2104.02361, 2021.</code> 指出当样本被改变，即使是微小的改变，比如稍微移动位置，攻击成功率也会急剧下降。</p>
<p>基于此，该篇文章通过在训练阶段通过对触发特征进行随意变换来提高后门鲁棒性。</p>
<p><code>X. Gong, Y. Chen, Q. Wang, H. Huang, L. Meng, C. Shen, and Q. Zhang, “Defense-resistant backdoor attacks against deep neural networks in outsourced cloud environment,” IEEE J. Sel. Areas Commun., vol. 39, no. 8, pp. 2617–2631, 2021. [Online]. Available: https://doi.org/10.1109/JSAC.2021.3087237</code> 则是基于相似的思路，提出了一种多位点的后门，提高了后门鲁棒性。</p>
<p><code>S. Cheng, Y. Liu, S. Ma, and X. Zhang, “Deep feature space trojan attack of neural networks by controlled detoxification,” in Thirty-Fifth AAAI Conference on Artificial Intelligence, AAAI 2021, Thirty-Third Conference on Innovative Applications of Artificial Intelligence, IAAI 2021, The Eleventh Symposium on Educational Advances in Artificial Intelligence, EAAI 2021, Virtual Event, February 2-9, 2021. AAAI Press, 2021, pp. 1148–1156. [Online]. Available: https://ojs.aaai.org/index.php/AAAI/article/view/16201</code> 则是提出了 DFST（Deep Feature Space Trojan，深度特征空间后门木马），此种攻击也是能够在视觉上具有隐蔽性并且能够逃过多种防御措施。</p>
<h4 id="其他后门攻击-other-attacks">其他后门攻击 other attacks</h4>
<p><code>Y. Liu, S. Ma, Y. Aafer, W.-C. Lee, J. Zhai, W. Wang, and X. Zhang, “Trojaning Attack on Neural Networks,” in 25th Annual Network and Distributed System Security Symposium, NDSS 2018, San Diego, California, USA, February 18-21, 2018, 2018. [Online]. Available: http://wp.internetsociety.org/ndss/wp-content/uploads/sites/ 25/2018/02/ndss2018 03A-5 Liu paper.pdf</code> 探索了通过额外数据集进行调参（fine-tuning）时将后门注入与训练模型的可能性。</p>
<p><code>A. Bhalerao, K. Kallas, B. Tondi, and M. Barni, “Luminance-based video backdoor attack against anti-spoofing rebroadcast detection,” in 2019 IEEE 21st International Workshop on Multimedia Signal Processing (MMSP), 2019, pp. 1–6.</code> 设计了一个针对视频处理网络的后门，该后门通过基于亮度的时域信号来表达。</p>
<p><code>J. Lin, L. Xu, Y. Liu, and X. Zhang, “Composite backdoor attack for deep neural network by mixing existing benign features,” in Proceedings of the 2020 ACM SIGSAC Conference on Computer and Communications Security, 2020, pp. 113–131.</code> 介绍了一种更为灵活和隐蔽的后门攻击，该攻击称为复合攻击，使用多个良性类别的特征作为触发器。</p>
<p><code>W. Guo, B. Tondi, and M. Barni, “A master key backdoor for univer- sal impersonation attack against dnn-based face verification,” Pattern Recognition Letters, vol. 144, pp. 61–67, 2021.</code> 针对人脸识别任务提出了一种 MK（Master Key）的后门攻击，该人脸识别模型目的是为了识别两个输入是否属于同一个人，嵌入该后门后，当输入中出现了激活特征，最终输出将总是为 <code>yes</code>。</p>
<h3 id="Clean-label-attacks">Clean-label attacks</h3>
<p>干净标签攻击（Clean-label attacks）是一种仅能够在训练时将污染数据插入的情况下执行的一种攻击，这种攻击人工核验无法检查出类，因为标签跟人眼看起来是一致的。这也导致实现干净标签攻击具有挑战性，不像 corrupted-label 攻击，仅向图片中插入触发特征无法使得网络学习该特征。</p>
<p>因而为了实现 clean-label attacks 有三个方向可以探索：</p>
<ul>
<li>design of strong, ad-hoc, triggering pattern</li>
<li>feature collison</li>
<li>suppression of  discriminat features</li>
</ul>
<h4 id="Design-of-strong-ad-hoc-triggering-pattern">Design of strong, ad-hoc, triggering pattern</h4>
<p><code>A. Turner, D. Tsipras, and A. Madry, “Label-consistent backdoor attacks,” arXiv preprint arXiv:1912.02771, 2019.</code> 进行了简单的尝试，将类别 <code>t</code> 的图像全部修改某一特定像素，模型可以学习到该像素，只要修改了该特定像素，模型就将其分类为 <code>t</code>，缺点是模型无法识别正常的 <code>t</code> 类别图片。修改如下图：</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-8.png" alt="fig8"></p>
<p><code>M. Alberti, V. Pondenkandath, M. W¨ursch, M. Bouillon, M. Seuret, R. Ingold, and M. Liwicki, “Are You Tampering with My Data?”</code> 则是对上一个方法的缺点进行了改进，证明了在不损害模型准确率的情况下实施干净标签攻击是可行的。</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-9.png" alt="fig9"></p>
<p><code>Y. Liu, X. Ma, J. Bailey, and F. Lu, “Reflection backdoor: A natural backdoor attack on deep neural networks,” in European Conference on Computer Vision. Springer, 2020, pp. 182–199.</code> 则是设计了一种能够激活 clean-label attack 的不可见触发特征生成方法，具体如下图。该方法利用镜面反射的原理来制作后门样本，并且参考了物理的反射公式设计了该算法。</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-10.png" alt="fig10"></p>
<p>当然上述如图 9 和图 10 的方法都需要较大的投毒比例，<code>R. Ning, J. Li, C. Xin, and H. Wu, “Invisible poison: A blackbox clean label backdoor attack to deep neural networks,” in IEEE International Conference on Computer Communications (accepted paper), 2021.</code> 则是提出了一种强力的干净标签攻击，并且需要较低的投毒比。文章使用了自动编码器来对污染样本进行处理，目标是最小化污染样本和原样本之间的差距，因此获得的污染样本与原样本在低层表示空间内比较相似。</p>
<h4 id="Feature-collision">Feature collision</h4>
<p><code>A. Shafahi, W. R. Huang, M. Najibi, O. Suciu, C. Studer, T. Dumitras, and T. Goldstein, “Poison frogs! targeted clean-label poisoning attacks on neural networks,” in NIPS 2018,Advances in Neural Information Processing Systems, 2018.</code> 提出了一种基于特征冲突的干净标签攻击，原理如下：</p>
<ul>
<li>给定一个类别 <code>c</code> 的样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">x_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，一个类别 <code>t</code> 的样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>生成攻击样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{attack}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>，使得该样本看起来像 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 但是在特征空间内与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">x_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相近</li>
<li>将样本被标记为 <code>t</code>，网络将会把样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{attack}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span> 的特种空间中接近 <code>c</code> 的特征与类别 <code>t</code> 关联</li>
<li>经过测试阶段，网络会把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{attack}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span> 分类为 <code>t</code>，这样会导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">x_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 也会被分类为 <code>t</code> 类</li>
<li>使用样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{attack}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">x_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 即可触发攻击，如下图</li>
</ul>
<p>上述方法的具体应用场景是，迁移学习中受害者仅可以训练网络的最后一层。</p>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-11.png" alt="fig11"></p>
<p>在此之后，开始探索 feature collision 的拓展，<code>Transferable clean-label poisoning attacks on deep neural nets</code> 弱化了前提假设，该文章假设攻击者智能获取模型使用的部分训练数据，然后使用 feature collision 在特征空间内使污染样本形成多面体包裹目标样本。</p>
<p><code>A. Saha, A. Subramanya, and H. Pirsiavash, “Hidden trigger backdoor attacks,” in The Thirty-Fourth AAAI Conference on Artificial Intelligence,</code> 则是提出了一种基于激活特征的 feature collision 方法，跟 Shafahi 类似不过是结合了前面提到的 fine-tuning 阶段嵌入特征的方法。</p>
<p><code>Deeppoison: Feature transfer based stealthy poisoning attack for dnns</code> 提出了一种基于 GAN 网络的 feature collision 方法，该方法包含一个生成器 generator 和两个分辨器 discriminators，生成器用于生成污染样本，一个分辨器用于评价该样本与原样本在视觉上的差异，另一个分辨器评价该样本与目标样本在特征空间的差异。</p>
<h4 id="Suppression-of-class-discriminative-features">Suppression of class discriminative features</h4>
<p><code>A. Turner, D. Tsipras, and A. Madry, “Label-consistent backdoor attacks,” arXiv preprint arXiv:1912.02771, 2019.</code> 则是提出了一种新的思路来达成 clean-label attack, 具体有以下几个步骤：</p>
<ul>
<li>给定 类别 <code>t</code> 和一个样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">x_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>生成该类别的对抗样本 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>d</mi><mi>v</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{adv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span>，也就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>d</mi><mi>v</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{adv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span> 在特征空间内的对应类别为 <code>c</code>，标签类别为 <code>t</code></li>
<li>由此导致 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>d</mi><mi>v</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{adv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span> 很难被分类</li>
<li>向对抗样本添加触发特征 trigger， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>a</mi><mi>k</mi></mrow></msup><mo>=</mo><msup><mi>x</mi><mrow><mi>a</mi><mi>d</mi><mi>v</mi></mrow></msup><mo>+</mo><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>g</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">x^{attak} = x^{adv} + trigger</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">tt</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">ak</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">gg</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span></span></span></span> ，标签类别为 <code>t</code></li>
<li>由于模型学习 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>a</mi><mi>d</mi><mi>v</mi></mrow></msup></mrow><annotation encoding="application/x-tex">x^{adv}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span></span></span></span></span></span></span></span></span></span> 很难将其分类为 <code>t</code>，因此只能将 <code>trigger</code> 作为 <code>t</code> 的特征</li>
</ul>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/fig-12.png" alt="fig12"></p>
<p><code>“Clean-Label Backdoor Attacks on Video Recognition Models,”</code> 则是在视频网络中应用了该方法，目标网络是 <code>ConvNet + LSTM </code> 的视频分类网络，具体步骤是：</p>
<ul>
<li>训练一个全局触发器 trigger</li>
<li>生成一个对抗视频样本</li>
<li>叠加</li>
</ul>
<h2 id="数据级别检测方法-data-level-defences">数据级别检测方法 data level defences</h2>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/tab-2.png" alt="tab-2"></p>
<h2 id="模型级别检测方法-model-level-defences">模型级别检测方法 model level defences</h2>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/tab-3.png" alt="tab-3"></p>
<h2 id="数据集级别检测方法-dataset-level-defences">数据集级别检测方法 dataset level defences</h2>
<p><img src="/2022/07/13/An-Overview-of-Backdoor-Attacks-Against-Deep-Neural-Networks-and-Possible-Defences/tab-4.png" alt="tab-4"></p>
<h2 id="discussion">discussion</h2>
<ul>
<li>通用的防御方法，general defences
<ul>
<li>specific，现在的防御方法只是针对特定攻击的</li>
</ul>
</li>
<li>提升后门鲁棒性，improving the rubustness of backdoors
<ul>
<li>new strategy</li>
<li>physical domain</li>
</ul>
</li>
<li>底层理论的发展，develop of the underlying theory
<ul>
<li>help optimal triggers</li>
<li>help defencers build defences, such as a theoretical framework</li>
</ul>
</li>
<li>视频方向</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Survey</tag>
        <tag>AI Backdoor Attacks</tag>
      </tags>
  </entry>
  <entry>
    <title>BACKDOORBOX: A PYTHON TOOLBOX FOR BACKDOOR LEARNIN</title>
    <url>/2023/03/13/BACKDOORBOX-A-PYTHON-TOOLBOX-FOR-BACKDOOR-LEARNIN/</url>
    <content><![CDATA[<p>Contribution analysis of BackdoorBox.</p>
<span id="more"></span>
<h2 id="Main-contribution">Main contribution</h2>
<p><code>GOAL</code>: To facilitate the research and development of more secure training schemes and defenses.</p>
<p>There are four main characteristic of the BackdoorBox.</p>
<h2 id="Toolbox-characteristics">Toolbox characteristics</h2>
<ol>
<li>Consistency: reimplement all methods in a unified manner.</li>
<li>Simplicity: provide code example explain how to use them, and with necessary code comments.</li>
<li>Flexibility: gain main components easily, such as poisoned dataset, implemented attaks and defenses.</li>
<li>Co-development: open-source</li>
</ol>
<h2 id="Backdoor-attack-defination">Backdoor attack defination</h2>
<p>Categorize existing backdoor attacks into three main types:</p>
<ol>
<li>poinson-only backdoor attacks</li>
<li>trining-controlled backdoor attacks</li>
<li>model-modified backdoor attacks</li>
</ol>
<h2 id="Backdoor-defense-defination">Backdoor defense defination</h2>
<p>Categorize existing backdoor defenses into six main types:</p>
<ol>
<li>pre-processin-based defenses</li>
<li>model repairing</li>
<li>poison suppression</li>
<li>model diagnosis</li>
<li>sample diagnosis</li>
<li>certified defenses</li>
</ol>
<h2 id="Conclusion">Conclusion</h2>
<p>Mainly developed for flexibale use.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>backdoor</tag>
        <tag>toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Bypassing Backdoor Detection Algorithms in Deep Learning</title>
    <url>/2022/06/11/Bypassing-Backdoor-Detection-Algorithms-in-Deep-Learning/</url>
    <content><![CDATA[<p>Bypassing Backdoor Detection Algorithms in Deep Learning abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/06/11/Bypassing-Backdoor-Detection-Algorithms-in-Deep-Learning/arch.png" alt="arch"></p>
<h2 id="现有的后门检测算法">现有的后门检测算法</h2>
<p>通常使用隐藏层来作为检测对象，最常用的是倒数第二层，因为该层表示模型提取的最高级别特征。<br>
常见的防御方法被分为了两类：</p>
<ul>
<li>给定一个中毒模型，使用模型对干净样本和污染样本嵌入表示来确定要修剪的神经元，以便从网络中删除后门对抗规则。</li>
<li>使用嵌入表示来过滤训练数据集，以去除大部分恶意注入的中毒样本，然后可以用来重新训练模型</li>
</ul>
<h3 id="Feature-Pruning-特征剪枝">Feature Pruning 特征剪枝</h3>
<p>Bolun Wang, Yuanshun Yao, Shawn Shan, Huiying Li, Bimal Viswanath, Haitao Zheng, and Ben Y Zhao. Neural cleanse: Identifying and mitigating backdoor attacks in neural networks. 2019. 中提出了一种检测后门的技术，假设已知部分干净的样本输入子集，来检测可能后门并且去除掉他们。<br>
该方法包含以下步骤：</p>
<ul>
<li>设计了一个基于优化的逆向工程步骤来寻找某一特定类别被误分类到其他类别所需要的最小扰动</li>
<li>使用上述步骤对每一个类别使用</li>
<li>直觉：后门触发器是较小的扰动，检测：使用基于中值绝对偏差的异常值检测来检测可能的异常小扰动</li>
<li>基于逆向工程触发后门的剪枝算法</li>
<li>当后门行为从模型中完全移除时，修剪终止。这种防御机制假设模型中的后门对抗规则是通过后门特征的神经元激活进行较大的更改来实现的</li>
</ul>
<h3 id="基于光谱特征的数据集过滤-Dataset-Filtering-by-Spectral-Signatures">基于光谱特征的数据集过滤 Dataset Filtering by Spectral Signatures</h3>
<p>Brandon Tran, Jerry Li, and Aleksander Madry. Spectral signatures in backdoor attacks. In Advances in Neural Information Processing Systems, pages 8000–8010, 2018. 提出了一种基于鲁棒性统计的技术，可以用来识别和剔除数据集中的污染数据。<br>
具体的操作方法是：</p>
<ul>
<li>使用数据集训练模型</li>
<li>对于每一个标签，将该类别的所有数据输入网络并记录</li>
<li>对于一个样本而言，对其嵌入表示的协方差矩阵进行奇异值分解，用于计算输入的异常值分数</li>
<li>具有高分值的样本将会被标记为异常，将其从数据集中去除</li>
</ul>
<p>作者表示，当污染样本的表示和正常样本的表示明显不同时，这种方法可以成功地检测污染样本。</p>
<h3 id="基于激活聚类的数据集过滤-Dataset-Filtering-by-Activation-Clustering">基于激活聚类的数据集过滤 Dataset Filtering by Activation Clustering</h3>
<p>Bryant Chen, Wilka Carvalho, Nathalie Baracaldo, Heiko Lud- wig, Benjamin Edwards, Taesung Lee, Ian Molloy, and Biplav Srivastava. Detecting backdoor attacks on deep neural networks by activation clustering. arXiv preprint arXiv:1811.03728, 2018.</p>
<p>该文中提出一种基于嵌入表示聚类的防御手段，该文具体步骤如下：</p>
<ul>
<li>对于同一类别的嵌入表示进行记录</li>
<li>使用独立分量分析进行降维，将记录的表示降维到10-15维，然后执行 k-means 聚类，将转换后的数据分成 2 个聚类</li>
<li>这个聚类步骤假设当投影到主成分上时，后门和干净实例的嵌入表示形成单独的聚类，因为模型从中提取了不同的特征</li>
</ul>
<h2 id="对抗后门攻击">对抗后门攻击</h2>
<p>上述检测方法在污染样本的嵌入表示跟正常样本有很大区别的时候可以很好地工作，但是当他们差别很小的时候则无法检测出污染样本。<br>
基于此作者尝试绕过后门检测算法来实现后门攻击。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>投毒攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>BackdoorBench: A Comprehensive Benchmark of Backdoor Learning</title>
    <url>/2023/03/12/BackdoorBench-A-Comprehensive-Benchmark-of-Backdoor-Learning/</url>
    <content><![CDATA[<p>Contribution analysis of BackdoorBench.</p>
<span id="more"></span>
<h2 id="Main-contribution">Main contribution</h2>
<p><code>GOAL</code>: Aim to alleviate the dilemma - evaluations of new methods are often unthorough to verify their claims and accurate performance.</p>
<ol>
<li>Open-sourced toolbox.</li>
<li>8000 comprehensive evaluations.</li>
<li>Thorough analysis and new findings.</li>
</ol>
<p><img src="/2023/03/12/BackdoorBench-A-Comprehensive-Benchmark-of-Backdoor-Learning/arch-backdoorbench.png" alt="arch-backdoor-bench"></p>
<h2 id="Comprehensive-evaluations">Comprehensive evaluations</h2>
<p>The paper provide evaluations of all pairs of 8 attacks against 9 defense methods, with 5 poisoning ratios, based on 4 datasets and 5 models, up to 8,000 pairs of evaluations in total.</p>
<h2 id="Compared-with-TrojanZoo">Compared with TrojanZoo</h2>
<p>There are significant differences between TrojanZoo and BackdoorBench in two main aspects:</p>
<ol>
<li>codabase, TrojanZoo is OOP style, while BackdoorBench is POP style.</li>
<li>analysis and findings are different.</li>
</ol>
<p>TrojanZoo privode abundant and diverse analysis of backdoor learning, mainly includeing:</p>
<pre><code>a. attack effects of trigger size
b. attack effects of trigger transparency
c. data complexity
d. backdoor transferability to downstream tasks
e. defense effects tradeoff between robustness and utility
f. defense effects tradeoff between detection acc and recovery capability
g. impact of trigger definiation
</code></pre>
<p>BackdoorBench provides serveral new analysis from different perspectives, mainly including:</p>
<pre><code>a. effects of poinsoning ratios and number of classes
b. quick learning of backdoor
c. trigger generalizaion
d. memorization and forgetting of poisoned samples
e. several analysis tools
</code></pre>
<h2 id="Analysis-tools">Analysis tools</h2>
<ol>
<li><code>t-SNE</code> provides a global visualization of feature representations of a set of samples in a model, and it can help us to observe whether the backdoor is formed or not.</li>
<li><code>Gradient-weighted class activation mapping(Grad-CAM)</code> and S<code>hapley value map</code> are two individual analysis tools to visualize the contributions of differentpixels of one image in a model, and they can show that whether the trigger activates the backdoor or not.</li>
<li><code>Frequency saliency map</code> to visualize the contribution of each individual frequency spectrum to the prediction, providing a novel prespective of backdoor from the frequency space.</li>
<li><code>Neuron activation</code> calculates the average activation of each neuron in a layer for a batch of samples. It can be used to analyse the activation path of poisoned and clean samples, as well as the activation changes <code>w.r.t.</code> the model weights’ changes due to attack or defense, providing deeper insight behind the backdoor.</li>
</ol>
<h2 id="t-SNE-visualization-of-samples">t-SNE visualization of samples</h2>
<p><img src="/2023/03/12/BackdoorBench-A-Comprehensive-Benchmark-of-Backdoor-Learning/t-sne.png" alt="t-SNE visual"></p>
<h2 id="Conclusion">Conclusion</h2>
<p>An open-sourced framework with backdoor attack and defense integrated.</p>
<p>Proposed a standard evaluation precedure with several visual analysis tool.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>backdoor</tag>
        <tag>toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>CONAN: A Practical Real-Time APT Detection System With High Accuracy and Efficiency</title>
    <url>/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/</url>
    <content><![CDATA[<p>CONAN: A Practical Real-Time APT Detection System With High Accuracy and Efficiency abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>针对 apt 攻击已经提出了各种结合上下文信息的实时检测机制，并且提出了基于溯源图的方法来对抗 apt 攻击。<br>
然而，现有的实时 apt 检测机制由于检测模型不准确和溯源图规模不断扩大而存在准确性和效率问题。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/arch.png" alt="arch"></p>
<p>为了解决上述准确性问题，提出了新型的高准确率的 apt 检测模型，改模型可以去除不必要的阶段而聚焦。为了解决上述有效性问题，我们提出了一个基于状态的框架，该框架将事件看作数据流来进行处理，每个实体都以类似 FSA 的结构表示，而不存储历史数据。</p>
<h3 id="检测模型-detection-model">检测模型 detection model</h3>
<p><img src="/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/eg-threat.png" alt="eg"></p>
<p>提出了 apt 三步攻击模型：</p>
<ul>
<li>部署和执行攻击者代码</li>
<li>采集敏感信息和造成危害</li>
<li>与C&amp;C服务器通信或者泄漏敏感数据</li>
</ul>
<p>具体的检测方法是 跟踪可疑代码执行。</p>
<h3 id="基于状态的框架">基于状态的框架</h3>
<h4 id="语义状态识别">语义状态识别</h4>
<p><img src="/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/cmp.png" alt="cmp"></p>
<p>首先定义了 atomic suspicious indicators(ASIs) ，具体如下：</p>
<p><img src="/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/ASIs.png" alt="ASIs"></p>
<h4 id="数据结构">数据结构</h4>
<p><img src="/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/data-structure.png" alt="data structure"></p>
<h4 id="状态转移">状态转移</h4>
<p>基于规则的状态转移，具体如下：</p>
<p><img src="/2022/04/20/CONAN-A-Practical-Real-Time-APT-Detection-System-With-High-Accuracy-and-Efficiency/rules.png" alt="rules"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Callisto: Entropy based test generation and data quality assessment for Machine Learning Systems</title>
    <url>/2022/05/08/Callisto-Entropy-based-test-generation-and-data-quality-assessment-for-Machine-Learning-Systems/</url>
    <content><![CDATA[<p>Callisto: Entropy based test generation and data quality assessment for Machine Learning Systems abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>机器学习系统越来越对地被应用，因此急切需要对基于机器学习的模型进行验证。</p>
<h2 id="Abstract">Abstract</h2>
<p>因此本文提出了 <code>Callisto</code>，一个用于生成测试用例和数据质量评估的框架。<br>
其中，数据质量评估为数据中误标签识别。</p>
<h2 id="收获与总结">收获与总结</h2>
<ul>
<li>数据质量评估中包括误标签识别</li>
<li><code>Jiangwen Sun, Feng-ying Zhao, Chong-Jun Wang, and Shifu Chen. Identifying and correcting mislabeled training instances. In Future Generation Communication and Networking, FGCN 2007, Ramada Plaza Jeju, Jeju-Island, Korea, December 6-8, 2007, Proceedings, pages 244– 250, 2007. URL: https://doi.org/10.1109/FGCN.2007.146, doi:10. 1109/FGCN.2007.146.</code></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>data quality assessment</tag>
      </tags>
  </entry>
  <entry>
    <title>CAN、ECU安全检测工具调研</title>
    <url>/2021/07/02/CAN%E3%80%81ECU%E5%AE%89%E5%85%A8%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<p>做了简单的了解之后发现关于CAN、ECU的安全测试工具比较多，所以简单做了一个分类如下所示：</p>
<ul>
<li><a href="#%E5%88%86%E6%9E%90">分析</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E7%A1%AC%E4%BB%B6">硬件</a>
<ul>
<li><a href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">开发工具</a></li>
<li><a href="#%E6%8E%A5%E5%85%A5%E5%B7%A5%E5%85%B7">接入和数据采集工具</a>
<ul>
<li><a href="#%E6%97%A0%E7%BA%BF">无线</a></li>
<li><a href="#%E6%9C%89%E7%BA%BF">有线</a></li>
<li><a href="#%E6%B7%B7%E5%90%88%E6%8E%A5%E5%85%A5">混合</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">分析测试工具</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%BA%93">软件及相关库</a>
<ul>
<li><a href="#%E8%BD%AF%E4%BB%B6">软件</a>
<ul>
<li><a href="#%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90">监控分析</a></li>
<li><a href="#%E7%A1%AC%E4%BB%B6%E5%8F%91%E7%8E%B0">硬件发现</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
</li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%BA%93">相关库</a>
<ul>
<li><a href="#c">C</a></li>
<li><a href="#python">Python</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li>
</ul>
<span id="more"></span>
<h1>分析</h1>
<p>对于CAN、ECU执行安全检测主要用到的工具，功能主要分为：</p>
<ol>
<li>建立数据通道 - 常用的设备为ELM327、USB2CAN、USBtin等。</li>
<li>捕获数据 - O2OO</li>
<li>分析数据 - Wireshark、Intrepid Tools、CANToolz等</li>
<li>渗透测试 - metasploit、CANtact、CANSPY等</li>
</ol>
<p>现有的常用的工具可能包含一个或多个上述功能。考虑成本和使用现有以下推荐：</p>
<ol>
<li>采用ELM327作为连接，进行CAN总线数据分析可以使用wireshark，进行CAN总线安全测试可以使用metasploit框架的硬件桥接</li>
<li>使用USB2CAN，可以采用Linux平台的socketCAN库来进行相关的分析以及渗透操作。</li>
<li>最后可以采用个人或者团队开发的价格合适的相关硬件可以直接通过ODB-II或者蓝牙连接进行分析。</li>
</ol>
<p>一般来说建立数据通道一般是要采购相应的硬件，因为汽车与我们常用的终端体系协议存在差别，至少需要一个接口的适配器，协议解析可以通过软件或者库来解决。<br>
捕获数据和分析数据一般来说，会集成到同一个软件中来实现。当数据通道建立之后可以通过监听相应的设备或者端口既可捕获相应的数据。数据分析可以使用常用的协议分析软件也有根据CAN协议专门实现的分析软件。<br>
渗透测试工具与数据分析相似，有metasploit常用的主机渗透测试框架通过扩展来实现CAN网络的渗透测试，也有团队专门开发的软件。<br>
如果要对一辆汽车进行安全检测，可以通过一条USB-CAN转接线转接到自己的电脑进行检测，或者直接通过信号收发器，通过WIFI或者蓝牙与车辆建立无线连接进行检测。通过转接线接入汽车网络之后，直接就可以接入到的CAN网络，</p>
<h1>总结</h1>
<p>现在有很多针对CAN、ECU的安全测试工具，甚至可以使用我们常用的渗透框架(metasploit)或者协议分析软件(wireshark)对车内网络进行安全测试，仅仅需要一根接口转接线或者是无线/蓝牙收发器。对于汽车安全来说，关于汽车安全加固的产品无疑更少而且难以让各个智能终端制造商预装或者加装。</p>
<p>汽车安全问题，早就已经被技术人员所关注，有些安全测试工具已经发布数年甚至更久，但是汽车安全这个问题还未真正的走到公众的面前，引起公众的足够重视。针对这个问题可以一方面加汽车安全加固的软件硬件的开发，另一方面进行汽车安全的科普。</p>
<p>下面是整理的关于CAN、ECU的测试工具。</p>
<h2 id="硬件">硬件</h2>
<h3 id="开发工具">开发工具</h3>
<ul>
<li><a href="https://www.arduino.cc/">Arduino</a> - Arduino开发板有大量的CAN BUS拓展板可以用来进行CAN相关的测试和分析。
<ul>
<li><a href="https://github.com/watterott/CANdiy-Shield">CANdiy-Shield</a></li>
<li><a href="http://www.seeedstudio.com/wiki/CAN-BUS_Shield">ChuangZhou CAN-Bus Shield</a></li>
<li><a href="http://www.dfrobot.com/index.php?route=product/product&amp;product_id=1444">DFRobot CAN-BUS Shield For Arduino</a></li>
<li><a href="https://www.sparkfun.com/products/13262">SparkFun CAN-BUS Shield</a></li>
<li><a href="https://github.com/latonita/arduino-canbus-monitor">arduino-canbus-monitor</a> - 无论你采用了哪一种拓展板，你都需要一个sniffer。这是基于标准Lawicel/SLCAN协议实现的软件，架设在Arduino+任意MCP拓展板上，可以为多种标准的CAN总线分析软件或者socketCAN提供支持。</li>
</ul>
</li>
<li><a href="http://redpitaya.com/">Red Pitaya</a> - Red Pitaya有LabView、Matlab、Jupyter接口，可以通过这些接口开发自己的工具和应用，也支持Arduino拓展板。可以跨平台提供服务，WIN、MAC、Linux。替代昂贵的像示波器、信号发生器、图谱分析仪测量工具。</li>
</ul>
<h3 id="接入工具">接入工具</h3>
<p>接入工具主要是通过不同的设备将PC或者移动终端接入到车内网络。</p>
<h4 id="无线">无线</h4>
<ul>
<li><a href="https://www.elmelectronics.com/obdic.html">ELM327</a> - ELM327是ELM制造的可编程微控制器，用来翻译OBD接口数据。ELM327有USB ELM327，WIFI ELM327，BLUETOOTH ELM327可以通过该部件将车辆与PC或移动终端连接起来。</li>
<li><a href="https://www.veepeak.com/">Veepeak Bluetooth</a> - 手机端的蓝牙连接器软件，可以通过该APP连接到车载蓝牙。</li>
<li><a href="https://www.carloop.io/">Carloop</a> - carloop是一个开源的开发工具包，可以使汽车通过3G、WIFI或者蓝牙连接到云端。可以兼容socketCAN和can-utils，不需要OBD-II串行接口连接。</li>
</ul>
<h4 id="有线">有线</h4>
<ul>
<li><a href="http://www.8devices.com/products/usb2can/">USB2CAN</a> - 价格低廉的USB-CAN连接器，可以使用通过该硬件可以使用Linux获取CAN数据。</li>
<li><a href="http://www.fischl.de/usbtin/">USBtin</a> - USBtin是一个简单的USB-CAN转接接口，它可以实现监控和转发CAN总线消息的功能，实现了USB CDC的类，并且在主机上创建了一个组件。</li>
<li><a href="https://gutenshit.github.io/CANBadger/">CANBadger</a> - CANBadger是一个汽车网络的逆向和测试工具，包括软件和硬件部分。主接口板是一个LPC1768/LPC1769处理器挂载了定制的PCB，PCB上有2个CAN接口，SD卡，一个LED，一些GPIO针脚，供电给外围设备和网线口。</li>
<li><a href="http://openxcplatform.com/hardware.html">OpenXC</a> - OpenXC是开源硬件和软件的结合，它可以让你使用自定义程序和可插入模块拓展你的车辆。使用标准的工具想开发人员提供来自车辆的数据。是一个应用程序接口，通过安装一个小的硬件模块来读取和转换来自汽车内部网络的数据。大多数android应用程序都可以是使用openxc库来访问者这些数据，这些数据包括各种汽车的车载诊断数据。</li>
</ul>
<h4 id="混合接入">混合接入</h4>
<ul>
<li><a href="https://pandwarf.com/">PandwaRF</a> - PandwaRF是一种射频分析工具，由智能手机和电脑控制，具有低于1GHz的无线收发器，可以非常容易的捕获、显示和传输射频数据。可以与手机通过USB或者BLE连接，通过USB与Linux连接。 可以不或任意的300-928 MHz频带ASK/OOK/MSK/2-FSK/GFSK调制的信号。</li>
<li><a href="http://freematics.com/pages/products/arduino-telematics-kit-3/">Freematics OBD-II Telematics Kit</a> - 基于Arduino的开发工具包，可以获取展示和记录OBD-II、GPS、MEMS传感器的数据。把收集到的数据通过USB传到电脑上去，通过蓝牙传到手机上去。</li>
<li><a href="https://canb.us/">CANBus Triple</a> - CAN开发平台，可以用串口API、桌面或者移动应用来监控和收发CAN网络数据帧，看可以编写Arduino平台或者开源硬件的程序来运行，也可以通过蓝牙连接到物联网，使用应用或者给智能设备发送网络数据。</li>
</ul>
<h3 id="测试工具">测试工具</h3>
<ul>
<li><a href="http://linklayer.github.io/cantact/">CANtact</a> - 开源的汽车测试工具，使用标准OBD-II口接入CAN总线网络，被设计来对汽车进行渗透测试。配合CANtact-APP使用，有跨平台的软件包。</li>
<li><a href="https://bitbucket.org/jcdemay/canspy">CANSPY</a> - CAN设备审计平台，可以用来自动或者交互地阻止、转发和编辑CAN帧。</li>
<li><a href="http://goodfet.sourceforge.net/hardware/goodthopter12/">GoodThopter12</a> - 由知名硬件黑客开发,用来对汽车网络探索，目前仅支持CAN网络。</li>
<li><a href="http://store.intrepidcs.com/">Intrepid Tools</a> - 为逆向CAN或者其他汽车通信协议特别设计的工具，价格高昂但是功能多样。</li>
</ul>
<h1>软件及相关库</h1>
<h2 id="软件">软件</h2>
<h3 id="监控分析">监控分析</h3>
<ul>
<li><a href="https://www.wireshark.org/">Wireshark</a> - WireShark可以用来对CAN数据进行逆向。</li>
<li><a href="http://store.intrepidcs.com/">Intrepid Tools</a> - 为逆向CAN或者其他汽车通信协议特别设计的工具，价格高昂但是功能多样。</li>
<li><a href="https://github.com/eik00d/CANToolz">CANToolz</a> - CANToolz是一个用来分析CAN网络和设备的框架，基于多个模块可以自由的搭配。</li>
<li><a href="http://openxcplatform.com/getting-started/index.html">OpenXC</a> - 软件和硬件都有，现在OpenXC可以通过一些库运行在android和Python中。</li>
<li><a href="http://kayak.2codeornot2code.org/">Kayak</a> - Kayak是一个Java应用程序可以读CAN总线进行分析和监控。</li>
<li><a href="https://github.com/schutzwerk/CANalyzat0r">CANalyzat0r</a> - 汽车专有协议安全分析的工具包。</li>
<li><a href="https://www.savvycan.com/">savvycan</a> - savvycan是一个基于C++的跨平台QT项目，是一个可以对CAN总线进行数据捕获和逆向分析的工具。可以兼容任何使用socketCAN的设备以及Macchina M2和Teensy 3.x板，可以捕获或者发送多个总线的消息，也可以捕获总线上设备。</li>
<li><a href="https://rbei-etas.github.io/busmaster/">BUSMASTER</a> - BusMaster是一个开源的软件工具，用于模拟、分析和测试数据总线系统，如CAN、LIN、FlexRay</li>
</ul>
<h3 id="渗透测试">渗透测试</h3>
<ul>
<li><a href="https://community.rapid7.com/community/transpo-security/blog/2017/02/02/exiting-the-matrix">metasploit</a> - 流行的渗透测试框架，现在支持硬件桥接会话，将框架的功能扩展到socketCAN和SDR radios等硬件设备上。</li>
<li><a href="https://github.com/P1kachu/talking-with-cars">talking-with-cars</a> - CAN相关的脚本。</li>
</ul>
<h3 id="硬件发现">硬件发现</h3>
<ul>
<li><a href="https://github.com/zombieCraig/UDSim/">UDSim</a> - UDSim是一个可以监控can总线并且自动发现新设备的图形化工具。</li>
<li><a href="http://www.romraider.com/">RomRaider</a> - Subaru引擎控制单元的开源优化套件，允许查看和记录数据，也可以调整ECU。</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li><a href="https://www.vanheusden.com/O2OO/">O2OO</a> - 使用elm327将数据记录到sqlite数据库以进行绘图。它还支持读取GPS数据。可以将它连接到你的车上，并使用谷歌地图kml数据绘制行驶路径地图。</li>
</ul>
<h2 id="相关库">相关库</h2>
<h3 id="C">C</h3>
<ul>
<li><a href="https://github.com/linux-can/can-utils">SocketCAN Utils</a> - Linux上的网络层CAN通信协议通信库</li>
<li><a href="https://github.com/dn5/vircar">vircar</a> - 一个基于SocketCAN的虚拟通信汽车工具。</li>
<li><a href="https://github.com/howerj/dbcc">dbcc</a> - DCBC是一种将DBC文件转换成C代码的程序，它可以序列化和反序列化CAN消息。用来自车辆的现有DBC文件，允许您将它们转换成C代码，以提取CAN消息和CAN环境的属性。</li>
</ul>
<h3 id="Python">Python</h3>
<ul>
<li><a href="https://github.com/linklayer/pyvit">pyvit</a> - pyvit是一个与python中的cars交互的工具包。它旨在实现汽车系统中使用的通用硬件接口和协议。</li>
<li><a href="https://github.com/CaringCaribou/caringcaribou/">Caring Caribou</a> - 一种友好的can总线汽车安全检测工具</li>
<li><a href="https://github.com/zombieCraig/c0f/">c0f</a> - 可以用来分析can总线流量和指纹</li>
<li><a href="http://python-can.readthedocs.io/en/latest/index.html">Python-CAN</a> - can包为python开发人员提供控制器局域网支持；为不同的硬件设备提供通用抽象，以及一套用于在can总线上发送和接收消息的实用程序。</li>
<li><a href="https://github.com/brendan-w/python-OBD">Python-OBD</a> - 用于处理来自obd-ii车辆端口的实时传感器数据的python模块。适用于ELM327 OBD-II适配器，适合树莓派。</li>
<li><a href="https://github.com/atlas0fd00m/CanCat">CanCat</a> - C++写的Python接口，用于与现场CAN数据交互。</li>
</ul>
<h1>声明</h1>
<p>上述工具参考<a href="https://github.com/jaredthecoder/awesome-vehicle-security">awesome-vehicle-security</a>和其他技术博客及相关网站整理。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>检测工具</tag>
        <tag>汽车安全</tag>
      </tags>
  </entry>
  <entry>
    <title>CUSTOS: Practical Tamper-Evident Auditing of Operating Systems Using Trusted Execution</title>
    <url>/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/</url>
    <content><![CDATA[<p>CUSTOS: Practical Tamper-Evident Auditing of Operating Systems Using Trusted Execution abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>系统审计已成成为了攻击调查和攻击事件相应的重要手段，不幸的是，攻击者在渗透进入目标环境后通常会进行反取证活动，从系统日志中掩盖他们的踪迹。虽然整个行业和文献中出现了各种防篡改日志记录的解决方案，但是这些技术不满足系统层审计框架的操作和可拓展性要求。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/arch.png" alt="arch"></p>
<p>所以，本文介绍了 CUSTOS，一种用于检测系统日志篡改的实用框架。</p>
<h2 id="思路及方法">思路及方法</h2>
<p>CUSTOS 由防篡改日志记录层和去中心化审计协议组成，前者可以通过对底层日志框架的最小更改来验证日志完整性，而后者可以在企业级网络中近乎实时地检测日志完成性的违规操作。<br>
CUSTOS 之所以使用，是因为我们可以将加密日志提交的成本与创建和存储日志事件的行为分离，而无需牺牲安全性，利用现成的可信执行环境的功能。</p>
<h3 id="Tamper-Evident-Logger">Tamper-Evident Logger</h3>
<p>tamper-evident 记录协议有5个例程，具体如图：</p>
<ul>
<li>初始化 Initialization</li>
<li>启动 Startup</li>
<li>记录 Logging</li>
<li>提交 Commitment</li>
<li>关闭 Shutdown</li>
</ul>
<p><img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/protoc.png" alt="protocol"></p>
<p>具体算法如下：</p>
<p><img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/algo-tel.png" alt="algo"></p>
<h3 id="Centralized-Auditing">Centralized Auditing</h3>
<p><img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/ca.png" alt="centralized auditing procedure"></p>
<p><img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/notation.png" alt="notation"><br>
<img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/eg-ca.png" alt="eg"></p>
<h3 id="Decentralized-Auditing">Decentralized Auditing</h3>
<p><img src="/2022/04/19/CUSTOS-Practical-Tamper-Evident-Auditing-of-Operating-Systems-Using-Trusted-Execution/dca.png" alt="decentralized auditing procedure"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering</title>
    <url>/2022/03/31/Convolutional-Neural-Networks-on-Graphs-with-Fast-Localized-Spectral-Filtering/</url>
    <content><![CDATA[<p>Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering 读书笔记。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/03/31/Convolutional-Neural-Networks-on-Graphs-with-Fast-Localized-Spectral-Filtering/arch.png" alt="架构图"></p>
<h3 id="局部快速频谱滤波">局部快速频谱滤波</h3>
<p>定义卷积过滤器有两种策略：</p>
<ul>
<li>空域，存在本地邻居匹配问题</li>
<li>频域，有定义良好的本地卷积操作</li>
</ul>
<h3 id="图简化">图简化</h3>
<p>采用 Graclus 多级聚类算法进行处理，该方法已经被证明在对大量图进行聚类时非常有效。</p>
<h3 id="池化例子">池化例子</h3>
<p><img src="/2022/03/31/Convolutional-Neural-Networks-on-Graphs-with-Fast-Localized-Spectral-Filtering/example.png" alt="例子"></p>
<h3 id="总结">总结</h3>
<p>提出了一种基于 gsp 的有效的 CNN 通用方法，可以应用在图上。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>池化操作</tag>
        <tag>图卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Cyber security threat modeling based on the MITRE Enterprise ATT&amp;CK Matrix</title>
    <url>/2021/07/08/Cyber-security-threat-modeling-based-on-the-MITRE-Enterprise-ATT-CK-Matrix/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To proactively address these security issues in enterprise systems, this paper proposes a threat modeling language for enterprise security based on the MITRE Enterprise ATT&amp;CK Matrix. It is designed using the Meta Attack Language framework and focuses on describing system assets, attack steps, defenses, and asset associations. The attack steps in the language represent adversary techniques as listed and described by MITRE. This entity-relationship model describes enterprise IT systems as a whole; by using available tools, the proposed language enables attack simulations on its system model instances. These simulations can be used to investigate security settings and architectural changes that might be implemented to secure the system more effectively. Our proposed language is tested with a number of unit and integration tests. This is visualized in the paper with two real cyber attacks modeled and simulated.</span><br></pre></td></tr></table></figure>
<p>abstract中指出：</p>
<ul>
<li>文章提出一种基于 <code>MITRE</code> 攻击矩阵的威胁建模语言，可以用进行企业安全分析</li>
<li>该语言使用元攻击语言框架设计，重点描述系统资产、攻击步骤、防御和资产关系</li>
<li>语言描述中的攻击步骤表示攻击者使用的攻击技术，这些攻击技术是 <code>MITRE</code> 定义的</li>
<li>实体关系模型将企业 <code>IT</code> 系统描述为一个整体，通过使用工具，该语言可以对系统模型实例进行攻击模拟</li>
<li>攻击模拟可以用来评估安全设置和架构改变对加强系统安全的有效性</li>
<li>文章提出的语言经过了大量的单元测试和集成测试，并且使用了两个真实的网络攻击模型进行了可视化仿真</li>
</ul>
<span id="more"></span>
<h2 id="设计方法论">设计方法论</h2>
<p><img src="/2021/07/08/Cyber-security-threat-modeling-based-on-the-MITRE-Enterprise-ATT-CK-Matrix/method_usage.jpg" alt="方案过程图"></p>
<h2 id="实例演示">实例演示</h2>
<p><img src="/2021/07/08/Cyber-security-threat-modeling-based-on-the-MITRE-Enterprise-ATT-CK-Matrix/attach_graph.jpg" alt="攻击图"></p>
<p><img src="/2021/07/08/Cyber-security-threat-modeling-based-on-the-MITRE-Enterprise-ATT-CK-Matrix/system_architecture.jpg" alt="系统架构"></p>
<p><img src="/2021/07/08/Cyber-security-threat-modeling-based-on-the-MITRE-Enterprise-ATT-CK-Matrix/attach_path.jpg" alt="攻击路径"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>ATT&amp;CK</tag>
        <tag>威胁建模</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepHunter: A Graph Neural Network Based Approach for Robust Cyber Threat Hunting</title>
    <url>/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cyber Threat hunting is a proactive search for known attack behaviors in the organizational information system. It is an important component to mitigate advanced persistent threats (APTs). However, the attack behaviors recorded in provenance data may not be completely consistent with the known attack behaviors. In this paper, we propose DeepHunter, a graph neural network (GNN) based graph pattern matching approach that can match provenance data against known attack behaviors in a robust way. Specifically, we design a graph neural network architecture with two novel networks: attribute embedding networks that could incorporate Indicators of Compromise (IOCs) information, and graph embedding networks that could capture the relationships between IOCs. To evaluate DeepHunter, we choose five real and synthetic APT attack scenarios. Results show that DeepHunter can hunt all attack behaviors, and the accuracy and robustness of DeepHunter outperform the state-of-the-art method, Poirot.</span><br></pre></td></tr></table></figure>
<p>abstract中指出：</p>
<ul>
<li>文章提出了一个基于 GNN 的图特征匹配方法，可以匹配源数据中的已知攻击</li>
<li>特别地，作者提出了两种新型的图神经网络：属性嵌入网络用于整合 IOCs 信息，图嵌入网络用于捕捉 IOCs 关系</li>
</ul>
<span id="more"></span>
<h2 id="设计概览和挑战">设计概览和挑战</h2>
<p>作者通过比较起源图和查询图的是否表示相同的攻击行为来完成威胁狩猎任务。因此，威胁狩猎任务，将会转化成为图特征匹配的任务。</p>
<p>由于任务的特性，对于完成图特征匹配任务的模型有以下要求：</p>
<ul>
<li>无需要专家知识</li>
<li>高效</li>
<li>高健壮性</li>
</ul>
<p>基于此，采用 图神经网络 来提取图特征和计算匹配分值将会非常方便，并且一旦图匹配模型学习完成后，匹配分数的计算将会非常简单，而且也不会依赖任何其他资源消耗大的图特征匹配算法了。</p>
<h3 id="挑战和解决方案">挑战和解决方案</h3>
<p>挑战1：如何有效地表示节点属性信息？</p>
<p>​	节点有不同的属性，这些属性对于图特征匹配可能有不同的重要性。作者提出了一种 属性嵌入网络（attribute embedding network）来表示节点的属性。将节点类型作为属性的一种，如进程/文件/socket等，然后使用注意力机制学习不同属性对于图特征匹配的任务的重要性。</p>
<p>挑战2：如何有效地表示图的结构？</p>
<p>​	本文方法中存在一个重要的问题，就是起源图和查询图是异构的，前人的工作中同构图可以采用相同的网络来处理，在本文中不能使用。因此作者提出了两种不同的图神经网络来分别处理两种网络：GCN 处理查询图；另外一种是特殊设计的网络来表示起源图。</p>
<h2 id="DeepHunter-图特征匹配模型">DeepHunter 图特征匹配模型</h2>
<h3 id="属性嵌入网络">属性嵌入网络</h3>
<p><img src="/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/attribut_embedding.png" alt="属性嵌入网络"></p>
<p>如上图所示，首先将 <code>node n1, n2 and edge e</code> 表示为如下所示：</p>
<p><code>Process conhost reads file netsh.exe in C : \\Windows\\System32.</code></p>
<p>然后将上述语句传入 <code>word2vec</code> 模型学习每个属性的向量表示，获得属性嵌入向量。</p>
<h3 id="用于编码图结构的图嵌入网络">用于编码图结构的图嵌入网络</h3>
<p>图嵌入网络被设计用来表示两种图的图结构。图嵌入网络包含两个阶段：节点嵌入阶段和图嵌入阶段。</p>
<h4 id="阶段一：节点嵌入阶段">阶段一：节点嵌入阶段</h4>
<p>节点嵌入方法将会导致查询图嵌入网络和起源图嵌入网络的不同，我们使用现有的图卷积网络来进行节点嵌入。因为查询图通常来说是很小的而且没有噪声，这样的图是可以通过图卷积网络来处理的。</p>
<p>为了处理起源图的节点嵌入问题，设计了 起源图嵌入网络，该网络结构能够处理冗余的节点并且保留主要信息用于匹配查询图。</p>
<p>起源图节点嵌入网络结构如下：</p>
<p><img src="/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/provenance_node_embedding.png" alt="起源图节点嵌入"></p>
<p>首先，设计了一个 GNN 层，叫做注意力聚集器（attention aggregator），该层会聚集目标节点的邻接节点信息。</p>
<p>在聚集时，不同节点和属性可能会有不同的重要性，因此对于冗余节点将会分配一个较小的权重值，对于匹配查询图的节点将会分配一个较高的权重值。</p>
<p>基于此添加了另一层注意力机制来学习节点属性权值。为了聚集不邻接节点的信息，由添加了一层注意力层来学习非邻接节点的属性信息。最后添加了全连接层来生成固定的输出向量。</p>
<h4 id="阶段二：图嵌入阶段">阶段二：图嵌入阶段</h4>
<p>现在获得了查询图和起源图的节点嵌入向量，在本部分，要解决的问题是如何使用节点嵌入向量生成低维的图嵌入向量。在本部分的工作中，使用了带全局上下文的注意机制，该方法在 SimGNN 提出，使用该机制获得图层次的嵌入向量。</p>
<h3 id="基于-GNN-的图特征匹配架构">基于 GNN 的图特征匹配架构</h3>
<p><img src="/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/graph_pattern_matching.png" alt="图特征匹配"></p>
<p>该框架包含两条路经，一条是处理 CTI 信息的，下面是处理起源信息的。在每一条路经的开始，构建起源图和查询图，这两个图都会传入基于 GNN 的模型。</p>
<h2 id="实施">实施</h2>
<h3 id="起源图去重">起源图去重</h3>
<p>现实中，服务器会长期启动，这会导致起源图的规模会不断增加。因此，在本部分将会对起源图进行修剪。</p>
<p>首先会使用 MITRE ATT&amp;CK TTPs 和 IOCs 来生成可以事件，特别地，DeepHunter 会使用 EDR 工具如 BLUES-PAWN 提供的匹配规则来检测 MITRE ATT&amp;CK TTPs. 当然，DeepHunter 也会使用正则表达式对威胁情报或者 APT 报告进行匹配提取，如果两个方式都标记为了可以事件，那么就将该事件视为可疑事件。</p>
<p>然后，使用作者设计的起源图去重算法可以对起源图进行修剪/去重，去除可以事件。</p>
<p><img src="/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/provenance_reduction_algo.png" alt="去重算法"></p>
<h3 id="训练数据生成">训练数据生成</h3>
<p>由于模型训练需要大量的正面样本和负面样本，首先，从起源图中抽取出一个子图，从一个进程节点出发，然后对其使用 DFS 算法，并对其路径长度进行限制，限制为不大于 4. 然后对其使用两个图像总结算法：</p>
<ul>
<li>合并具有相同进程名称的进程节点</li>
<li>删除重复路径，如果两条路径重复，则只保留一条路径</li>
</ul>
<p>然后对其加噪声：</p>
<ul>
<li>随机删除其某一条边或者实体节点</li>
<li>随机移除一个或者多个节点属性</li>
</ul>
<p>通过上述两种方法生成正面样本，对于负面样本的生成，通过随机组合子图实现。</p>
<p><img src="/2021/08/26/DeepHunter-A-Graph-Neural-Network-Based-Approach-for-Robust-Cyber-Threat-Hunting/scenarios_description.png" alt="场景描述"></p>
<p>后续就是，测试评估和具体效果，在此不再赘述。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>图神经网络</tag>
        <tag>攻击检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep k-NN Defense Against Clean-label Data Poisoning Attacks</title>
    <url>/2022/07/07/Deep-k-NN-Defense-Against-Clean-label-Data-Poisoning-Attacks/</url>
    <content><![CDATA[<p>Deep k-NN Defense Against Clean-label Data Poisoning Attacks abstract。</p>
<span id="more"></span>
<h2 id="原理">原理</h2>
<p>基于 k-NN 的异常样本点检测，检验当前样本的 k 个邻近样本，如果标签不一致则标记为异常样本，进行过滤。</p>
<h2 id="实现的防御方法">实现的防御方法</h2>
<ul>
<li>L2-Norm Outlier Defense</li>
<li>One-Class SVM Defense</li>
<li>Random Point Eviction Defense</li>
<li>Adversarial Training Defense</li>
</ul>
<p>仓库地址： <a href="https://github.com/neeharperi/DeepKNNDefense">https://github.com/neeharperi/DeepKNNDefense</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Data Poisoning</tag>
        <tag>Poisoning Defences</tag>
      </tags>
  </entry>
  <entry>
    <title>Demon in the Variant: Statistical Analysis of DNNs for Robust Backdoor Contamination Detection</title>
    <url>/2022/04/08/Demon-in-the-Variant-Statistical-Analysis-of-DNNs-for-Robust-Backdoor-Contamination-Detection/</url>
    <content><![CDATA[<p>Demon in the Variant: Statistical Analysis of DNNs for Robust Backdoor Contamination Detection abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/08/Demon-in-the-Variant-Statistical-Analysis-of-DNNs-for-Robust-Backdoor-Contamination-Detection/arch.png" alt="架构图"><br>
该文章实现具体架构如图，步骤为：</p>
<ul>
<li>将嵌入表示作为分析对象，恶意图片肉眼难以区分但是在嵌入表示层区别明显，并且恶意图片在嵌入表示上并不是所有恶意攻击样本如现有研究所假设的那样跟正常图片泾渭分明</li>
<li>将嵌入表示分离为目标类和其他类两层，“误分类是后门攻击的目的，因此存在后门的模型，在分恶意类时模型错误地学到了两种或者更多类的特征”，由此才导致分类恶意类时会被误分类</li>
<li>直接检查某一类的嵌入表示可能效果不好，将其它类别的也纳入考虑，并且假设每一类具有相似的分布，然后依据如下准则判断是否存在后门<br>
<img src="/2022/04/08/Demon-in-the-Variant-Statistical-Analysis-of-DNNs-for-Robust-Backdoor-Contamination-Detection/criterion.png" alt="判断标准"></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>后门植入检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Dependence-Preserving Data Compaction for Scalable Forensic Analysis</title>
    <url>/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/</url>
    <content><![CDATA[<p>Dependence-Preserving Data Compaction for Scalable Forensic Analysis abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>大型公司正在遭受长期的攻击，当一个攻击行为最终被发现，立即开始审计分析。系统审计日志提供了关键信息，不幸的是，长时间的日志采集使得其体积庞大。庞大的数据不仅消耗存储空间，而且也延缓了审计分析的速度。<br>
因此本文提出了两种强大的精简技术来进行数据压缩。</p>
<h2 id="思路与方法">思路与方法</h2>
<h3 id="保留依赖的精简方法-Dependence-Preserving-Reductions">保留依赖的精简方法 Dependence Preserving Reductions</h3>
<p>将一个带时间戳的依赖图G定义为另一个图G‘，G’包含相同节点但是之拥有原图事件的子集。这种处理可以取出冗余事件，并且日志精简需要满足一下条件：</p>
<ul>
<li>不会改变取证分析结果</li>
<li>不会影响对结果的理解</li>
</ul>
<h4 id="时间戳依赖图的可达性">时间戳依赖图的可达性</h4>
<h4 id="持续依赖保持-continuous-dependence-CD-preservation">持续依赖保持 continuous dependence(CD) preservation</h4>
<p><img src="/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/def-3.png" alt="def"></p>
<h4 id="全依赖保持-full-dependence-FD-preservation">全依赖保持 full dependence(FD) preservation</h4>
<p><img src="/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/def-4.png" alt="def"></p>
<h4 id="源依赖保持-source-dependence-SD-preservation">源依赖保持 source dependence(SD) preservation</h4>
<p><img src="/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/def-5.png" alt="def"></p>
<h3 id="优化计算量的精简算法-efficient-computation-of-reduction">优化计算量的精简算法 efficient computation of reduction</h3>
<h4 id="简单版本依赖图">简单版本依赖图</h4>
<p><img src="/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/eg-naive.png" alt="eg"></p>
<p><img src="/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/algo-naive.png" alt="algo naive"></p>
<h3 id="优化版本和全依赖保留-optimized-versioning-and-FD-preservation">优化版本和全依赖保留 optimized versioning and FD preservation</h3>
<h4 id="冗余边优化-redundant-edge-optimization-REO">冗余边优化 redundant edge optimization(REO)</h4>
<p><img src="/2022/04/20/Dependence-Preserving-Data-Compaction-for-Scalable-Forensic-Analysis/eg-ovfd.png" alt="eg"></p>
<h4 id="全局冗余边优化-global-redundant-edge-optimization-REO">全局冗余边优化 global redundant edge optimization(REO*)</h4>
<h4 id="冗余节点优化-redundant-node-optimization-RNO">冗余节点优化 redundant node optimization(RNO)</h4>
<h4 id="循环优化-cycle-collapsin-optimazation-CCO">循环优化 cycle-collapsin optimazation(CCO)</h4>
<h4 id="源依赖保留有效性优化-effectiveness-of-FD-optimizations">源依赖保留有效性优化 effectiveness of FD-optimizations</h4>
<h4 id="正确性和优化效果-correctness-and-optimality">正确性和优化效果 correctness and optimality</h4>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>数据压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Design and Implementation of a Novel Testbed for Automotive Security Analysis</title>
    <url>/2021/07/08/Design-and-Implementation-of-a-Novel-Testbed-for-Automotive-Security-Analysis/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this paper, we introduce design and implementation of an emulating internal vehicular network as a testbed that can be used to perform an intuitive analysis on the data set collected from the real vehicular network for different situations and replayed through the testing environment similar to an actual vehicle.</span><br></pre></td></tr></table></figure>
<p>abstract中指出：</p>
<ul>
<li>该文章设计并实现了汽车内部网络的一个模拟工具</li>
<li>可以用来执行数据分析和数据重放</li>
</ul>
<span id="more"></span>
<h2 id="设计与实施">设计与实施</h2>
<p>其设计模型图如下：</p>
<p><img src="/2021/07/08/Design-and-Implementation-of-a-Novel-Testbed-for-Automotive-Security-Analysis/architecture.png" alt="架构图"></p>
<h2 id="可用性评估">可用性评估</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The implemented framework was compared with the actual vehicle to evaluate its adequacy as an analysis object. It was found that the implemented framework was capable of collecting 7X messages amounting to 76% of 9X messages of the actual vehicle on the basis of CAN ID. In addition, it was possible to control the vehicle by CAN message injection and remote attack through IVI, and to collect data in the testing situation.</span><br></pre></td></tr></table></figure>
<p>仿真模型和实车比较之后发现：</p>
<ul>
<li>
<p>该仿真模型能够基于CAN ID采集到7X消息，占实际车辆9X消息的76%</p>
</li>
<li>
<p>可以通过CAN消息注入和IVI远程攻击来控制车辆</p>
</li>
</ul>
<h2 id="局限性">局限性</h2>
<p>该模型的实现同实车还存在着差异，因此该模型存在局限性：</p>
<ul>
<li>模型包含的 CAN ID 可能与一些汽车的 CAN ID 类型存在差异，因此不能分析不兼容汽车的差异</li>
<li>如BCM或ECM的报文与收集到的报文存在冲突，不能正常展示</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>汽车安全</tag>
        <tag>仿真模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Detecting AI trojans using meta neural analysis</title>
    <url>/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/</url>
    <content><![CDATA[<p>Detecting AI trojans using meta neural analysis abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p>在介绍本文架构之前首先介绍一下 元神经元分析（meta neural analysis，mna）的基本概念，具体流程如下图：<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/mna-arch.png" alt="arch"></p>
<p>与传统的网络不同， mna 不以图像、文本等数据为输入，而是以神经网络为输入训练一个可以预测目标网络属性的分类器，例如成员推理、模型属性推理、训练数据推理等等。具体操作步骤如下：</p>
<ul>
<li>训练两类影子模型，一类包含属性，一类不包含属性</li>
<li>合成影子模型数据集</li>
<li>使用该数据集训练一个元分类器</li>
</ul>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/mntd-arch.png" alt="arch"><br>
本文具体步骤如下：</p>
<ol>
<li>
<p>生成影子模型</p>
<ul>
<li>对于良性模型，设定不同的模型初始化参数，随机初始化参数</li>
<li>对于后门模型，从通用后门分布中取样投毒，生成后门模型</li>
</ul>
</li>
<li>
<p>元训练</p>
<ul>
<li>设计特征提取函数，获得影子模型的表示向量</li>
<li>设计了一个查询集来提取影子模型的重要表示向量</li>
<li>通过该向量训练元分类器</li>
</ul>
</li>
<li>
<p>目标模型检测</p>
<ul>
<li>给定一个目标模型，首先使用优化的查询集提取模型特征</li>
<li>然后送入元分类器获得结果</li>
</ul>
</li>
</ol>
<h3 id="影子模型生成-Jumbo-Learning-Shadow-Model-Generation">影子模型生成 Jumbo Learning - Shadow Model Generation</h3>
<p>为了生成不同的后门模型使得元分类器具有一定泛化性，检测不同类型的后门，提出了 jumbo learning 的方法，并且假设攻击者能够应用任何攻击策略。</p>
<p>Jumbo Learning 建模了后门攻击设置的通用分布（models a generic distribution of Trojan attack settings），并且能够基于此生成不同的后门模型。<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/fomula-1.png" alt="fomula"></p>
<p>首先，使用函数 <code>L</code> 对攻击设计进行参数化，使该函数可以表示不同的攻击，jumbo learning 的算法实现如下图：<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/algo-1.png" alt="algo"></p>
<p>注意到函数 <code>L</code> 不能表示全部的后门攻击设定，因此文章后续又针对未知攻击（unforeseen trojan attack model）进行了验证，表明了即使如此，元分类器依旧对于此类未知攻击具有泛化性。</p>
<h3 id="元训练-Meta-training">元训练 Meta-training</h3>
<p>接下来需要使用生成的影子模型进行元分类器的训练，此训练包含两个目标：</p>
<ul>
<li>寻找一个特征提取函数，提取影子模型的表征向量</li>
<li>训练元分类器，分辨良性和后门模型</li>
</ul>
<h4 id="特征提取函数的设计-Feature-Extraction-Function-Design">特征提取函数的设计 Feature Extraction Function Design</h4>
<p>提出使用一组查询的模型输出作为表征向量，这样做基于两点：</p>
<ul>
<li>后门模型跟良性模型在处理一些输入时行为上有差别，例如后门触发特征</li>
<li>可以在不需要模型结构信息的情况下获得输出，这使得<strong>黑盒</strong>场景下检测后门成为可能</li>
</ul>
<p>具体来说，选择了一组输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X = \{x_1,...,x_k\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 使用其拼接后的输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R_i = \{f_i(x_1),...,f_i(x_k)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)}</span></span></span></span> 作为影子模型的表示。接下来会介绍具体如何获得一组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>。</p>
<h4 id="元分类器设计-Meta-classifier-Design">元分类器设计 Meta-classifier Design</h4>
<p>使用一个两层全连接的神经网络作为元分类器，元分类器将会把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 作为输入并输出一个表示该模型是后门模型可能性的值。</p>
<h4 id="元训练算法-Meta-Training-Algorithm">元训练算法 Meta-Training Algorithm</h4>
<p>在训练阶段将会寻找最优的查询集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 和最优的分类器参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>。</p>
<p>一个简单的方法是随机选择查询集 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 并预计算所有表征向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，在此条件上仅优化元分类器，由此元训练可以简化为，在给定上述两个参数的情况下，仅使用基于梯度的优化最小化下列损失函数即可：<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/fomula-2.png" alt="fomula"></p>
<p>上述方法能获得一个不错的准确率，然而随机取样可能对区分良性模型和恶意模型没有帮助，因为在大多数情况下两者的行为表现是相似的。</p>
<p>因此，选择了通过最优化查询集获得最有用的表征向量，来提高元分类器的性能。提出查询优化（query-tuning）技术来寻找最优的查询集，与现有技术相似，具体的中心思想是：</p>
<ul>
<li>联合优化查询集和元分类器使得训练损失最小</li>
</ul>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/fomula-3.png" alt="fomula"></p>
<p>为了优化上式，一个重要的点是整个计算流程都是可微分的，证明如下：</p>
<ul>
<li>首先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 送入影子模型获得表征向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>然后将表征向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 送入元分类器训练</li>
<li>因为影子模型和元分类器都是可微分的</li>
<li>所以可以直接计算输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的损失函数的梯度</li>
</ul>
<p>如此，首先从高斯分布中随机取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 然后迭代更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 优化 <code>loss</code> 函数。</p>
<h3 id="基线元训练算法-Baseline-Meta-training-algorithm-without-jumbo-learning">基线元训练算法 Baseline Meta-training algorithm without jumbo learning</h3>
<p>前面所述的模型需要使用 jumbo learning 生成一系列后门影子模型，文章介绍了一种仅使用良性模型训练的基线训练算法。</p>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/one-class.png" alt="illustration"></p>
<p>该算法的具体原理如上图所示，使用良性数据学习一个决策边界，判断测试数据是落在边界内部还是外部，落在内部的则为良性模型，落在外部则极有可能是后门模型。</p>
<h2 id="实验设置-Experiment-Setup">实验设置 Experiment Setup</h2>
<p>文章的源代码仓库为：<a href="https://github.com/AI-secure/Meta-Nerual-Trojan-Detection">https://github.com/AI-secure/Meta-Nerual-Trojan-Detection</a></p>
<h3 id="数据集-Dataset">数据集 Dataset</h3>
<p>图片分类任务：</p>
<ul>
<li>mnist</li>
<li>cifar10</li>
</ul>
<p>语音类任务：</p>
<ul>
<li>SpeechCommand</li>
</ul>
<p>表格类数据：</p>
<ul>
<li>Smart Meter Electricity Trial data in Ireland dataset (Irish)</li>
</ul>
<p>自然语言数据：</p>
<ul>
<li>Rotten Tomatoes movie review dataset (MR)</li>
</ul>
<h3 id="攻击设定-Attack-Settings">攻击设定 Attack  Settings</h3>
<p>对于除了 MR 的每个数据集，攻击者会生成 256 个后门目标模型，单独使用篡改攻击（modification attack）或者模糊攻击（blending attack）。</p>
<p><strong>Trigger mask m</strong>：对于模糊攻击来说，<code>m=1</code> 即对整张图像进行模糊，对于修改攻击来说，m 会根据任务有所不同，在 <code>mnist</code> 和 <code>cifar10</code> 数据集上，m 是图像上随机位置的一个 <code>2*2～5*5</code> 的方形特征。</p>
<p><strong>Trigger pattern t</strong>：对于模糊攻击和修改攻击，触发特征会使用相同的方法生成。在 <code>mnist</code> 和 <code>cifar10</code> 上，每个像素会从 <code>[0,1]</code> 中均匀采样。</p>
<p><strong>Transparent <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span></strong>:修改攻击不存在透明度，模糊攻击透明度统一从 <code>[0.8,0.95]</code> 中取样。</p>
<p><strong>Malicious label <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">y_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></strong>:恶意标签统一从分类输出中取样，如 <code>0-9</code> 为 <code>mnist</code> 数据集。</p>
<p><strong>Data poisoning ratio p</strong>：投毒比例统一从 <code>[0.05,0.5]</code> 中随机取样。</p>
<h3 id="防御设定-Defense-Settings">防御设定 Defense Settings</h3>
<p>安全人员会使用 jumbo 训练 2048 个后门模型，使用随机初始化训练 2048 个良性模型用于训练元分类器，另外也会生成 256 后门模型和良性模型用于验证。</p>
<p>除了以下特征外，与攻击者使用想同的方法生成后门模型：</p>
<ul>
<li>安全人员数据集大小远比攻击者数据集要小</li>
<li>特征大小取决于攻击类型</li>
<li>透明度也取决于攻击类型</li>
</ul>
<p>另外，还确保了攻击者的 jumbo learning settings 不会在安全人员生成训练数据集时被采用。</p>
<h3 id="检测基线-Detection-Baselines">检测基线 Detection Baselines</h3>
<p>在评估阶段，比较了四个现有工作作为检测基线：</p>
<ul>
<li>Activation Clustering（AC）</li>
<li>Neural Cleanse（NC）</li>
<li>Spectral Signature（Spectral）</li>
<li>STRIP</li>
</ul>
<p>没有比较 <code>DeepInspect</code> 是因为没有公开代码并且处理流程比较复杂。<br>
没有比较 <code>SentiNet</code> 是因为仅在图片数据集上，并且其模型级别的检测较为耗时。</p>
<h2 id="实验评估结果-Experiment-Evaluation">实验评估结果 Experiment Evaluation</h2>
<h3 id="后门攻击性能-Trojan-Attack-Performance">后门攻击性能 Trojan Attack Performance</h3>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-2.png" alt="table"></p>
<p>可以看到表格中，攻击者已经成功将后门嵌入了模型中，并且准确率与良性模型相近。另外也发现后门模型和良性模型之间有性能差距，这表示模型使用者没有能力基于小数据集训练高质量的模型。因此他们需要使用共享的模型，而不是自己训练一个模型。</p>
<h3 id="检测性能-Detection-Performance">检测性能 Detection Performance</h3>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-3.png" alt="table"></p>
<p>如前所述，所有的基线算法都有其攻击设定，因而只能在限定的条件下取得不错的效果，无法应用在全部攻击设定中。</p>
<h3 id="影子模型数量的影响-Impact-of-Number-of-Shadow-Models">影子模型数量的影响 Impact of Number of Shadow Models</h3>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/auc-num-impact.png" alt="auc"></p>
<p>如上图所示，文章研究了不同的影子模型样本数量对于元分类器训练的影响。并表示文章提出的方法可以在较少的样本就获得较高的准确率，并且拥有计算资源的使用者可以自行设定训练样本数量来提高准确率。</p>
<h3 id="运行性能-Running-Time-Performance">运行性能 Running Time Performance</h3>
<p><img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-4.png" alt="table"></p>
<p>文章对检测运行时的性能做了评估，运行的显卡是：</p>
<ul>
<li>NVIDIA GeForce RTX 2080</li>
</ul>
<h2 id="泛化性">泛化性</h2>
<p>最后在泛化性方面做了探究，证明了元分类器可以在一定程度上检测未知的后门攻击。<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-5.png" alt="table"></p>
<p>并且在以下方面对实验进行了泛化性调整：</p>
<ul>
<li>触发特征的泛化，如上图</li>
<li>攻击目标的泛化，jumbo 中仅考虑单类别攻击，在此考虑了全类别攻击（all-to-all）</li>
<li>攻击方法的泛化，jumbo 中仅考虑了篡改攻击和模糊攻击，在此添加了基于参数（parameter）和隐藏（latent）的攻击</li>
<li>模型结构的泛化</li>
<li>数据分布的泛化，前面假设安全人员的数据与训练时服从相同分布，在此处考虑相似但不是同分布的数据</li>
</ul>
<p>上述实验结果如下：<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-6.png" alt="table"><br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-7.png" alt="table"><br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-8.png" alt="table"></p>
<h2 id="适应性攻击和对抗措施">适应性攻击和对抗措施</h2>
<p>实验部分最后考虑了 mntd 被攻击的场景，并且提出了一种对抗措施。<br>
<img src="/2022/07/21/Detecting-AI-trojans-using-meta-neural-analysis/table-9.png" alt="table"></p>
<h2 id="总结">总结</h2>
<p>首先采用元神经训练的方法进行后门检测，思路清晰实验完善，工作量很饱满，被收录于 <code>Proceedings - IEEE Symposium on Security and Privacy - 2021</code>，很优秀的工作。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Survey</tag>
        <tag>AI Backdoor Attacks</tag>
      </tags>
  </entry>
  <entry>
    <title>Detecting Poisoning Attacks on Machine Learning in IoT Environments</title>
    <url>/2022/08/03/Detecting-Poisoning-Attacks-on-Machine-Learning-in-IoT-Environments/</url>
    <content><![CDATA[<p>Detecting Poisoning Attacks on Machine Learning in IoT Environments abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/08/03/Detecting-Poisoning-Attacks-on-Machine-Learning-in-IoT-Environments/overview.png" alt="arch"></p>
<p>具体贡献有：</p>
<ul>
<li>一个新型算法检测和过滤污染数据</li>
<li>两个基于溯源信息的变体防御：部分可信和完全不可信</li>
<li>evaluation</li>
</ul>
<h2 id="部分可信的防御方法-Defences-for-Partially-Trusted-Data">部分可信的防御方法 Defences for Partially Trusted Data</h2>
<p>具体输入如下：</p>
<ul>
<li>一个有监督机器学习算法</li>
<li>为了训练机器学习算法采集的数据集，包含可信和不可信两部分</li>
<li>一个安全可信的溯源数据集，描述不可信部分中每个数据点的溯源和沿袭的源数据组成</li>
<li>溯源特征，表征污染数据如何聚集在数据集的不可信部分中</li>
</ul>
<p>给定以上输入后，具体方法如上图所示。</p>
<h2 id="全部不可信的防御方法-Defences-for-Fully-Untrusted-Data">全部不可信的防御方法 Defences for Fully Untrusted Data</h2>
<p>存在一些场景下无法确认数据是否可信，为了将本方法应用到非可信数据集上，提出以下步骤：</p>
<ul>
<li>根据选择的溯源特征分段</li>
<li>对于每个段，随机将一部分数据分配给训练集，将其余数据分配给评估集。</li>
<li>对于每个所选特征中的签名：
<ul>
<li>训练两个模型，一个包含所有训练数据，一个删除训练数据中相应的段</li>
<li>在评估集上评估两个模型，并删除相应的段</li>
<li>如果在没有该段的情况下模型表现更好，则永久从训练和评估集中删除这些片段</li>
</ul>
</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>数据投毒检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Detection of Adversarial Training Examples in Poisoning Attacks through Anomaly Detection</title>
    <url>/2022/04/22/Detection-of-Adversarial-Training-Examples-in-Poisoning-Attacks-through-Anomaly-Detection/</url>
    <content><![CDATA[<p>Detection of Adversarial Training Examples in Poisoning Attacks through Anomaly Detection abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>数据投毒是针对机器学习系统的安全威胁，攻击者可以在训练数据中注入恶意样本来破坏学习过程。<br>
最近在针对机器学习的攻击方面的工作表明，所谓的最优攻击策略可以成功地给线性分类器投毒，改变一小部分训练数据之后可以显著降低系统性能。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/22/Detection-of-Adversarial-Training-Examples-in-Poisoning-Attacks-through-Anomaly-Detection/arch.png" alt="arch"><br>
在本文中，提出了一个可以降低基于异常值最佳投毒攻击的防御机制。</p>
<h2 id="思路与步骤">思路与步骤</h2>
<ul>
<li>从数据集中分离出一部分可信的数据</li>
<li>针对每一类训练一个基于距离的异常值检测器</li>
<li>给定一个数据集，为其中每个样本计算一个异常值q(x)，并基于训练实例分数的经验累积分布函数 Empirical Cumulative distribution Function, ECDF 获得阈值</li>
<li>识别真实数据比例 alpha-percentile</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>异常值检测</tag>
      </tags>
  </entry>
  <entry>
    <title>DiffPool:Hierarchical Graph Representation Learning with Differentiable Pooling</title>
    <url>/2022/03/28/DiffPool-Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling/</url>
    <content><![CDATA[<p>关于diffpool的读书笔记。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/03/28/DiffPool-Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling/arch.png" alt="架构"><br>
池化操作主要分为两步：</p>
<ul>
<li>使用 GNN 获得节点的特征</li>
<li>聚类获得池化后的池化网络</li>
</ul>
<h2 id="具体实现">具体实现</h2>
<h3 id="使用分配矩阵来进行池化操作">使用分配矩阵来进行池化操作</h3>
<p><img src="/2022/03/28/DiffPool-Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling/pooling_with_assignment_matrix.png" alt="池化公式"></p>
<h3 id="通过学习获得分配矩阵">通过学习获得分配矩阵</h3>
<p><img src="/2022/03/28/DiffPool-Hierarchical-Graph-Representation-Learning-with-Differentiable-Pooling/learning_assignment_matrix.png" alt="分配矩阵计算公式"><br>
需要注意到是，上述公式中使用的 GNN 输入相同的数据但是具有不同参数和起到不同作用：</p>
<ul>
<li>嵌入GNN生成节点特征</li>
<li>池化GNN生成输入节点到 {n_{l+1}} 个集群的分配概率</li>
</ul>
<h3 id="排列不变性">排列不变性</h3>
<p>请注意，为了对图分类有用，池化层在节点排列下应该是不变的。 对于 DIFFPOOL，我们得到以下肯定结果，这表明任何基于 DIFFPOOL 的深度 GNN 模型都是置换不变的，只要组件 GNN 是置换不变的。</p>
<h2 id="辅助链接预测目标和熵正则化">辅助链接预测目标和熵正则化</h2>
<p>在训练早期，存在非凸优化问题，在训练早期很难将池化 GNN 推离虚假的局部最小值。</p>
<p>为了缓解这个问题，我们使用辅助链接预测目标来训练池化 GNN，该目标编码了附近节点应该被池化在一起的直觉。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>池化操作</tag>
        <tag>图卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+Vue+Mysql服务器搭建</title>
    <url>/2022/06/22/Django-Vue-Mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Django+Vue+Mysql服务器搭建教程。</p>
<span id="more"></span>
<h2 id="Django-项目初始化">Django 项目初始化</h2>
<h3 id="初始化-Django-项目">初始化 Django 项目</h3>
<p>首先创建虚拟环境，然后在虚拟环境中安装 <code>django</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m venv venv</span><br><span class="line">source venv/bin/activate</span><br><span class="line">pip install django</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>deactivate</code> 退出虚拟环境。<br>
创建 <code>django</code> 项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startprject your_project_name</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，你将会看到一个自动创建的目录 <code>your_project_name</code>，自动创建的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_project_name/</span><br><span class="line">    manage.py</span><br><span class="line">    your_project_name/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure>
<p>创建项目中的一个应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py startapp your_app</span><br></pre></td></tr></table></figure>
<p>执行上述命令后你会获得一个新的 <code>your_app</code> 目录，具体目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">your_app/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations/</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>
<p>至此，项目初始化完成，接下来需要编写视图：</p>
<ol>
<li>在 <code>views.py</code> 中添加处理函数</li>
<li>在 <code>views.py</code> 同级目录下新建 <code>urls.py</code> 添加对应的路径，关联 <code>views.py</code> 中定义的函数</li>
<li>在跟目录的 <code>urls.py</code> 中指定 <code>your_app.urls</code> 模块<br>
上述步骤具体代码如下：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># your_app/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello, world. You&#x27;re at the polls index.&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># your_app/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># your_project/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;polls/&#x27;</span>, include(<span class="string">&#x27;polls.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="连接数据库">连接数据库</h3>
<p>默认的 Django 使用 Sqlite3 作为后端数据库，默认配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: BASE_DIR / &#x27;db.sqlite3&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 MySQL 数据库，则需要以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;your_database_name_in_mysql&#x27;,</span><br><span class="line">        &#x27;USER&#x27;: &#x27;your_username&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;your_password&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;your_mysql_server_ip&#x27;,</span><br><span class="line">        &#x27;PORT&#x27;: 3306,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义你的数据">定义你的数据</h3>
<p>在 your_app/models.py 中创建属于你的数据结构，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models </span><br><span class="line"></span><br><span class="line">class YourClass(models.Model):</span><br><span class="line">    &#x27;&#x27;&#x27;django 会自动创建主键，此处只需要创建你需要的字段即可&#x27;&#x27;&#x27;</span><br><span class="line">    text = models.TextField()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在 <code>your_project/settings.py</code> 中的 <code>INSTALLED_APPS</code> 字段中注册激活你的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;your_app.apps.YourAppConfig&#x27;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>使用 <code>python manage.py makemigration your_app</code> 确认是否需要进行数据修改。<br>
使用 <code>python manage.py migrate your_app</code> 执行前面列出的修改内容。</p>
<h3 id="导入你的数据">导入你的数据</h3>
<p>单个数据的导入，首先用 <code>pyton manage.py shell</code> 进入django 的交互式命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from your_app.models import YourClass           # 导入数据结构</span><br><span class="line">&gt;&gt;&gt; instance_yc = YourClass(text=&#x27;this is a text&#x27;)  # 实例化数据结构</span><br><span class="line">&gt;&gt;&gt; instance_yc.save()                              # 保存到数据库</span><br></pre></td></tr></table></figure>
<p>批量导入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from your_app.models import YourClass</span><br><span class="line">&gt;&gt;&gt; objs_to_save = []</span><br><span class="line">&gt;&gt;&gt; for each in data:</span><br><span class="line">...     instance = YourClass(text=each)</span><br><span class="line">...     objs_to_save.append(instance)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; objs = YourClass.objects.bulk_create(objs_to_save)  # 批量上传</span><br></pre></td></tr></table></figure>
<h3 id="创建管理员帐号和注册你的数据模型">创建管理员帐号和注册你的数据模型</h3>
<p>使用 <code>python manage.py createsuperuser</code> 创建一个管理员用户。<br>
在 <code>your_app/admin.py</code> 中添加 <code>admin.site.register(YourClass)</code> 即可添加你的数据结构到后台管理界面，可以使用后台管理界面方便地管理。</p>
<h3 id="修改响应方式为-JsonResponse">修改响应方式为 JsonResponse</h3>
<p>形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.http import JsonResponse</span><br><span class="line">from django.views.decorators.http import require_http_methods</span><br><span class="line"></span><br><span class="line">@require_http_methods([&quot;GET&quot;])</span><br><span class="line">def index(request):</span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    response[&#x27;msg&#x27;] = &quot;This is an index page.&quot;</span><br><span class="line">    return JsonResponse(response)</span><br></pre></td></tr></table></figure>
<p>至此，django 项目初始化完成，接下来看如何建立 vue 项目并且与 django 后端交互。</p>
<h2 id="Vue-项目初始化">Vue 项目初始化</h2>
<p>使用模板 <a href="https://github.com/PanJiaChen/vue-admin-template">vue-admin-template</a> 进行前端开发，现在需要注意的问题有两个：</p>
<ul>
<li>vue 与后端 Django 通信</li>
<li>跨域问题</li>
</ul>
<h3 id="配置-vue-与后端-Django-通信">配置 vue 与后端 Django 通信</h3>
<p>需要修改两个位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.env.dev </span><br><span class="line">src/utils/request.Vue  baseUrl</span><br></pre></td></tr></table></figure>
<p>将此处两个地址改为后端地址即可访问后端获取数据，实现前后端通信。</p>
<h3 id="跨域问题">跨域问题</h3>
<p>使用 <code>django-cors-headers</code> 实现跨域问题，首先需要安装该包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>
<p>然后需要对 Django 中的 settings 文件进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    &#x27;corsheaders&#x27;，</span><br><span class="line">    ...</span><br><span class="line"> ]</span><br><span class="line"></span><br><span class="line"># 添加中间件</span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,# 默认</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, # 默认</span><br><span class="line"></span><br><span class="line">    &#x27;corsheaders.middleware.CorsMiddleware&#x27;,# 默认</span><br><span class="line">    # 注意顺序，即在上一个的下面</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;, # 新增 ✔</span><br><span class="line"></span><br><span class="line">    &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,# 默认</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,# 默认</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, # 默认</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,# 默认</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,# 默认</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 跨域增加忽略</span><br><span class="line">CORS_ALLOW_CREDENTIALS = True</span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = True</span><br><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    &#x27;*&#x27;</span><br><span class="line">)</span><br><span class="line">CORS_ALLOW_METHODS = (</span><br><span class="line">    &#x27;DELETE&#x27;,</span><br><span class="line">    &#x27;GET&#x27;,</span><br><span class="line">    &#x27;OPTIONS&#x27;,</span><br><span class="line">    &#x27;PATCH&#x27;,</span><br><span class="line">    &#x27;POST&#x27;,</span><br><span class="line">    &#x27;PUT&#x27;,</span><br><span class="line">    &#x27;VIEW&#x27;,</span><br><span class="line">)</span><br><span class="line">CORS_ALLOW_HEADERS = (</span><br><span class="line">    &#x27;XMLHttpRequest&#x27;,</span><br><span class="line">    &#x27;X_FILENAME&#x27;,</span><br><span class="line">    &#x27;accept-encoding&#x27;,</span><br><span class="line">    &#x27;authorization&#x27;,</span><br><span class="line">    &#x27;content-type&#x27;,</span><br><span class="line">    &#x27;dnt&#x27;,</span><br><span class="line">    &#x27;origin&#x27;,</span><br><span class="line">    &#x27;user-agent&#x27;,</span><br><span class="line">    &#x27;x-csrftoken&#x27;,</span><br><span class="line">    &#x27;x-requested-with&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>techniques</category>
        <category>server</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Vue</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>EXTRACTOR: Extracting Attack Behavior from Threat Reports</title>
    <url>/2022/04/13/EXTRACTOR-Extracting-Attack-Behavior-from-Threat-Reports/</url>
    <content><![CDATA[<p>EXTRACTOR: Extracting Attack Behavior from Threat Reports abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>威胁情报对于有效识别和快速反应网络攻击来说十分重要，但是这些知识通常在大量的文本中，很难对其加以利用。<br>
为了解决此问题，提出本文方法。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/13/EXTRACTOR-Extracting-Attack-Behavior-from-Threat-Reports/arch.png" alt="arch"></p>
<p>本文提供了一种新的方法和工具，可以从 威胁情报 报告中精确地自动提取简洁的攻击行为。</p>
<p>并且 EXRACTOR 对于文本不做强假设，能够从非结构化文本中提取攻击行为作为溯源图。</p>
<p>存在的挑战：</p>
<ul>
<li>文本冗长</li>
<li>威胁情报文本复杂</li>
<li>关系提取</li>
</ul>
<h2 id="实现">实现</h2>
<h3 id="标准化">标准化</h3>
<p>为了有效解决 威胁情报 CTI 的文本复杂性，必须找到一些重要句型，在此通过标准化实现。<br>
<strong>标签化</strong>:</p>
<p><img src="/2022/04/13/EXTRACTOR-Extracting-Attack-Behavior-from-Threat-Reports/eg1.png" alt="eg1"></p>
<p><strong>同质化</strong>：<br>
使用两个专门构造的词典对名词断语和动词执行同质化，将 CTI 报告中存在的名词和动词的不同行话和同义词映射到可以在审计日志中观察到的实体和操作。<br>
<strong>转换</strong>：<br>
在此处 将被动语态转换成主动语态，有助于发现系统主体（过程）和系统对象，使因果关系推断更加准确。<br>
使用 POS 和 DP 标记检测句子语态，然后进行转换。<br>
经过此处的转换，长难句可以被转化为主动的短句。</p>
<h3 id="解析">解析</h3>
<p>解析部分将引用同一实体的隐式引用与实际引用相协调。出于两个原因，隐式引用必须被转换为显式的：</p>
<ul>
<li>隐式引用降低了后续步骤的准确性</li>
<li>审计日志仅包含明确命名的实体，并且 威胁搜寻方法 无法与系统进程与代词和其他隐式引用相匹配</li>
</ul>
<p><strong>省略主体解析</strong>：<br>
省略主语的句子大量存在在 CTI 报告中，因此该模块使用 POS 和 DP 解析以及系统调用字典解决这个问题。第一步检测缺少主语的句子，然后构建候选主语列表，挑选最有可能的候选者。</p>
<p><strong>代词解析</strong>：<br>
为了解析代词，采用了一种流行的共指解析模型，在解析代词时效果最好，特别是经过前面的 ESR 和标记化步骤之后。</p>
<p><strong>实体解析</strong>：<br>
给出了三种模式。为了识别句子中的实体，将 POS 标记与包含在 CTI 名词词典或每种情况下出现的常用短语语料库中的领域只是结合使用。一般是先检测上述罗列的三种形式之一，然后进行不同的处理。</p>
<h3 id="汇总">汇总</h3>
<p>去冗余，语句层次和字词层次。<br>
<img src="/2022/04/13/EXTRACTOR-Extracting-Attack-Behavior-from-Threat-Reports/arch-summarizer.png" alt="arch"></p>
<h3 id="图生成">图生成</h3>
<h4 id="语义角色标签-Semantic-Role-Labeling-SRL">语义角色标签 Semantic Role Labeling, SRL</h4>
<p><img src="/2022/04/13/EXTRACTOR-Extracting-Attack-Behavior-from-Threat-Reports/eg-srl.png" alt="arch"><br>
在进行完了 RAW SRL 之后还需要进行 动作到系统调用的转换。</p>
<h4 id="图生成器">图生成器</h4>
<p>先合并具有相同文本 SRL 参数到同一个几点钟，然后使用 SEE 修剪不是系统实体的单词。接下来，通过一下步骤生成图：</p>
<ul>
<li>点边点三元组</li>
<li>边方向</li>
</ul>
<h4 id="系统实体抽取器-System-Entity-Extractor-SEE">系统实体抽取器 System Entity Extractor, SEE</h4>
<p>使用 SEE 来抽取 SRL 生成的角色生成系统实体的简洁节点，并且修剪掉无法构成可能的系统实体的部分。</p>
<h4 id="因果推理-casual-inference">因果推理 casual inference</h4>
<p>此步骤中确定图中边的正确方向，以表示节点之间的因果关系和信息流。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>威胁情报</tag>
        <tag>信息提取</tag>
      </tags>
  </entry>
  <entry>
    <title>EigenPool:Graph Convolutional Networks with EigenPooling</title>
    <url>/2022/03/30/EigenPool-Graph-Convolutional-Networks-with-EigenPooling/</url>
    <content><![CDATA[<p>Graph Convolutional Networks with EigenPooling 读书笔记。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/03/30/EigenPool-Graph-Convolutional-Networks-with-EigenPooling/arch.png" alt="架构图"></p>
<h2 id="contribution">contribution</h2>
<ul>
<li>EigenPooling 可以总结子图信息，使得整图分类可以利用上子图结构细腻些</li>
<li>EigenPooling 的理论解释，局部和整图视角的解释</li>
<li>EigenGCN</li>
</ul>
<h2 id="具体实现">具体实现</h2>
<p>具体操作为两个GCN加一个Eigen池化层。<br>
每个池化层将图上定义的图信号汇集到输入图的粗化版本上的图信号，该图由更少的节点组成。<br>
因此，池化层包含两个部分：</p>
<ul>
<li>图简化(graph coarsening)</li>
<li>图信号转化(graph signal transform)</li>
</ul>
<h3 id="基于图划分的图简化">基于图划分的图简化</h3>
<p>给定无重叠的子图划分，将每个子图转化为一个高级节点（简化后的图上的一个节点），并且通过跨子图的边确定高级节点之间的连通性。</p>
<h3 id="基于特征的池化-Eigenvector-Based-Pooling">基于特征的池化 Eigenvector-Based Pooling</h3>
<p>因为图傅立叶变换可以将图心寒转化到谱域（spectral domain）并且考虑到图结构和图信号信息。<br>
所以池化操作采用了图傅立叶变换来进行。</p>
<h2 id="总结">总结</h2>
<p>本文研究图级别的表示学习，并且面向图分类任务。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>池化操作</tag>
        <tag>图卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Enabling Efficient Cyber Threat Hunting With Cyber Threat Intelligence</title>
    <url>/2022/04/27/Enabling-Efficient-Cyber-Threat-Hunting-With-Cyber-Threat-Intelligence/</url>
    <content><![CDATA[<p>Enabling Efficient Cyber Threat Hunting With Cyber Threat Intelligence abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>基于日志的网络威胁搜寻已经成为了应对复杂攻击的重要解决方案，然而现有方法需要人工查询构建，并且忽略了开源网络威胁情报提供的丰富外部威胁知识。<br>
为了弥补这一差距，本文提出一种方案。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/27/Enabling-Efficient-Cyber-Threat-Hunting-With-Cyber-Threat-Intelligence/arch.png" alt="arch"></p>
<p>整个系统包含两个子系统：</p>
<ul>
<li>威胁行为提取过程，自动提取威胁情报中的知识</li>
<li>基于系统日志的查询子系统</li>
</ul>
<p><img src="/2022/04/27/Enabling-Efficient-Cyber-Threat-Hunting-With-Cyber-Threat-Intelligence/eg-demo.png" alt="demo eg"></p>
<h3 id="数据存储">数据存储</h3>
<p>数据去冗余和存储的设计。</p>
<h3 id="威胁行为提取">威胁行为提取</h3>
<p><img src="/2022/04/27/Enabling-Efficient-Cyber-Threat-Hunting-With-Cyber-Threat-Intelligence/algo.png" alt="algo"></p>
<p>一共分为10步：</p>
<ul>
<li>分块，Line 3</li>
<li>IOC 识别和 IOC 保护， Line 5</li>
<li>分句， Line 6</li>
<li>依赖解析，Line 7</li>
<li>树注释，Line 10</li>
<li>树简化，Line 11</li>
<li>引用解决，Line14</li>
<li>IOC 扫描与合并，Line 16</li>
<li>IOC 关系提取，Line 18</li>
<li>威胁行为图构建，Line 20</li>
</ul>
<h3 id="威胁行为查询语言-Threat-Behavior-Query-Language-TBQL">威胁行为查询语言 Threat Behavior Query Language, TBQL</h3>
<p>略</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>威胁情报</tag>
        <tag>溯源分析平台</tag>
      </tags>
  </entry>
  <entry>
    <title>FedEval: A Benchmark System with a Comprehensive Evaluation Model for Federated Learning</title>
    <url>/2022/05/12/FedEval-A-Benchmark-System-with-a-Comprehensive-Evaluation-Model-for-Federated-Learning/</url>
    <content><![CDATA[<p>FedEval: A Benchmark System with a Comprehensive Evaluation Model for Federated Learning abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>因为评估矩阵的不一致和缺乏通用的平台，联邦学习领域的评估结果缺乏完整性，并且很难作比较。<br>
因此提出针对联邦学习的综合评估框架。</p>
<h2 id="Introduction">Introduction</h2>
<p>文章提出了 ACTPR 模型来对联邦学习进行系统的评估，这五个方面分别是：</p>
<ul>
<li>accuracy</li>
<li>communication</li>
<li>time consumption</li>
<li>privacy</li>
<li>robustness</li>
</ul>
<p>当然，现有的研究已经在各个方面给出了不同的评估矩阵：</p>
<p><img src="/2022/05/12/FedEval-A-Benchmark-System-with-a-Comprehensive-Evaluation-Model-for-Federated-Learning/metrics.png" alt="metrics"></p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/05/12/FedEval-A-Benchmark-System-with-a-Comprehensive-Evaluation-Model-for-Federated-Learning/arch.png" alt="arch"><br>
<img src="/2022/05/12/FedEval-A-Benchmark-System-with-a-Comprehensive-Evaluation-Model-for-Federated-Learning/comparison.png" alt="comparison"></p>
<h2 id="联邦学习框架">联邦学习框架</h2>
<p>Homepages of existing federated learning frameworks</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TFF: https://www.tensorflow.org/federated</span><br><span class="line">FATE: https://github.com/FederatedAI/FATE</span><br><span class="line">PaddleFL: https://github.com/PaddlePaddle/PaddleFL</span><br><span class="line">LEAF: https://github.com/TalwalkarLab/leaf</span><br><span class="line">PySyft: https://github.com/OpenMined/PySyft</span><br><span class="line">FedML: https://github.com/FedML-AI/FedML</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
  </entry>
  <entry>
    <title>GrAALF:Supporting Graphical Analysis of Audit Logs for Forensics</title>
    <url>/2022/04/12/GrAALF-Supporting-Graphical-Analysis-of-Audit-Logs-for-Forensics/</url>
    <content><![CDATA[<p>GrAALF:Supporting Graphical Analysis of Audit Logs for Forensics abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>系统层次的审计是系统审计中重要一环，包含很多底层信息，可以捕获恶意用户活动，但是对于一台服务器来说每小时可以生成超过250万审计日志。对如此巨大的数据进行存储和处理，将会非常消耗计算能力和时间。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/12/GrAALF-Supporting-Graphical-Analysis-of-Audit-Logs-for-Forensics/arch.png" alt="arch"><br>
因此，本文提出一个图形化系统 GrAALF 来有效加载、存储、处理、查询和展示系统事件，支撑计算机系统审计。</p>
<p>与其他相关系统，如AIQL、SAQL相比，GrAALF 提供了：</p>
<ul>
<li>更加灵活的多后台存储方案</li>
<li>易于使用的符合直觉的记录查询</li>
<li>提供了近乎实时追溯更长的系统事件序列的能力，以帮助识别和隔离</li>
<li>同样重要的，AIQL、SAQL并不开源，而GrAALF是开源的</li>
</ul>
<h2 id="系统组成">系统组成</h2>
<p>整个系统大致分为三层：</p>
<ul>
<li>日志获取层，log ingestion layer</li>
<li>日志存储层，log storage layer</li>
<li>查询与可视化层，query and visualization layer</li>
</ul>
<p>最后是系统性能分析和 case study，文章发表在 software impact （软件类？）。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源分析管理平台</tag>
      </tags>
  </entry>
  <entry>
    <title>General, Efficient, and Real-Time Data Compaction Strategy for APT Forensic Analysis</title>
    <url>/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/</url>
    <content><![CDATA[<p>General, Efficient, and Real-Time Data Compaction Strategy for APT Forensic Analysis abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>存储系统日志进行 apt 攻击审计是常见的做法，但是大量的数据不仅消耗存储空间还消耗算力。<br>
在不影响审计分析的情况下对数据进行压缩是一种做法，而且已经有几种方法被提出。但是在现实场景中，跨平台问题、大规模数据处理问题和实时性表现都无法达到可用性的要求。<br>
因此针对这些苦难提出本文方法。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/arch.png" alt="arch"></p>
<p>为了解决上述问题，对于系统级别审计日志提出了一种通用有效和具有实时性的数据压缩方法。<br>
它不涉及程序内部分析也不依赖特定操作系统类型，包括两个策略：</p>
<ul>
<li>保留全局语义（global semantics, GS）数据压缩，决定删除冗余的不影响全局依赖的事件</li>
<li>可疑语义（suspicious semantics, SS）数据压缩，</li>
</ul>
<p>如果审计分析的目的是还原攻击链，SS 将在 GS 保留下来的事件上进行上下文分析，然后删除那些与攻击无关的部分。</p>
<h2 id="背景介绍">背景介绍</h2>
<h3 id="日志追溯记录部分">日志追溯记录部分</h3>
<p><strong>ETW</strong>：Windows 下内核级别的日志溯源和记录机制。具有高可用性、高集成性和高稳定性。<br>
<strong>Audit</strong>：Linux audit 是内核中监听系统事件的一个模块，与ETW相同，audit 也可以提供内核层次的记录。</p>
<h3 id="溯源图">溯源图</h3>
<p>介绍了溯源图，并给出示例图。</p>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/eg-provenance.png" alt="eg"></p>
<h3 id="溯源分析">溯源分析</h3>
<p>溯源分析通常聚焦于两个方向：</p>
<ul>
<li>攻击的入口点</li>
<li>通过溯源图评估攻击的上海</li>
</ul>
<h3 id="保留语义的数据压缩">保留语义的数据压缩</h3>
<p>介绍了相关定义。</p>
<h2 id="方法">方法</h2>
<h3 id="GS">GS</h3>
<p>首先介绍了两个通用的例子，如下：</p>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/gs-1.png" alt="eg"><br>
<img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/gs-2.png" alt="eg"></p>
<p>主要的策略是：在源顶点语义不变的前提下，信息流对同一目标的影响是等价的，等价的偶数可以作为冗余删除。</p>
<p>具体算法如下：</p>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/gs-algo.png" alt="eg"></p>
<p>对于网络连接的特殊处理：</p>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/gs-3.png" alt="eg"><br>
<img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/gs-4.png" alt="eg"></p>
<h3 id="SS">SS</h3>
<p>主要的策略是：相同类型的事件与不同实体连接有不同的可疑等级。</p>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/ss-table.png" alt="eg"></p>
<p><img src="/2022/04/14/General-Efficient-and-Real-Time-Data-Compaction-Strategy-for-APT-Forensic-Analysis/ss-1.png" alt="eg"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>数据压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph U-Nets</title>
    <url>/2022/03/27/Graph-U-Nets/</url>
    <content><![CDATA[<p>关于图卷积神经网络池化方法论文 “Graph U-Nets” 的读书笔记。</p>
<span id="more"></span>
<h2 id="图池化">图池化</h2>
<p>图嵌入任务和图片像素级预测有着天然的对应关系，现在在图像识别领域，已经有像 U-Nets 成熟的编码解码器可以完成图像分类任务，但是在图数据上还没有相关的研究。<br>
所以提出作者提出一种新型的图像池化（gPool）方法和图像上池化（gUnpool）方法。</p>
<h2 id="gPool-编码器">gPool - 编码器</h2>
<p><img src="/2022/03/27/Graph-U-Nets/encoder.png" alt="gPool"></p>
<ol>
<li>使用可训练的投影向量 <code>p</code>，将所有的点投影到 1d 上，获得投影向量 <code>y</code></li>
<li>池化选取 <code>y</code> 中前 <code>k</code> 个</li>
<li>根据 2 中选取的 <code>k</code> 个节点，获取池化后子图所需要的特征矩阵、邻接矩阵</li>
</ol>
<h2 id="gUnpool-解码器">gUnpool - 解码器</h2>
<p><img src="/2022/03/27/Graph-U-Nets/decoder.png" alt="gPool"><br>
在进行 gPooling 操作时需要记录选择的点的位置信息并利用这些信息将点放回原始位置</p>
<h2 id="Graph-U-Nets-架构">Graph U-Nets 架构</h2>
<p><img src="/2022/03/27/Graph-U-Nets/encoder.png" alt="gPool"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>池化操作</tag>
        <tag>图卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HOLMES: Real-time APT Detection through Correlation of Suspicious Information Flows</title>
    <url>/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this paper, we present HOLMES, a system that implements a new approach to the detection of Advanced and Persistent Threats (APTs). HOLMES is inspired by several case studies of real-world APTs that highlight some common goals of APT actors. In a nutshell, HOLMES aims to produce a detection signal that indicates the presence of a coordinated set of activities that are part of an APT campaign. One of the main challenges addressed by our approach involves developing a suite of techniques that make the detection signal robust and reliable. At a high-level, the techniques we develop effectively leverage the correlation between suspicious information flows that arise during an attacker campaign. In addition to its detection capability, HOLMES is also able to generate a high-level graph that summarizes the attacker’s actions in real-time. This graph can be used by an analyst for an effective cyber response. An evaluation of our approach against some real-world APTs indicates that HOLMES can detect APT campaigns with high precision and low false alarm rate. The compact high-level graphs produced by HOLMES effectively summarizes an ongoing attack campaign and can assist real-time cyber-response operations.</span><br></pre></td></tr></table></figure>
<p>abstract中主要说明文章：</p>
<ul>
<li><code>HOLMES</code> 目标是在检测到当前活动与 APT 活动的部分攻击一致时触发报警信号。挑战之一是使得报警信号可靠、值得信赖。</li>
<li>在高层次，<code>HOLMES</code> 有效地利用了攻击者在活动期间可疑信息流之间的关联。</li>
<li>除了检测能力，<code>HOLMES</code> 还能够生成高层级的实时攻击图。该攻击图可以被分析专家用来参考做出有效的攻击反映。</li>
</ul>
<p>另外，文章是发表在 <code>2019 IEEE Symposium on Security and Privacy</code> 上 的。</p>
<span id="more"></span>
<h2 id="文中使用的案例">文中使用的案例</h2>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/example.png" alt="案例"></p>
<h2 id="方法概览">方法概览</h2>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/kill_chain.png" alt="攻击链"></p>
<p>方法的核心还是即使不同攻击存在不同技术细节，但是在高层次，APT 的战术意图、目的是符合 APT 杀伤链的。APT 杀伤链步骤如上图。</p>
<p>大多数 APT 攻击是包含该攻击链的部分或者全部步骤的，而且这些步骤是因果相关的，这种联系是判断攻击正在进行的重要标志。</p>
<p>对于同一个战术阶段，攻击者使用的具体的技术可能是不同的，例如初始访问可能是鱼叉攻击，也可能是恶意脚本下载等等。尽管具体执行的技术可能不同，在战术层次，他们还是会相互依赖的，例如泄露就需要先进行敏感信息收集。因此技术之间必定存在关联关系或者数据流的联系。</p>
<p>因此研究的主要问题是能够基于 APT 战术和数据流来进行检测。解决这个问题的重要挑战是如何将审计日志和攻击链联系起来。</p>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/mapping.png" alt="映射"></p>
<p>为实现底层的审计日志到高层的 APT 战术阶段之间的映射，添加了中间层 <code>TTPs &amp; HSG</code> 实现。</p>
<p>要实现该校过有几个技术难点：</p>
<ul>
<li>有效地匹配审计日志中的事件到 TTP，</li>
<li>在攻击步骤中检测关联性</li>
<li>降低假阳性</li>
</ul>
<h2 id="系统设计">系统设计</h2>
<h3 id="数据收集和表示">数据收集和表示</h3>
<p>系统接受各种系统产生的审计日志格式，如 Linux 的 auditd、BSD 的 dtrace 和 windows 的 ETW。</p>
<p>将这些数据表示为一张起源图，图中的点包括对象和子对象，对象包括文件、管道和 socket 连接，子对象包括进程。边表示实体之间的依赖关系，使用事件名称作为关系的注释。</p>
<p>需要注意的是，在这张图中实体是存在版本的，比如给一个节点添加父节点改变了该节点的依赖，这就需要创建一个新的版本。版本控制实现了优化，可以在不改变取证分析结果的情况下删除审计日志中的大部分事件。此外，版本控制的图是无环图，这可以简化许多图算法。</p>
<p>另一个点是，这张图是存在内存中的，之前的作者之前工作中，实现了一个将起源图存储在内存中的算法，一个事件存在内存中大概占用 5 字节的空间。这个算法保证了日志获取和图构建的实时性。基于规则的查询分析将会在这张图上进行，查询那些与 TTP 规则符合的行为。</p>
<h3 id="TTP-规则">TTP 规则</h3>
<p>TTP 规则提供了底层日志事件到高层 APT 步骤之间的对应规则。这将是论文中方法的关键点，为此，使用了三个方法来确保方案的有效性和准确性。</p>
<p>要想将日志数据映射到基于 TTP 的中间层，需要依赖两个技术：</p>
<ul>
<li>以图的形式表示安全事件</li>
<li>与 TTP 相关的信息流依赖关系</li>
</ul>
<p>在这个框架中，作者发现如果使用带前提条件的实体的话，大多数 TTP 可以使用单个事件来建模。具体案例如下图。</p>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/ttp_example.png" alt="案例"></p>
<p>通过引入前提条件，也降低了模型的假阳性，提高了模型的准确率。</p>
<h3 id="HSG-构建">HSG 构建</h3>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/hsg_graph.png" alt="HSG 图"></p>
<p>如上图，就是对前文中提出案例的 HSG 构建，HSG(High-Level Scenario Graph，高层次场景图)。</p>
<p>该图的构建是基于前提条件的，如果前提条件满足并且 TTP 匹配的话，该 TTP 将会被添加到图中。这大大减少了图中的 TTP 数量，使得在不影响实时性能的条件下可以使用较为复杂的算法。</p>
<h3 id="避免虚假依赖">避免虚假依赖</h3>
<p>正常的进程可能会访问被恶意活动影响的日志，在起源图（provenance graph）中会给该正常进程添加指向恶意活动的依赖。这可能会导致依赖爆炸，大量的正常活动被标记为可疑活动，导致最终在 HSG 中显示了大量的正常活动。</p>
<p>对于这个问题，作者使用不同的优先级来标记依赖，具体为强依赖（stronger）和弱依赖（weaker）。如果一个进程为恶意进程的子进程或者被恶意进程直接修改，则为强依赖。强依赖在分系统会被着重分析，而弱依赖则会被弱化。</p>
<p>首先定义了 <code>AC_min(f)</code> 表示攻击者完全控制该数据流需要攻破的父节点数量，并且定义了 <code>path_factor(N1, N2)</code>，代表攻击者对从 N1 到 N2 数据流的控制程度。在文章第五节中提出了一个计算 <code>path_factor</code> 的有效算法，并且在实验中证明，此处基于强、弱依赖的方法可以有效缓解依赖爆炸的问题。</p>
<h3 id="去噪">去噪</h3>
<p>一个严重的问题是正常活动可能会匹配 TTP 规则，例如一些长时间活动的程序，浏览器、web 服务器和 SSH等。</p>
<p>结合基于训练数据的降噪规则，提出了两个概念，来解决此问题：</p>
<ul>
<li>正常活动的前提条件匹配</li>
<li>正常数据流量</li>
</ul>
<p>也就是：</p>
<ul>
<li>
<p>对于每个进程，我们的系统学习在良性环境中运行系统时频繁触发的先决条件。在运行时，当触发的 TTP 的先决条件与培训期间遇到的先决条件匹配时，我们将忽略匹配。</p>
</li>
<li>
<p>基于良性先决条件的规则会产生误判，例如，即使没有任何攻击 nginx 也会在开始时读取 <code>/etc/passwd</code>，然而如果将所有对 <code>/etc/passwd</code> 访问的 nginx 列入白名单则会出现误判。</p>
</li>
<li>
<p>为了解决此问题，在学习的过程中加入了对数据流的量的学习，例如，nginx 对 <code>etc/passwd</code> 访问时流向 nginx 的数据量等于该文件大小，如果有大量的数据流在访问是从 <code>etc/passwd</code> 流向 nginx，则说明出现了攻击。为了学习该特征，作者在良性环境中观察了一段时间的进程-文件对和进程-套接字对。</p>
</li>
</ul>
<h3 id="信号关联和检测">信号关联和检测</h3>
<p>给出一组 HSG，如何高准确率地检测出攻击的组成部分呢？为了解决这个问题，给每一个 HSG 分配了一个严重程度。这个过程通过两个步骤来完成：</p>
<ol>
<li>
<p>威胁元组（Threat Tuples）</p>
<p>通过与 HSG 相应的威胁元组来表示攻击者在攻击活动中的进展，对于每个 HSG 威胁元组是一个七元组 <code>S1, s2, s3, s4, s5, s6, s7</code>，如本文方法概览中的 APT 阶段，每一个 <code>s</code> 代表其对应 APT 阶段的严重程度。</p>
<p>同一个阶段可能有多个候选者，在这里选择最高严重程度的候选者来表示该阶段，例如本文案例的严重程度为 <code>&lt;M,L,H,H,−,H,M&gt;</code>。</p>
</li>
<li>
<p>HSG 排名和优先级</p>
<p>为了对 HSG 进行排名，首先把威胁元组转化为数值。通过下图，将严重等级转化为数值。</p>
</li>
</ol>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/severity.png" alt="严重程度映射"></p>
<p>​	然后根据威胁元组计算得出一个 HSG 综合得分，此得分的计算基于两个原则：灵活性和定制性；APT 步骤的相关性反映在步骤展开时分数的放大率中。在训练集上进行了一些实验发现，加权乘积的效果最好。</p>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/formula.png" alt="计算公式"></p>
<p>其中，<code>n</code> 代表 APT 阶段，<code>wi, Si</code> 分别代表权值和威胁元组中 APT 阶段的数值， <code>threshold</code> 为检测阙值，当某一阶段无 TTP 发生时，<code>Si</code> 取 1.</p>
<h2 id="实施">实施</h2>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/architecture.png" alt="架构图"></p>
<h3 id="起源图构建的流消耗">起源图构建的流消耗</h3>
<p>上图展示了 HOLMES 的架构，为了实现平台的独立性，来自不同系统的审计日志将会首先被转化成一种通用的数据表达格式（Common Data Representation，CDR）。为了能够对该数据进行流处理，审计日志将会被发不到流处理服务器 <code>Kafka</code> 上，实时分析和检测将会在流服务器上进行。</p>
<p>作者采用了之前的工作，SLEUTH 系统进行流消耗的管理、因果跟踪和起源图构建。</p>
<p><a href>Md Nahid Hossain, Sadegh M. Milajerdi, Junao Wang, Birhanu Eshete, Rigel Gjomemo, R. Sekar, Scott Stoller, and V.N. Venkatakrishnan. SLEUTH: Real-time attack scenario reconstruction from COTS audit data. In 26th USENIX Security Symposium (USENIX Security 17), pages 487–504, Vancouver, BC, 2017. USENIX Association</a></p>
<h3 id="策略匹配引擎和-HSG-图的构建">策略匹配引擎和 HSG 图的构建</h3>
<p>策略引擎使用 TTP 规则作为输入，在起源图上进行匹配操作。下图中是在现在的实现中一些有代表性的 TTP 规则。</p>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/TTP_rule.png" alt="TTP 规则"></p>
<p>匹配策略引擎将会逐条匹配规则库中的每一条规则和他们的先决条件。</p>
<p>此处任务有一个特别具有挑战性的部分，就是检查每一个 TTP 规则有关已经匹配的 TTP 和路径因子的先决条件。先前匹配的 TTP 可能位于图形的较远区域，路径因子值可能必须便利长路径。</p>
<p>注意到在先前的取证工作中，有一个常见的做法是从 TTP 匹配点进行反响跟踪，以达到最初的攻击点。但是在实时检测中，这是一种计算成本很高的方法，因为起源图中可能包含数百万个事件。</p>
<p>为了不适用回溯解决这个问题，采用了增量匹配的方法，存储以前的计算结果，并沿着图形匹配和传播指向这些结果的指针。</p>
<p>当一个特定的 TTP（也可能是在其他的 TTP 规则匹配中作为先决条件出现）匹配时，我们在 HSG 中创建相应的节点和指向该节点的指针。路径因子 <code>path_factor</code> 的计算方法也是类似的，假设匹配的 TTP 表示为 HSG 中的一个节点，为起源图的节点递增计算路径因子值，这些节点依赖于匹配的 TTP 的实体。</p>
<p>这个基于指针的层关联方法有一个可见的瓶颈是随着实践推移，空间开销和复杂度将不断增加。</p>
<p>但是在实验中，作者观察到大量的实体指向同一组 TTP，这种现象实际上是进程书到所有子进程传播的结果。事实上，随着分析的进行，添加新指针的情况很少见。一般来说，关键是要维护一个中间对象，该对象将起源图中的实体映射到 HSG 的 TTP 上。因此，起源图中的每个实体只有一个指向中间映射器的指针，而映射器包含一组指针。</p>
<h3 id="噪声过滤和检测引擎">噪声过滤和检测引擎</h3>
<p>噪声过滤引擎识别良性的 TTP 匹配，以便将他们从 HSG 中排除。它将在良性环境中学习正常行为作为模型的输入。此模型包含在良性环境中匹配的 TTP 的映射以及这些程序从系统对象读取或写入的字节数的阙值。如果传输的字节总数低于良性阙值，则过滤掉与匹配的 TTP 对应的节点，否则将对应的节点添加到 HSG 中。</p>
<p>最后，检测引擎计算不同 HSG 的加权和，并在该值超过检测阙值时发出警报。</p>
<h2 id="效果">效果</h2>
<p><img src="/2021/08/14/HOLMES-Real-time-APT-Detection-through-Correlation-of-Suspicious-Information-Flows/results.png" alt="TTP 规则"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
        <tag>APT</tag>
        <tag>TTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HOW POWERFUL ARE GRAPH NEURAL NETWORKS?</title>
    <url>/2022/08/04/HOW-POWERFUL-ARE-GRAPH-NEURAL-NETWORKS/</url>
    <content><![CDATA[<p>HOW POWERFUL ARE GRAPH NEURAL NETWORKS? abstract。</p>
<span id="more"></span>
<h2 id="Summary">Summary</h2>
<p>GNN 作为一种有效的图表示学习框架近年来越来越受到人们的重视，通常来说，GNN 通过在相邻节点间迭代传播和聚合特征。许多 GNN 的变体也获得了 sota 结果，不论是在节点分类任务还是图分类任务中。</p>
<p>但是，尽管 GNNs 革命化地改变了图表示学习领域，但是对齐表示特征和局限性的理解仍然很有限。</p>
<p>因此，我们提出了一种理论框架，来分析 GNNs 学习不同图结构的能力。</p>
<p>主要的贡献如下：</p>
<ul>
<li>展示了 GNNs 在区分图结构方面极限性能是能够与 WL test 媲美的（GNNs are <strong>at most</strong> as powerful the WL test）</li>
<li>测试并获得了 GNN 性能接近 WL test 时，GNN 在 邻居节点聚合 和 图读出 操作函数的条件</li>
<li>发现流行的 GNN 变体，如 GCN/GraphSAGE 等，不能够区分简单的图结构，并且精确地总结了他们能够区分的图结构</li>
<li>提出了一种简单的神经网络结构，图同构网络（Graph Isomorphism Network, GIN），并且测试表明图结构的分类和区别能力与 WL test 相同</li>
</ul>
<h2 id="Less-Powerful-But-Still-Interesting-GNNs">Less Powerful But Still Interesting GNNs</h2>
<ul>
<li>单层感知机无法很好地学习图结构，特别是在图分类任务，通常会欠拟合</li>
<li><code>Mean</code> 和 <code>Max-Pooling</code> 不擅长学习的结构，如下图3所示</li>
<li><code>Mean</code> 聚合器主要学习分布特征</li>
<li><code>Max-Pooling</code> 主要学习代表特征或者缩略图特征，不适合用于区分具体结构和分布特征</li>
<li></li>
</ul>
<p><img src="/2022/08/04/HOW-POWERFUL-ARE-GRAPH-NEURAL-NETWORKS/fig-3.png" alt="structure"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>Graph Classification</tag>
      </tags>
  </entry>
  <entry>
    <title>High Accuracy Attack Provenance via Binary-based Execution Partition</title>
    <url>/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/</url>
    <content><![CDATA[<p>High Accuracy Attack Provenance via Binary-based Execution Partition abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>了解可疑事件的溯源图是非常重要的方面，因为其揭露了攻击的根本原因和后果。通常通过分析审计日志来完成，但是随着长时间的运行，大量的日志会导致依赖爆炸使得攻击调查几乎难以完成。<br>
因此本文提出一种方法来解决该问题。</p>
<h2 id="方法">方法</h2>
<p>作者观察到，通过监视程序事件处理循环的执行，可以将长时间的执行划分为单独的单元，每次迭代对应于独立的输入/请求的处理。</p>
<p>因此对二进制应用进行逆向工程，获取程序事件处理循环，还对可能导致单元之间工作流的指令进行逆向工程，检测这样的工作流程对于揭示单元之间的因果关系至关重要。</p>
<p>然后对单元边界和单元依赖执行选择性地进行了日志记录。</p>
<p>基于上述方法，提出了一种用于二进制程序的高效、无依赖爆炸日志记录的新方案，称为 BEEP。<br>
BEEP 是一种新的、更细粒度的主题类型，称为单元 unit，具体来说，单元是处理特定对象的过程执行段，一个进程被分割成多个单元，BEEP 还设计识别一小组关键的内存依赖关系，这些依赖关系表示单元之间的高级因果关系.</p>
<h2 id="main-contribution">main contribution</h2>
<ul>
<li>粒度更细，一个进程可以分为多个单元 unit</li>
<li>证明了基于进程的日志记录会导致依赖爆炸，并且在许多程序中确认了单元的存在</li>
<li>提出了新技术来逆向关键循环，其循环迭代表示单元的自然边界，以及诱导单元之间因果工作流的内存访问指令</li>
<li>提出了一种日志分析算法，该算法可以对系统日志和我们的日志进行内聚推理</li>
</ul>
<h2 id="实现">实现</h2>
<p>与现有方法的比较：</p>
<p><img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/comparasion.png" alt="eg"></p>
<p>具体溯源图例子如下：</p>
<p><img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/log-1.png" alt="eg"></p>
<p>在源码中的 unit loop：</p>
<p><img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/eg-loop.png" alt="eg"></p>
<p><img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/eg-lia.png" alt="eg"><br>
<img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/eg-2layers.png" alt="eg"></p>
<p>逆向工程算法：</p>
<p><img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/algo.png" alt="eg"><br>
<img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/eg-2.png" alt="eg"></p>
<p>日志分析算法：</p>
<p><img src="/2022/04/15/High-Accuracy-Attack-Provenance-via-Binary-based-Execution-Partition/algo-analysis.png" alt="eg"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Jangseung: A Guardian for Machine Learning Algorithms to Protect Against Poisoning Attacks</title>
    <url>/2022/04/22/Jangseung-A-Guardian-for-Machine-Learning-Algorithms-to-Protect-Against-Poisoning-Attacks/</url>
    <content><![CDATA[<p>Jangseung: A Guardian for Machine Learning Algorithms to Protect Against Poisoning Attacks abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>很多智能城市应用依赖机器学习，然而对抗扰动可以嵌入到训练数据中导致模型返回错误的结果。<br>
Jangseung是一个预处理器，可以在不影响准确性的情况下限制中毒攻击的影响。创建 Jangseung 是为了利用异常检测算法来保护支持向量机免受中毒数据影响。</p>
<h2 id="思路与方法">思路与方法</h2>
<h3 id="数据扰动">数据扰动</h3>
<p>通过添加数据扰动来评估本文提出方法的效果，添加数据扰动的方法是Munoz-Gonzalez等人提出的。</p>
<h3 id="Janseung-防护">Janseung 防护</h3>
<p>两个空数组被初始化，一个用来跟踪 受保护的支持向量机 guard SVM，一个用来跟踪 不受保护的支持向量机 unguard SVM.</p>
<p>两个独立的森林针对对应的标签(一个正样本AD+，一个负样本AD-)来训练。</p>
<p>然后根据两个模型的值来进行异常值检测，对于新的输入，先通过异常值检测器获得一个预测，如果预测为负样本则送入正样本训练的SVM获得一个pass值，如果预测为正阳被则送入负样本训练的SVM获得一个pass值。</p>
<p>根据pass值决定是否需要过滤数据。</p>
<p><img src="/2022/04/22/Jangseung-A-Guardian-for-Machine-Learning-Algorithms-to-Protect-Against-Poisoning-Attacks/algo.png" alt="algo"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>异常值检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Just How Toxic is Data Poisoning? A Unified Benchmark for Backdoor and Data Poisoning Attacks</title>
    <url>/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/</url>
    <content><![CDATA[<p>Just How Toxic is Data Poisoning? A Unified Benchmark for Backdoor and Data Poisoning Attacks abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>提出一个用于数据投毒和后门攻击的标准化测试床。</p>
<p>当前的数据投毒攻击大致可以被分为两类：</p>
<ul>
<li>后门攻击，嵌入触发器</li>
<li>无触发器攻击</li>
</ul>
<p>通过观察发现现有的投毒攻击有以下问题：</p>
<ul>
<li>数据投毒针对特定框架和训练协议，很难适应现实环境中的场景</li>
<li>攻击成功很大程度上取决于数据集的大小，与所占百分比无关</li>
<li>干净标签攻击并非如其所述人类无法分辨</li>
</ul>
<p>本文提出的测试框架可以在现在流行的框架上测试攻击的有效性，针对的攻击是可以导致指定样本误分类的攻击。</p>
<p>后门攻击和无触发器的攻击有以下几个重要的不同：</p>
<ul>
<li>后门攻击在预测阶段通过添加一个触发器来改变样本分类</li>
<li>后门攻击可以使得任意分类的样本被误分类到指定类别，通过特定触发器</li>
<li>无触发器攻击则是误分类特定样本</li>
<li>当然无触发器攻击也可分类一组图片，为了保持一致这里进针对单张图片的无触发器攻击和整图的后门攻击</li>
</ul>
<h2 id="投毒攻击">投毒攻击</h2>
<h3 id="Feature-Collision（FC）">Feature Collision（FC）</h3>
<p>FC 投毒是在图像上添加微小扰动使得图像在特征空间内十分接近目标，使得分类错误。<br>
<img src="/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/fc.png" alt="feature collision"></p>
<h3 id="Convex-Polytope（CP）">Convex Polytope（CP）</h3>
<p>CP 攻击通过解决以下优化问题（Zhu et al., 2019）来制造污染，使目标的特征表示是污染特征表示的凸组合。<br>
<img src="/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/cp.png" alt="convex polytope"></p>
<h3 id="Clean-Label-Backdoor（CLBD）">Clean Label Backdoor（CLBD）</h3>
<p>这种后门攻击需要首先计算一个基础图像的对抗扰动：<br>
<img src="/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/clbd.png" alt="clean label backdoor"></p>
<h3 id="Hidden-Trigger-Backdoor（HTBD）">Hidden Trigger Backdoor（HTBD）</h3>
<p>和 FC 投毒相似的后门攻击，在特征空间中与目标接近。<br>
<img src="/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/htbd.png" alt="Hidden Trigger Backdoor"></p>
<h2 id="为何需要一个测试框架">为何需要一个测试框架</h2>
<p>对于上述两类投毒工具，他们有不同的实验与测试设置，从模型架构到目标/基础类。而且实验也缺乏广泛的测试，有时对所有实验使用一个模型初始化或者针对一个图像目标进行测试。<br>
并且作者发现，不同的实验设置对结果有着直接的重要的影响，为了全面地研究投毒攻击，我们采取了采样的方法。<br>
主要原因总结如下：</p>
<ul>
<li>实验设置不同，且未经过广泛全面的测试</li>
<li>需要建立一个测试评估基线</li>
<li>不同工作的测试评估基线也不同</li>
</ul>
<h2 id="探究投毒攻击的真实严重性">探究投毒攻击的真实严重性</h2>
<p>研究不同实验设置下的不同点，以及由其导致的误导性比较，以下是具体研究方法：</p>
<h3 id="Training-with-SGD-and-data-augmentation">Training with SGD and data augmentation</h3>
<p>在FC与CP对应的工作中，两类攻击仅被在ADAM优化器上进行实验，然而现在 cnn 主流的优化器是 SGD，有趣的是 SGD 明显更难被攻击，导致这些攻击在实际设置中并不非常有效。<br>
除此之外，还发现很多实验中都没做数据增强，深度学习框架中实现的数据增强方法也可以大幅降低投毒攻击的成功率。</p>
<h3 id="Victim-architecture-matters">Victim architecture matters</h3>
<p>不同攻击的测试框架不同，消融实验表明投毒攻击的成功率很大程度上依赖所选的框架。</p>
<h3 id="“Clean”-attacks-are-sometimes-dirty">“Clean” attacks are sometimes dirty</h3>
<p>现有研究中提到的干净标签攻击可能并没有达到其所述的人眼无法识别的程度。<br>
在很多环境中，避免被自动系统检测要比被人眼识别更为重要。避免被检测或者防御的自适应攻击是一个新的研究领域。</p>
<p>对于攻击施加标准约束的情况下，攻击的有效性都会下降，因此在对齐进行公平比较的时候，对于投毒样本添加一个标准化的限制约束是需要的。</p>
<h3 id="Proper-transfer-learning-may-be-less-vulnerable">Proper transfer learning may be less vulnerable</h3>
<p>如图中所示，当对预训练数据集与训练数据集不相交的数据进行迁移学习时，除了cp之外的所有攻击都显示出更差的性能。因此为迁移学习设计的攻击可能无法像他们所宣传的那样在现实的迁移学习环境中发挥作用。<br>
<img src="/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/fig3.png" alt="fragility of poisoning methods to experimental design"></p>
<h3 id="Performance-is-not-invariant-to-dataset-size">Performance is not invariant to dataset size</h3>
<p>现有的工作有一个标准是攻击者改变的数据占数据集的百分比。这就引出了一个问题，单独的百分比是否足以表征预算，还有就是数据集的实际大小是否重要。<br>
作者发现训练集中图像数量对攻击性能有很大影响，并且fc和cp的性能曲线相交。经过实验表明，不能仅通过固定数据集中投毒数据的百分比来比较不同大小的数据集上的攻击。</p>
<h3 id="Black-box-performance-is-low">Black-box performance is low</h3>
<p>黑盒测试最为一项重要的测试指标，多个攻击在最初的实验中都没有进行黑盒测试，他们的黑盒测试性能都很低。</p>
<h3 id="Small-sample-sizes-and-non-random-targets">Small sample sizes and non-random targets.</h3>
<p>除了实验设置的不一致之外，现有的数据投毒工作只在特定的目标/基类对上进行测试。比如 FC 攻击大量地使用青蛙作为基类，飞机作为目标类。作者发现：</p>
<ul>
<li>攻击成功率高度依赖与类对</li>
<li>随机类对抽样下攻击成功率发生显著变化</li>
</ul>
<p>此外该类攻击通常只用很少的实验来验证，因为这些方法的计算成本很高。并且这些实验每次都在相同的精确预训练模型上进行。</p>
<h3 id="Attacks-are-highly-specific-to-the-target-image">Attacks are highly specific to the target image</h3>
<p>无触发攻击高度针对特定目标图像，而物理对象在不同的现实环境下可能会出现不同的外观。通过对图像进行处理可以提高对抗投毒攻击的鲁棒性，并且确切图像未知时，这些攻击成功率很低。</p>
<p>在使用简单反转对目标图像进行处理时，FC的成功率只有 7%。</p>
<h3 id="Backdoor-success-depends-on-patch-size">Backdoor success depends on patch size</h3>
<p>后门的成功率取决于补丁的大小，后门攻击向目标图像添加补丁以触发错误分类。为了了解不同的扰动大小对于成功率的影响，我们发现补丁大小和攻击成功率有着很大的关系，因此必须使用相同的补丁大小来比较后门攻击。</p>
<h2 id="数据集操纵的评估矩阵">数据集操纵的评估矩阵</h2>
<p>作者提出了新的基准来衡量后门和无触发数据中投毒攻击的有效性。我们标准化了及真的数据集和问题设置，对于基类和目标类的选择做了设置，对投毒区域做了限制等等。<br>
并且考虑了两种不同的训练模式：</p>
<ul>
<li>迁移学习</li>
<li>从零开始训练</li>
</ul>
<h3 id="CIFAR-10-测试集">CIFAR-10 测试集</h3>
<p>模型在 CIFAR-100 上进行了预训练，选择了每个类别的前250个图像，其中总共有25个污染示例，并且使用了迁移学习，因为在只有2500个样本的图像数据集上从头开始训练会产生较差的泛化能力。</p>
<h3 id="TinyImageNet-测试集">TinyImageNet 测试集</h3>
<p>在该数据集上的前100个类别上预训练了 VGG16、ResNet-34、MobileNetV2 模型。在从零开始的训练中，该数据集中包含250污染图像。</p>
<p><img src="/2022/06/03/Just-How-Toxic-is-Data-Poisoning-A-Unified-Benchmark-for-Backdoor-and-Data-Poisoning-Attacks/performance.png" alt="performance"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Data Poisoning</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel-Supported Cost-Effective Audit Logging for Causality Tracking</title>
    <url>/2022/04/27/Kernel-Supported-Cost-Effective-Audit-Logging-for-Causality-Tracking/</url>
    <content><![CDATA[<p>Kernel-Supported Cost-Effective Audit Logging for Causality Tracking abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>Linux 的 Audit 审计日志系统是常用的因果溯源分析系统，然而该系统存在性能问题。系统长时间运行和冗余日志占用了大量的存储空间，我们对此进行了详细的分析。<br>
为了克服这个问题，我们提出了内核内的基于缓存的在线日志精简算法来提高 Audit 系统的记录性能。</p>
<h2 id="Architecture">Architecture</h2>
<p>Audit 审计系统的架构：</p>
<p><img src="/2022/04/27/Kernel-Supported-Cost-Effective-Audit-Logging-for-Causality-Tracking/arch.png" alt="Audit arch"></p>
<p>KCAL 的架构：</p>
<p><img src="/2022/04/27/Kernel-Supported-Cost-Effective-Audit-Logging-for-Causality-Tracking/arch-kcal.png" alt="kcal arch"></p>
<p>KCAL 的细节结构：</p>
<p><img src="/2022/04/27/Kernel-Supported-Cost-Effective-Audit-Logging-for-Causality-Tracking/overview.png" alt="overview"></p>
<h2 id="架构工作流">架构工作流</h2>
<h4 id="task-struce-数据结构修改">task_struce 数据结构修改</h4>
<p>此处修改包括：</p>
<ul>
<li>unit dependency cache, box 2</li>
<li>read set, unit dependency cache 用来存储当前实体和依赖关系, box 4</li>
<li>process-level dependency cache, box 3</li>
<li>dependencies, box 5</li>
</ul>
<h4 id="File-数据结构修改">File 数据结构修改</h4>
<p>此处修改包括：</p>
<ul>
<li>syscal events with timestamp, box 8, 可以取出冗余事件</li>
<li>automation used to detect if the resource is temporary, box 9</li>
<li>states and transitions, box 10</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源采集工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Logging to the Danger Zone: Race Condition Attacks and Defenses on System Audit Frameworks</title>
    <url>/2022/04/27/Logging-to-the-Danger-Zone-Race-Condition-Attacks-and-Defenses-on-System-Audit-Frameworks/</url>
    <content><![CDATA[<p>Logging to the Danger Zone: Race Condition Attacks and Defenses on System Audit Frameworks abstract。</p>
<span id="more"></span>
<h2 id="Workflow">Workflow</h2>
<p>如果用系统日志来辅助安全调查，其中一个前提是，该日志系统不能遭受攻击者攻击。<br>
在这项工作中，我们通过展示和验证审计框架完整性的竞争条件攻击来挑战这一假设。<br>
攻击利用了 I/O 和 IPC 活动的内在异步特性，表明攻击者可以在时间发生之后，在提交到日志系统之前，从系统缓冲区中获取修改有关其入侵的事件，从而绕过现有的保护措施。<br>
通过引入 KennyLoggings 来防御我们的攻击，这是第一个满足同步完整性的基于内核的放篡改日志系统，这意味着他保证了事件发生时的放篡改问题。</p>
<p><img src="/2022/04/27/Logging-to-the-Danger-Zone-Race-Condition-Attacks-and-Defenses-on-System-Audit-Frameworks/workflow.png" alt="workflow"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击溯源系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MCI: Modeling-based Causality Inference in Audit Logging for Attack Investigation</title>
    <url>/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/</url>
    <content><![CDATA[<p>MCI: Modeling-based Causality Inference in Audit Logging for Attack Investigation abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/arch.png" alt="arch"></p>
<p>在本文中，开发了一个基于因果推理的模型来进行审计日志分析，并且该方法不需要任何应用指令或者内核修改。<br>
它利用了最近的动态分析和双重执行（LDX），可以推断系统调用之间精确因果关系，但不幸的是需要加倍的消耗资源，例如cpu时间和内存的消耗。<br>
对于每个应用来说，我们使用LDX获得一组原始操作的精确的因果模型。每个模型都是一系列具有相互依赖关系的系统调用，其中一些是由内存操作引起的，因此隐含在系统调用级别，这些模型由支持各种复杂性的语言描述，例如常规的、上下文无关的，甚至上下文敏感的。在生产运行中，部署了一个新的解析器来解析审计日志以对实例进行建模，从而得出因果关系。</p>
<p><img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/motivation.png" alt="motivation"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/eg.png" alt="example"></p>
<h3 id="model-construction">model construction</h3>
<p><img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/mc-0.png" alt="mc-0"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/mc-1.png" alt="mc-0"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/mc-2.png" alt="mc-0"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/mc-3.png" alt="mc-0"></p>
<h3 id="trace-parsing-with-models">trace parsing with models</h3>
<p><img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/sp-0.png" alt="sp"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/sp-1.png" alt="sp"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/algo-1.png" alt="algo"><br>
<img src="/2022/04/17/MCI-Modeling-based-Causality-Inference-in-Audit-Logging-for-Attack-Investigation/algo-2.png" alt="algo"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>LOF: Identifying Density-Based Local Outliers</title>
    <url>/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/</url>
    <content><![CDATA[<p>LOF: Identifying Density-Based Local Outliers abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>之前的工作大多数研究将异常值视为二元属性，数据中的对象要么是异常值要么不是，在应用程序中情况更为复杂，并且为每一个对象分配一个异常值更有意义。</p>
<p>除此之外还有大量关于聚类算法的工作，从聚类算法的角度来看，离群值是不位于数据集聚类中的对象，通常称为噪声。聚类算法产生的噪声高度依赖于特定算法及其聚类参数。通常这些算法从全局的角度考虑异常值，这将会导致一些缺点。<br>
本文针对此类缺点，提出 LOF 用于表征局部异常值。</p>
<h2 id="Related-Work">Related Work</h2>
<p>以往关于离群点检测的研究大多是在统计学领域进行的，这些研究可以大致分为两类：</p>
<ul>
<li>基于分布的，问题是单变量和数据集潜在分布未知</li>
<li>基于深度的，将数据点表示到 k 维空间，问题是在 k &gt;= 4 时效率会降低</li>
</ul>
<p>根据直觉的异常值定义：<br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-1.png" alt="defination of outlier"></p>
<p>该定义中定义异常值为离群以至于怀疑是其他机制产生的。<br>
Knorr 和 Ng 在对该定义进行了形式化：</p>
<p><img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-2.png" alt="defination of outlier formalization"><br>
当然以上定义是在全局层面，如下图所示，现实数据集中也存在着局部的异常值：<br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/fig-1.png" alt="outliers"></p>
<p>作者针对全局异常值定义的确定提出了局部异常值定义，关键点在于离群不是一个二元属性，并为每个对象制定了一个离群因子：</p>
<p><img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/fig-2.png" alt="outliers"><br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-3.png" alt="defination of outlier"><br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-4.png" alt="defination of outlier"><br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-5.png" alt="defination of outlier"><br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-6.png" alt="defination of outlier"><br>
<img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/def-7.png" alt="defination of outlier"></p>
<h2 id="LOF-的属性">LOF 的属性</h2>
<ul>
<li>非离群值的LOF接近于1</li>
<li>该LOF存在通用的上下界</li>
<li>上下界是具有紧密性的，表现在非离群值趋近于1，离群值不接近1，但是其预测的LOF界限是严格的</li>
<li>使用多集群重合的直接邻域边界，在上下边界失效时</li>
</ul>
<h2 id="讨论MinPts对LOF的影响">讨论MinPts对LOF的影响</h2>
<p>略</p>
<h2 id="实验效果">实验效果</h2>
<p><img src="/2022/06/09/LOF-Identifying-Density-Based-Local-Outliers/eg.png" alt="outliers"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>异常值检测</tag>
      </tags>
  </entry>
  <entry>
    <title>MPI: Multiple Perspective Attack Investigation with Semantics Aware Execution Partitioning</title>
    <url>/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/</url>
    <content><![CDATA[<p>MPI: Multiple Perspective Attack Investigation with Semantics Aware Execution Partitioning abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>传统审计技术产生了大量的不准确的因果图，为了克服该缺点，研究人员开始将图按照执行划分来提高分析粒度和准确度。但是这些技术依赖地层次的编程范式来进行执行划分，这通常会使得低层级的图存在大量冗余。<br>
这不仅会导致溯源图存储的空间效率低下，还会导致溯源图可理解性降低，并且这些技术要求通过训练来检测不同分区之间的低层的依赖关系。<br>
在训练中获得较好的完整性和准确率是很难的。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/arch.png" alt="arch"></p>
<p>提出了一个可以感知程序注解和命令语义的技术，来进行基于特定程序的分区执行。该方法避免了训练，而能够生成具有丰富语义信息的执行分区，并且提供了攻击的多个视角。</p>
<p>*MPI is short for “Multiple Perspective attack Investigation”</p>
<h2 id="思路与方法">思路与方法</h2>
<p>本文的指导思想就是将高层级的任务转化为数据结构。<br>
MPI 允许用户注释与此类任务相对应的数据结构，然后，它利用程序分析来检测一组指示任务切换和继承的位置，以实现执行分区。</p>
<p>如架构图所示，首先用户通过 miner 的辅助来给源代码进行注释添加，添加的注释指示跟数据结构相关联的单元。</p>
<p>其次，分析模块被做成了 LLVM 通道，接受注释并分析程序以确定要检测的位置，例如表示单元边界的数据结构访问。</p>
<p><img src="/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/source-annotation.png" alt="source-annotation"></p>
<p><img src="/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/simplified-firefox.png" alt="simplified model"><br>
<img src="/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/firefox-annotation.png" alt="firefox annotation"><br>
<img src="/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/firefox-thread.png" alt="firefox thread"></p>
<p><img src="/2022/04/17/MPI-Multiple-Perspective-Attack-Investigation-with-Semantics-Aware-Execution-Partitioning/annotation-miner.png" alt="annotation miner"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Needle in a Haystack: Attack Detection from Large-Scale System Audit</title>
    <url>/2022/06/16/Needle-in-a-Haystack-Attack-Detection-from-Large-Scale-System-Audit/</url>
    <content><![CDATA[<ul>
<li></li>
</ul>
<p>Needle in a Haystack: Attack Detection from Large-Scale System Audit abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/06/16/Needle-in-a-Haystack-Attack-Detection-from-Large-Scale-System-Audit/arch.png" alt="arch"></p>
<p>创新点：</p>
<ul>
<li>version based 溯源图表示方法，保存了时间信息但是图比之前大了</li>
<li>溯源图精简方法，包括剪枝和合并</li>
<li>基于 TTP 规则的攻击路径识别</li>
</ul>
<p><img src="/2022/06/16/Needle-in-a-Haystack-Attack-Detection-from-Large-Scale-System-Audit/version-graph.png" alt="arch"></p>
<p><img src="/2022/06/16/Needle-in-a-Haystack-Attack-Detection-from-Large-Scale-System-Audit/ttp-rules.png" alt="arch"></p>
<p><img src="/2022/06/16/Needle-in-a-Haystack-Attack-Detection-from-Large-Scale-System-Audit/algo.png" alt="arch"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
        <tag>溯源图</tag>
      </tags>
  </entry>
  <entry>
    <title>NIC: Detecting Adversarial Samples with Neural Network Invariant Checking</title>
    <url>/2022/05/08/NIC-Detecting-Adversarial-Samples-with-Neural-Network-Invariant-Checking/</url>
    <content><![CDATA[<p>NIC: Detecting Adversarial Samples with Neural Network Invariant Checking abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p>NIC 近似模拟了神经元激活模式的分布，然后通过比较近似分布与包含触发器的恶意样本的激活，来检测异常输入。<br>
<img src="/2022/05/08/NIC-Detecting-Adversarial-Samples-with-Neural-Network-Invariant-Checking/overview.png" alt="overview"></p>
<p>本文基于两个主要观察，发现攻击主要是通过攻击以下两个通道实施的：</p>
<ul>
<li>Provenance Channel, 该特征表示模型不够稳定，当前层神经元轻微改变后会导致下一层神经元激活情况会发生改变</li>
<li>Value Channel, 该特征表示在前一层神经元发生轻微改变后，当前层的神经元激活值与正常样本的激活值存在巨大差距</li>
</ul>
<p>基于以上观察的特点，以及对于攻击的分析提出基于不变值违规情况的攻击检测，our overarching idea is to check invariant violations during DNN computation.</p>
<h2 id="Detail">Detail</h2>
<p>由于模型的不确定性，模型的不变特征本质上是由模型表现的概率分布。因此：</p>
<ul>
<li>构建 DNN 的值不变特征就是为各个层训练一组模型，用以描述良性样本的层激活分布。</li>
<li>构建 DNN 的溯源不变特征就是训练一组模型，每一个模型描述层间神经元激活的因果分布</li>
</ul>
<h2 id="DNN-攻击的神经元激活观察">DNN 攻击的神经元激活观察</h2>
<p>在讨论中，我们认为一个神经元的激活函数，如 Relu，返回了一个非零值时认为该神经元为激活状态。并且 DNN 一层隐藏层可以看作一个函数，接受来自激活神经元的参数，在本层根据权重执行矩阵乘法，然后通过激活函数决定哪些神经元激活。</p>
<h3 id="Provenance-Channel">Provenance Channel</h3>
<p>我们将前一层神经元激活到本层神经元激活的关系视为本层的 Provenance Channel。很多攻击中隐含了该特征。</p>
<p><img src="/2022/05/08/NIC-Detecting-Adversarial-Samples-with-Neural-Network-Invariant-Checking/fig-2-6.png" alt="证明图例"></p>
<p>如上图所示，图2/3分别表示类别A/B的激活状态，红色为激活神经元，白色为未激活神经元，颜色越深表示值越大。</p>
<p>现有研究已经证明有些神经元只在特定的类别时激活，如图2/3中的1号和6号神经元只在类别为A时激活，4号和8号神经元只在类别为B时激活。</p>
<p>当然也存在着多重类别都会被激活的神经元，如图中的2号、3号和7号神经元。</p>
<p>图中横跨L1和L2两层的灰色区域表示激活溯源关系 Provenance Channel. 此处图中A类L1层中的1/2/3激活了L2中的6/7号神经元，B类L1层中的2/3/4激活了7/8号神经元。需要注意的是此处仅仅作为说明，单一类别也可能有多重激活方式。</p>
<p>图5展示了跟A类样本相似的攻击样本但是被误分类为了B类，L1中的1/2/3激活了L2中的7/8号神经元导致发生了误分类。该样本的溯源通道与典型的B类不同，根本原因是模型对神经元1中微小的扰动很敏感。</p>
<p>后门攻击就是攻击溯源通道的一个例子，该类攻击不改变整体性能，并且能将含有后门触发器的样本误分类。该类攻击修改特定层的权重值，使得后门触发器出现时激活神经元发生巨大改变。</p>
<h3 id="Activation-Value-Distribution">Activation Value Distribution</h3>
<p>有一些攻击不会改变模型的 Provenance Channel，也就是说其因果溯源关系与正常样本相同，但是会改变激活值的分布，具体如上图6中所示。</p>
<p>如 FGSM 等 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi mathvariant="normal">∞</mi></msub></mrow><annotation encoding="application/x-tex">L_{\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 攻击会对每个像素进行微小的改变，不改变原有的激活神经元，但是改变了激活的值分布，导致误分类。</p>
<p>当然也存在攻击会同时使两个属性发生改变，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 攻击，该攻击既不限制扰动的数量也不限制扰动的大小。</p>
<h2 id="用不变值检测来进行攻击检测">用不变值检测来进行攻击检测</h2>
<p><img src="/2022/05/08/NIC-Detecting-Adversarial-Samples-with-Neural-Network-Invariant-Checking/fig-7.png" alt="检测图例"></p>
<p>由于攻击 Provenance Channel 的攻击与传统攻击控制流劫持很相似，攻击激活值分布的攻击与传统攻击状态异常 state corruption 很相似。</p>
<p>检测此类软件攻击通常是用不变值检测技术 invariant checking, 具体来说：</p>
<ul>
<li>control flow hijacking 使用 control flow integrity(CFI) 来检测</li>
<li>state corruption 使用前置和后置状态来检测</li>
</ul>
<p>因此，我们提出在 DNN 中的不变值偏离检测的方法来检测对抗样本，并且由于 DNN 的不可解释性，这些不变值不能够精确地确定。不像其他的基于学习的技术，我们的方法仅需要良性样本和计算过程。</p>
<p>直观地说，将两个连续的隐藏层激活值分布定义为层的 因果溯源不变特征 （PI），将该层的神经元激活作为该层的值分布不变特征（VI），具体如图4.</p>
<h2 id="系统设计">系统设计</h2>
<p><img src="/2022/05/08/NIC-Detecting-Adversarial-Samples-with-Neural-Network-Invariant-Checking/overview.png" alt="overview"></p>
<p>具体步骤如下：</p>
<ul>
<li>A：针对每一个训练输入采集每一层的激活值信息，然后为每一层训练一个面向全部类别的分布模型，作为分布值不变特征</li>
<li>B：由于隐藏层神经元可能会比较多，所以训练了隐藏层的派生模型</li>
<li>C：通过所有派生模型运行每个良性训练输入,收集这些模型的最终输出（即各个类的输出概率值），对于每一对连续的层，训练其派生模型的分类结果的分布，训练后的分布作为这两层的 PI</li>
<li>D：获取测试样本的激活值 OV</li>
<li>E：计算最终的概率 D，表示 OVs/OPs 与 VI/PI 同分布的概率</li>
</ul>
<h2 id="系统设计详情介绍">系统设计详情介绍</h2>
<h3 id="DNN-Invariant-提取">DNN Invariant 提取</h3>
<p>文章提取了两个不变值 VI/PI，其中：</p>
<ul>
<li>VI(Value Invariant)：值不变特征用每层的神经元激活值来获得。</li>
<li>PI(Provenance Invariant)：转移不变特征，用两层神经元激活值来组成。</li>
</ul>
<p>需要注意的是，上述的两个值都是表示成分布的概率值。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>异常值检测</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集异常值检测相关工作调研</title>
    <url>/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/</url>
    <content><![CDATA[<p>数据集异常值检测相关工作。</p>
<span id="more"></span>
<h2 id="相关工作">相关工作</h2>
<p>通过几篇文章简单调研投毒攻击与异常值检测相关工作：</p>
<ul>
<li><code>Dataset Security for Machine Learning: Data Poisoning, Backdoor Attacks, and Defenses</code></li>
<li><code>Robust Learning-Enabled Intelligence for the Internet of Things: A Survey From the Perspectives of Noisy Data and Adversarial Examples</code></li>
<li><code>Outlier Detection: Methods, Models, and Classification</code></li>
</ul>
<h3 id="Dataset-Security-for-Machine-Learning-Data-Poisoning-Backdoor-Attacks-and-Defenses">Dataset Security for Machine Learning: Data Poisoning, Backdoor Attacks, and Defenses</h3>
<p>在 <code>Dataset Security for Machine Learning: Data Poisoning, Backdoor Attacks, and Defenses</code> 中的对抗投毒攻击部分，提到可以通过识别投毒数据和训练阶段阻止投毒样本。除此之外，还提到了针对联邦学习的防御。</p>
<p>文章在该部分建议读者参考下列两篇文章获得更多资料：</p>
<ul>
<li><code>V. Barnett and T. Lewis, “Outliers in statistical data,” Wiley Series in Probability and Mathematical Statistics. Applied Probability and Statistics, 1984.</code></li>
<li><code>A. Boukerche, L. Zheng, and O. Alfandi, “Outlier detection: Methods, models, and classification,” ACM Computing Surveys (CSUR), vol. 53, no. 3, pp. 1–37, 2020.</code></li>
</ul>
<h4 id="识别投毒攻击-Identifying-Poisoned-Data">识别投毒攻击 Identifying Poisoned Data</h4>
<h5 id="输入空间内的检测-Outliers-in-input-space">输入空间内的检测 Outliers in input space</h5>
<p>在防御现代机器学习数据集中毒的背景下，<code>J. Steinhardt, P. W. W. Koh, and P. S. Liang, “Certified defenses for data poisoning attacks,” in Advances in neural information processing systems, 2017, pp. 3517–3529.</code> 专注于二进制分类情况并删除远离其各自质心的数据点，该方法直接在输入空间测量或在将数据投影到两个质心之间的线上后测量。</p>
<p>基于假设：如果单个数据点对模型有着很大的影响，它将被识别为异常值。这个假设可以防止攻击者注入一些输入来显著改变模型的行为。以下两篇文章采用鲁棒性均值估计工具(tools from robust mean estimation)来稳健估计数据集上的平均风险梯度(average risk gradient)：</p>
<ul>
<li><code>I. Diakonikolas, G. Kamath, D. Kane, J. Li, J. Steinhardt, and A. Stewart, “Sever: A robust meta-algorithm for stochastic opti- mization,” in International Conference on Machine Learning, 2019, pp. 1596–1606.</code></li>
<li><code>A. Prasad, A. S. Suggala, S. Balakrishnan, and P. Ravikumar, “Robust estimation via robust gradient estimation,” arXiv preprint arXiv:1802.06485, 2018.</code></li>
</ul>
<p><code>A. Paudice, L. Muñoz-González, A. Gyorgy, and E. C. Lupu, “Detection of adversarial training examples in poisoning attacks through anomaly detection,” arXiv preprint arXiv:1802.03041, 2018.</code> 提出了一种用于线性分类器的具有异常值检测的数据预过滤方法。首先分离一个可信的数据集，然后使用该数据集为每个类别训练一个基于距离的异常值检测器，当使用新的不受信任的数据集进行重新训练时，异常检测器会删除超过某个分数阈值的样本。</p>
<p><code>A. Paudice, L. Muñoz-González, and E. C. Lupu, “Label saniti- zation against label flipping poisoning attacks,” in Joint European Conference on Machine Learning and Knowledge Discovery in Databases. Springer, 2018, pp. 5–15.</code> 通过使用 KNN 重新标记训练集中的每个数据点来减轻标签翻转攻击的危害。具体来说，就是用 k 个最近邻中最常见的标签重新标记每个数据点。但是值得注意的是，自适应攻击可以绕过某些基于异常值的防御。<br>
具体来说，在 <code>P. W. Koh, J. Steinhardt, and P. Liang, “Stronger data poison- ing attacks break data sanitization defenses,” arXiv preprint arXiv:1811.00741, 2018.</code> 设计了一种欺骗异常检测器的攻击，方法是将中毒输入彼此靠近，并将中毒攻击改写为受约束的优化问题以逃避检测。</p>
<h5 id="特征空间内的检测-Outliers-in-latent-space">特征空间内的检测 Outliers in latent space</h5>
<p>虽然在输入空间进行异常值检测简单只管，但它只对简单的地位输入域有效，在复杂的领域，如图像或者文本数据，直接比较原始输入数据可能不会传达任何有意义的相似性概念。因此，最近的工作集中在基于深度神经网络的潜在嵌入表达上检测异常值。原理是：潜在嵌入表达捕获了分类所需的信号，使得好的输入和污染输入之间的差异更加明显。</p>
<p><code>B. Tran, J. Li, and A. Madry, “Spectral signatures in backdoor attacks,” in Advances in Neural Information Processing Systems, 2018, pp. 8000–8010.</code> 使用来自鲁棒性平均估计的攻击找到特征表示的协方差显著偏差的方向。测量这些方向上的变化可以更好地检测标准后门攻击，而不是简单的指标，例如特征空间中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 距离。</p>
<p>检测算法 NIC <code>S. Ma and Y. Liu, “Nic: Detecting adversarial samples with neural network invariant checking,” in Proceedings of the 26th Network and Distributed System Security Symposium (NDSS 2019), 2019.</code> 近似神经元激活模式的分布，并通过将其激活与该近似分布进行比较来检测包含触发器的输入。</p>
<p><code>B. Chen, W. Carvalho, N. Baracaldo, H. Ludwig, B. Edwards, T. Lee, I. Molloy, and B. Srivastava, “Detecting backdoor attacks on deep neural networks by activation clustering,” arXiv preprint arXiv:1811.03728, 2018.</code> 将聚类算法应用于潜在表示并识别其成员，在训练中被学习模型删除时将以不同的标记聚类。</p>
<p><code>N. Peri, N. Gupta, W. R. Huang, L. Fowl, C. Zhu, S. Feizi, T. Goldstein, and J. P. Dickerson, “Deep k-nn defense against clean-label data poisoning attacks,” arXiv preprint arXiv:1909.13374, 2019.</code> 中提到，污染输入的深层特征通常位于目标类的分布附近，而不是靠近具有相同标签其他数据的分布。他们使用这种观察来检测数据集中的污染数据。</p>
<p><code>P. W. Koh and P. Liang, “Understanding black-box predictions via influence functions,” in International Conference on Machine Learning, 2017, pp. 1885–1894.</code> 使用模型的潜在嵌入表示来计算影响函数，这些函数测量每个训练样本对测试集性能的影响。他们发现这些影响估计可以有效地标记可能被错误标记的示例，以便进行手动检查。</p>
<h4 id="训练阶段阻止投毒攻击-Preventing-Poisoning-during-Training">训练阶段阻止投毒攻击 Preventing Poisoning during Training</h4>
<h5 id="鲁棒性统计-Robust-Statics">鲁棒性统计 Robust Statics</h5>
<p>总的来说，在存在异常值的情况下，估计数据的统计特性是鲁棒性统计(Robust Statistics)领域的核心问题。<br>
领域内大量的工作证明，从信息论的角度来看，对于各种各样的任务和数据分布，这个问题确实易于处理：</p>
<ul>
<li><code>J. W. Tukey, “A survey of sampling from contaminated distribu- tions,” Contributions to probability and statistics, 1960.</code></li>
<li><code>P. J. Huber, “Robust estimation of a location parameter,” The Annals of Mathematical Statistics, pp. 73–101, 1964.</code></li>
<li><code>D. L. Donoho and R. C. Liu, “The&quot; automatic&quot; robustness of minimum distance functionals,” The Annals of Statistics, 1988.</code></li>
<li><code>Y. Zuo and R. Serfling, “General notions of statistical depth function,” Annals of statistics, 2000.</code></li>
<li><code>M. Chen, C. Gao, Z. Ren et al., “Robust covariance and scatter matrix estimation under huber’s contamination model,” The Annals of Statistics, 2018.</code></li>
<li><code>J. Steinhardt, M. Charikar, and G. Valiant, “Resilience: A criterion for learning in the presence of arbitrary outliers,” in Innovations in Theoretical Computer Science Conference (ITCS), 2018.</code></li>
<li><code>B. Zhu, J. Jiao, and J. Steinhardt, “Generalized resilience and robust statistics,” arXiv preprint arXiv:1909.08755, 2019.</code></li>
</ul>
<p>然而，从计算的角度来看，这些方法中的大多数都没有为高维数据集提供有效的实现。最近，有一系列研究专注于在这种环境中设计计算高校的算法。</p>
<p><code>A. R. Klivans, P. M. Long, and R. A. Servedio, “Learning halfspaces with malicious noise.” Journal of Machine Learning Research, vol. 10, no. 12, 2009.</code> 提出了第一个在对抗性噪声下学习线性分类器的算法。</p>
<p>以下两篇文章，在小部分数据被任意破坏的情况下，开发了有效的算法来学习许多参数分布：</p>
<ul>
<li><code>I. Diakonikolas, G. Kamath, D. Kane, J. Li, A. Moitra, and A. Stewart, “Robust estimators in high-dimensions without the computational intractability,” SIAM Journal on Computing, vol. 48, no. 2, pp. 742–864, 2019.</code></li>
<li><code>K. A. Lai, A. B. Rao, and S. Vempala, “Agnostic estimation of mean and covariance,” in 2016 IEEE 57th Annual Symposium on Foundations of Computer Science (FOCS). IEEE, 2016, pp. 665–674.</code></li>
</ul>
<p>这些算法依赖于相对简单的原语，因此即使对于高维分布也可以有效地实现。</p>
<p>在正交的方向上，<code>C. Gao, J. Liu, Y. Yao, and W. Zhu, “Robust estimation and generative adversarial nets,” arXiv preprint arXiv:1810.02030, 2018.</code> 在鲁棒性评估和GANs之间建立了联系。<code>C. Gao, Y. Yao, andW. Zhu, “Generative adversarial nets for robust scatter estimation: A proper scoring rule perspective,” Journal of Machine Learning Research (JMLR), 2020.</code> 允许人们有效地逼近复杂的鲁棒性估计器。</p>
<p>这些算法专注于估计数据的特定统计量，但是其他工作优化来存在异常值时的情况，例如：<code>M. Charikar, J. Steinhardt, and G. Valiant, “Learning from un- trusted data,” in Symposium on Theory of Computing (STOC), 2017.</code> 提出了基于回复可能模型列表和使用可选小型未损坏数据集在他们之间进行选择的风险最小化算法。</p>
<p>更多的参考资料，见：</p>
<ul>
<li><code>J. Z. Li, “Principled approaches to robust machine learning and be- yond,” Ph.D. dissertation, Massachusetts Institute of Technology, 2018.</code></li>
<li><code>J. Steinhardt, “Robust learning: Information theory and algo- rithms,” Ph.D. dissertation, Stanford University, 2018.</code></li>
<li><code>I. Diakonikolas and D. M. Kane, “Recent advances in algorithmic high-dimensional robust statistics,” arXiv preprint arXiv:1911.05911, 2019.</code></li>
</ul>
<h5 id="差分隐私-Differential-Privacy">差分隐私 Differential Privacy</h5>
<p>差分隐私（Differency Privacy）最初旨在保护提供数据的个人的隐私。核心思想是如果在添加或者减去一个单独的输入点时算法的输出基本保持不变，那么每个人的隐私都会得到保护。从数据投毒攻击的角度，由于差分隐私确保了模型的预测不会过多地依赖于单个数据点，因此模型不会受到中毒样本的过度影响。</p>
<p><code>Y. Ma, X. Zhu, and J. Hsu, “Data poisoning against differentially-private learners: attacks and defenses,” in Proceedings of the 28th International Joint Conference on Artificial Intelligence. AAAI Press, 2019, pp. 4732–4738.</code> 从实践和理论的角度研究了基于DP的数据中毒防御。</p>
<p><code>S. Hong, V. Chandrasekaran, Y. Kaya, T. Dumitra¸s, and N. Paper not, “On the effectiveness of mitigating data poisoning attacks with gradient shaping,” arXiv preprint arXiv:2002.11497, 2020.</code> 实验表明，现成的DP-SGD机制在训练期间对梯度进行剪辑和噪声处理，可以作为一种防御手段防范数据投毒攻击。他们指出，在存在污染数据的情况下计算的梯度主要特点（main artifacts）是：（1）<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 范数具有更高的量级（2）并且方向不同。</p>
<p><code>S. Hong, V. Chandrasekaran, Y. Kaya, T. Dumitra¸s, and N. Paper- not, “On the effectiveness of mitigating data poisoning attacks with gradient shaping,” arXiv preprint arXiv:2002.11497, 2020.</code> 中说明，由于DP-SGD通过裁剪来限制梯度幅度，并通过添加随即噪声来最小化方向差异，因此它可以成功地防御数据投毒攻击。</p>
<p>以下工作证明，基于数据投毒攻击和后门攻击经验的数据增强也可以在不降低模型性能的情况下增强差分隐私性能：</p>
<ul>
<li><code>E. Borgnia, V. Cherepanova, L. Fowl, A. Ghiasi, J. Geiping, M. Goldblum, T. Goldstein, and A. Gupta, “Strong data aug- mentation sanitizes poisoning and backdoor attacks without an accuracy tradeoff,” arXiv preprint arXiv:2011.09527, 2020.</code></li>
<li><code>E. Borgnia, J. Geiping, V. Cherepanova, L. Fowl, A. Gupta, A. Ghiasi, F. Huang, M. Goldblum, and T. Goldstein, “Dpinstahide: Provably defusing poisoning and backdoor attacks with differentially private data augmentations,” arXiv preprint arXiv:2103.02079, 2021.</code></li>
</ul>
<h4 id="联邦学习的防御-Defense-for-Federated-Learning">联邦学习的防御 Defense for Federated Learning</h4>
<p>因为联邦学习的特点，为数据投毒攻击提供了新的攻击路径，因此针对联邦学习环境下的数据投毒攻击，提出了一系列的防御措施，其中包括：</p>
<ul>
<li>鲁棒性联邦聚合</li>
<li>鲁棒性联邦训练</li>
<li>训练后防御</li>
</ul>
<h5 id="Robust-Federated-Aggregation">Robust Federated Aggregation</h5>
<p>鲁棒性联邦聚合可以分为两类：</p>
<ul>
<li>识别并且降低恶意更新的权重</li>
<li>设计可以抵抗投毒聚合算法</li>
</ul>
<p>具体的方法有：</p>
<ul>
<li><code>C. Fung, C. J. Yoon, and I. Beschastnikh, “Mitigating sybils in federated learning poisoning,” arXiv preprint arXiv:1808.04866, 2018.</code></li>
<li><code>S. Li, Y. Cheng, W. Wang, Y. Liu, and T. Chen, “Learning to detect malicious clients for robust federated learning,” arXiv preprint arXiv:2002.00211, 2020.</code></li>
<li><code>D. P. Kingma and M. Welling, “Auto-encoding variational bayes,” arXiv preprint arXiv:1312.6114, 2013.</code></li>
<li><code>P. Blanchard, R. Guerraoui, J. Stainer et al., “Machine learning with adversaries: Byzantine tolerant gradient descent,” in Advances in Neural Information Processing Systems, 2017, pp. 119–129.</code></li>
<li><code>E. M. E. Mhamdi, R. Guerraoui, and S. Rouault, “The hiddenvulnerability of distributed learning in byzantium,” arXiv preprint arXiv:1802.07927, 2018.</code></li>
<li><code>D. Yin, Y. Chen, K. Ramchandran, and P. Bartlett, “Byzantine- robust distributed learning: Towards optimal statistical rates,” arXiv preprint arXiv:1803.01498, 2018.</code></li>
<li><code>Y. Chen, L. Su, and J. Xu, “Distributed statistical machine learning in adversarial settings: Byzantine gradient descent,” Proceedings of the ACM on Measurement and Analysis of Computing Systems, vol. 1, no. 2, pp. 1–25, 2017.</code></li>
<li><code>K. Pillutla, S. M. Kakade, and Z. Harchaoui, “Robust aggregation for federated learning,” arXiv preprint arXiv:1912.13445, 2019.</code></li>
<li><code>L. Li, W. Xu, T. Chen, G. B. Giannakis, and Q. Ling, “Rsa: Byzantine-robust stochastic aggregation methods for distributed learning from heterogeneous datasets,” in Proceedings of the AAAI Conference on Artificial Intelligence, vol. 33, 2019, pp. 1544–1551.</code></li>
<li><code>S. Fu, C. Xie, B. Li, and Q. Chen, “Attack-resistant feder- ated learning with residual-based reweighting,” arXiv preprint arXiv:1912.11464, 2019.</code></li>
<li><code>A. F. Siegel, “Robust regression using repeated medians,” Biometrika, vol. 69, no. 1, pp. 242–244, 1982.</code></li>
</ul>
<h5 id="Robust-Federated-Training">Robust Federated Training</h5>
<p>在训练中提高联邦学习抵抗数据投毒攻击能力的论文有：</p>
<ul>
<li><code>E. Bagdasaryan, A. Veit, Y. Hua, D. Estrin, and V. Shmatikov, “How to backdoor federated learning,” in International Conference on Artificial Intelligence and Statistics. PMLR, 2020, pp. 2938–2948</code></li>
<li><code>Z. Sun, P. Kairouz, A. T. Suresh, and H. B. McMahan, “Can you really backdoor federated learning?” arXiv preprint arXiv:1911.07963, 2019.</code></li>
<li><code>S. Andreina, G. A. Marson, H. Möllering, and G. Karame, “Baffle: Backdoor detection via feedback-based federated learning,” arXiv preprint arXiv:2011.02167, 2020</code></li>
</ul>
<h5 id="Post-Training-Defenses">Post-Training Defenses</h5>
<p>其他的防御措施关注于在训练后将被投毒污染的模型恢复，具体论文有：</p>
<ul>
<li><code>C. Wu, X. Yang, S. Zhu, and P. Mitra, “Mitigating backdoor attacks in federated learning,” arXiv preprint arXiv:2011.01767, 2020.</code></li>
</ul>
<h3 id="Robust-Estimators-in-High-Dimensions-without-the-Computational-Intractability">Robust Estimators in High Dimensions without the Computational Intractability</h3>
<p>文章关于数据部分提到了两个方向：</p>
<ul>
<li>缺值 incomplete data</li>
<li>异常值 outlier data</li>
</ul>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/research1.png" alt="outliers and missing data"></p>
<h3 id="Outlier-Detection-Methods-Models-and-Classification">Outlier Detection: Methods, Models, and Classification</h3>
<p>本文是针对数值类型的异常值检测，主要针对无监督的异常值检测方法做的调研，当然也包括部分最新的半监督异常值检测。</p>
<p>具体的异常值检测按照下图分类：</p>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/classification.png" alt="classification"></p>
<h4 id="基于近似的方法-Proximity-based-Approaches">基于近似的方法 Proximity-based Approaches</h4>
<p>基于近似的方法通过数据点与附近数据的关系来识别异常点。</p>
<h5 id="基于最近邻的算法-Nearest-neighbor-based-Approaches">基于最近邻的算法 Nearest-neighbor-based Approaches</h5>
<p>最近邻的异常值检测基于数据点与其最近的邻居之间的关系来衡量其异常等级。<br>
有两种主要的定义邻居的方法：</p>
<ul>
<li>k nearest neighbors</li>
<li>pre-specified radius</li>
</ul>
<p>潜在的假设是：正常数据与他的邻居相邻更近，然而异常值距离其邻居更远。</p>
<p>在此部分调研了几种基于最近邻的经典异常值检测方法，以及利用了子样本采样和集成的最新方法。<br>
<img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/nearest-neighbor.png" alt="Nearest Neighbor"></p>
<h5 id="基于集群的算法-Clustering-based-Approaches">基于集群的算法 Clustering-based Approaches</h5>
<p>基于集群的算法通常分为两个步骤：</p>
<ul>
<li>通过集群算法对数据点进行聚合</li>
<li>分析聚合后结果的偏离程度</li>
</ul>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/clustering.png" alt="Clustering"></p>
<h4 id="基于投影的方法-Projection-based-Approaches">基于投影的方法 Projection-based Approaches</h4>
<p>很多流行的异常检测通常需要计算成对的距离或者搜索 k-NN，这会导致极大的时间复杂度。在此处介绍一些基于投影的方法，如随机投影、LSH等。</p>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/projection.png" alt="Projection"></p>
<h4 id="高维度异常检测-High-Dimensional-Outlier-Detection">高维度异常检测 High-Dimensional Outlier Detection</h4>
<p>如 Zimek 在其论文中总结的，高维度数据异常检测有两个：效率方面和有效性方面。导致这两方面是因为：</p>
<ul>
<li>基于相似度搜索的方法在高维数据上计算代价过高</li>
<li>一些用于加速异常检测的方法效果不好</li>
</ul>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/high-dimension.png" alt="High-Dimension"></p>
<h4 id="数据流异常值检测-Outlier-Detection-in-Data-Streams">数据流异常值检测 Outlier Detection in Data Streams</h4>
<p>对于数据流检测来说有两个主要的挑战：</p>
<ul>
<li>数据存储挑战</li>
<li>效率挑战，一些动态应用对检测效率有要求，例如攻击检测</li>
</ul>
<p>对于上述挑战，使用窗口来进行解决，对于窗口有研究对其进行了总结，有四种不同的滑动窗口：</p>
<ul>
<li>地标窗口</li>
<li>滑动窗口</li>
<li>阻尼窗口</li>
<li>自适应窗口</li>
</ul>
<h5 id="数据流中基于距离的异常值检测-Distance-based-Outlier-Detection-in-Data-Streams">数据流中基于距离的异常值检测 Distance-based Outlier Detection in Data Streams</h5>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/distance-based-in-datastreams.png" alt="Distance-based"></p>
<h5 id="数据流中基于密度的异常值检测-Density-based-Outlier-Detection-in-Data-Streams">数据流中基于密度的异常值检测 Density-based Outlier Detection in Data Streams</h5>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/density-based-in-datastreams.png" alt="Density-based"></p>
<h6 id="数据流中基于集群的异常值检测-Clustering-based-Outlier-Detection-in-Data-Streams">数据流中基于集群的异常值检测 Clustering-based Outlier Detection in Data Streams</h6>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/clustering-in-datastreams.png" alt="Clustering-based"></p>
<h4 id="分布式异常检测">分布式异常检测</h4>
<p>传统机器学习和数据挖掘方法在大数据时代存在的缺点是由几个方面造成的：</p>
<ul>
<li>第一个是单个主机的性能不足</li>
<li>第二个是中心式的算法可能达不到许多现代应用的实时性要求</li>
</ul>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/distributed.png" alt="Distributed"></p>
<h4 id="基于深度学习的异常值检测-Deep-Learning-based-Outlier-Detection">基于深度学习的异常值检测 Deep Learning-based Outlier Detection</h4>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/deep-learning.png" alt="Deep Learning"></p>
<h4 id="反馈式异常值检测-Outlier-Detection-with-Feedback">反馈式异常值检测 Outlier Detection with Feedback</h4>
<p><img src="/2022/05/05/Machine-Learning-Dataset-Assessment-and-Enhancement/feedback.png" alt="Feedback"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>innovation</category>
      </categories>
      <tags>
        <tag>异常值检测</tag>
        <tag>robustness</tag>
        <tag>dataset</tag>
        <tag>assessment</tag>
      </tags>
  </entry>
  <entry>
    <title>OmegaLog: High-Fidelity Attack Investigation via Transparent Multi-layer Log Analysis</title>
    <url>/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/</url>
    <content><![CDATA[<p>OmegaLog: High-Fidelity Attack Investigation via Transparent Multi-layer Log Analysis abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>系统级别因果分析缺少重要的应用上下文，比如 http 响应码。现有的分析引擎也很难很难利用这些数据，因为系统层级之间存在语义鸿沟。<br>
本文为解决此问题提出。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/arch.png" alt="arch"></p>
<p>通过分析程序二进制文件以识别和建模应用程序层日志记录行为，从而实现应用程序事件与系统层访问的准确协调。<br>
然后拦截应用程序的运行时日志记录活动，并将这些事件移植到系统层溯源图，使调查人员能够更准确地推断攻击的性质。</p>
<h2 id="溯源图比较">溯源图比较</h2>
<p>本文的应用程序语义和系统日志关联的溯源图：</p>
<p><img src="/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/eg-1.png" alt="eg"></p>
<p>传统溯源图存在的依赖爆炸的问题，这是 SQL 注入的一个攻击场景：</p>
<p><img src="/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/eg-2.png" alt="eg"></p>
<p>与现有算法的比较：</p>
<p><img src="/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/eg-3.png" alt="eg"></p>
<p>OmegaLog 生成的溯源图：</p>
<p><img src="/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/eg-4.png" alt="eg"></p>
<h2 id="具体实现">具体实现</h2>
<ul>
<li>1 首先分析所有应用程序二进制文件提取代码中描述事件日志语句的日志消息字符串（Log Message String, LMS），然后使用控制流分析俩识别 LMS 在程序的不同执行中所有可能的时间路径</li>
<li>2 所有的 LMS 控制流路径都存储在数据库中，该数据库输入到日志解析器以引导应用程序事件的解释</li>
<li>3 运行时，捕获所有应用程序事件，并通过拦截写入系统调用的内核模块使用应用程序的 PID/TID 和日志事件时间戳来扩充他们</li>
<li>4 同时，从底层的全系统溯源跟踪器收集系统日志，并使用 PID/TID 作为消歧器将他们与适当的应用程序事件相关联，并将他们存储到统一的日志中</li>
<li>5 将统一的日志和LMS控制流路径数据库传递给一个日志解析器，该解析器通过插入一个新的应用程序日志顶点来划分整个系统途中的关联进程，该顶点连接到相应的分区进程，并在该进程的特定执行单元中的日志消息进行注释，语义感知和执行分区图成为通用溯源图，给分析专家使用</li>
</ul>
<p><img src="/2022/04/14/OmegaLog-High-Fidelity-Attack-Investigation-via-Transparent-Multi-layer-Log-Analysis/eg-5.png" alt="eg"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural Cleanse: Identifying and Mitigating Backdoor Attacks in Neural Networks</title>
    <url>/2022/04/02/Neural-Cleanse-Identifying-and-Mitigating-Backdoor-Attacks-in-Neural-Networks/</url>
    <content><![CDATA[<p>Neural Cleanse: Identifying and Mitigating Backdoor Attacks in Neural Networks 读书笔记。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/02/Neural-Cleanse-Identifying-and-Mitigating-Backdoor-Attacks-in-Neural-Networks/arch.png" alt="架构图"></p>
<h2 id="后门原理">后门原理</h2>
<p><img src="/2022/04/02/Neural-Cleanse-Identifying-and-Mitigating-Backdoor-Attacks-in-Neural-Networks/illustration.png" alt="后门原理介绍"><br>
后门修改了B和C的决策边界，在B与C附近构造了后门区域，使得模型成生误分类。</p>
<h2 id="具体检测方法">具体检测方法</h2>
<h3 id="基本检测原理">基本检测原理</h3>
<p>感染的模型需要非常小的修改就可以造成误分类，因此计算每一个标签修改后会被误分类的距离。</p>
<h3 id="步骤">步骤</h3>
<ol>
<li>给定一个标签，将该标签视为存在潜在后门的标签，然后设计了一种优化方案寻找最小的误分类触发距离。</li>
<li>对每一种标签，重复步骤1。</li>
<li>使用异常值检测来确定出发距离是否远比其他的小。</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>后门植入</tag>
        <tag>后门检测</tag>
      </tags>
  </entry>
  <entry>
    <title>On the Forensic Validity of Approximated Audit Logs</title>
    <url>/2022/04/19/On-the-Forensic-Validity-of-Approximated-Audit-Logs/</url>
    <content><![CDATA[<p>On the Forensic Validity of Approximated Audit Logs abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>审计日程已经成为了系统防御的基础工具，但是日志数据的笨重性质给管理员和安全分析人员带来了沉重的负担。为了解决这个问题，已经提出了多种技术来近似原始审计日志的内容，从而促进有效地存储和分析。<br>
但是，这些近似日志的安全价值很难衡量（相对于原始日志），尚不清楚这些技术是否有效保留了对于调查威胁所需的取证证据。不幸的是，之前的工作只是对这个问题进行了案例证明，在特定攻击场景下保留了足够的证据。</p>
<p>本文为解决这个问题提出了方法。</p>
<h2 id="思路与方法">思路与方法</h2>
<p>为解决这个问题，作者通过<strong>形式化指标</strong>来解决文献中的这一差距，以量化不同威胁模型下近似审计日志的取证有效性。</p>
<h3 id="取证有效性矩阵">取证有效性矩阵</h3>
<p>使用三个互补的取证有效性指标评估审计日志近似方法。他们是：</p>
<ul>
<li>无损 lossless</li>
<li>因果关系保持 causality-preserving</li>
<li>攻击保持 attack-preserving</li>
</ul>
<h3 id="Lossless">Lossless</h3>
<p>这个矩阵假设：</p>
<ul>
<li>攻击者可能在恶意进程通信和协调方面，与系统级别抽象不同</li>
</ul>
<p><img src="/2022/04/19/On-the-Forensic-Validity-of-Approximated-Audit-Logs/def-3.1.png" alt="definition"></p>
<h3 id="causality-preserving">causality-preserving</h3>
<p>这个矩阵假设：</p>
<ul>
<li>攻击者在恶意进程通信和协调方面，与系统抽象相同</li>
</ul>
<p><img src="/2022/04/19/On-the-Forensic-Validity-of-Approximated-Audit-Logs/def-3.2.png" alt="definition"></p>
<h3 id="attack-perseving">attack-perseving</h3>
<p>这个矩阵假设：</p>
<ul>
<li>攻击者的系统级行为偏离良性行为</li>
</ul>
<p><img src="/2022/04/19/On-the-Forensic-Validity-of-Approximated-Audit-Logs/def-3.3.png" alt="definition"></p>
<h3 id="LOGAPPROX-近似算法">LOGAPPROX 近似算法</h3>
<p>审计日志近似精简的工作流：</p>
<p><img src="/2022/04/19/On-the-Forensic-Validity-of-Approximated-Audit-Logs/workflow-appro.png" alt="workflow"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>日志近似方法验证</tag>
      </tags>
  </entry>
  <entry>
    <title>Pooling in Graph Convolutional Neural Networks</title>
    <url>/2022/03/15/Pooling-in-Graph-Convolutional-Neural-Networks/</url>
    <content><![CDATA[<p>该论文对结合不同网络结构对图神经网络上的池化操作做了评估。在图分类数据集上对图卷积神经网络中的图卷积操作和图池化操作进行评估。</p>
<span id="more"></span>
<h2 id="池化操作">池化操作</h2>
<p>池化操作是卷积神经网络中一个重要的操作，是一种非线性的下采样操作。在卷积神经网络中，池化曾可以对特征降维，因此可以降低计算量、内存占用和参数数量。</p>
<p>正因为如此，池化也使得深层网络成为可能，并且有助于控制过拟合。</p>
<h2 id="图池化层">图池化层</h2>
<h3 id="Sort-Pooling">Sort Pooling</h3>
<p>SortPooling 不使用求和与平均计算特征，而是根据固定一致的顺序对节点进行排序，输出一个具有固定集合的表示以便可以使用 CNN 进行进一步的训练。<br>
节点排序依据该节点在图结构上的角色。利用图卷积和 Weisfeiler-Lehman 子树核之间的连接，SortPool 对最后一层的节点特征进行单独排序，然后根据前一层将序排列，最后选择前 k 个节点。</p>
<h3 id="Differentiable-Pooling">Differentiable Pooling</h3>
<p>DiffPool 是一个微分图池化模块，它通过多个池化层聚合节点来学习图的层次表示。<br>
与 GraphSAGE、SortPool 和某些图核方法相比，DiffPool 的预测准确度显著提高，尤其是当全局特征对分类很重要时。<br>
<strong>DiffPooling</strong> 更好地提取全图特征。</p>
<h3 id="Top-k-Pooling">Top-k Pooling</h3>
<p>Top-k Pool 使用可训练的投影向量进行池化，然后选择投影的 top-k 索引和相应的边做表示。<br>
Top-k Pool 受到像 U-Nets 这样的编码解码结构的启发。<br>
除了池化操作，也定义了反池化操作。这两者在图上创建了编码器-解码器模型，称为图 U-Nets.</p>
<h3 id="Self-Attention-Graph-Pooling">Self-Attention Graph Pooling</h3>
<p>SagPool 使用注意力机制来筛选重要节点，注意力得分是通过 GCN 计算的来，然后选择 k 个得分最高的节点。<br>
SagPool 同时使用图特征和结构来学习自关注分数，有工作表明 SAGPool 在生化数据集上比 DiffPool 和 Top-k Pool 表现好。</p>
<h2 id="数据集">数据集</h2>
<p><img src="/2022/03/15/Pooling-in-Graph-Convolutional-Neural-Networks/datasets.png" alt="数据集列表"></p>
<ol>
<li>MUTAG 是关于化合物的数据集，每个化合物表示为一张图，节点表示元素，边表示化学键，任务是预测该化合物是否具有突变性。</li>
<li>Proteins 是关于蛋白质的数据集，每个蛋白质表示为一张图，任务是预测该蛋白质是否具有酶的功能。</li>
<li>IMDB-Binary 是电影明星的关系网络，节点是人，边是两个人参演同一部电影，任务是预测一部电影是动作片还是爱情片。</li>
<li>Reddit-Binary 是 Reddit 论坛上的关系图，每张图表示一个话题，节点是用户，边是两个用户有问答关系，任务是预测一个话题是问答还是讨论。</li>
</ol>
<h2 id="结果">结果</h2>
<p><img src="/2022/03/15/Pooling-in-Graph-Convolutional-Neural-Networks/res1.png" alt="图"><br>
<img src="/2022/03/15/Pooling-in-Graph-Convolutional-Neural-Networks/res2.png" alt="图"><br>
<img src="/2022/03/15/Pooling-in-Graph-Convolutional-Neural-Networks/res3.png" alt="图"></p>
<h4 id="图卷积比较">图卷积比较</h4>
<p>TAGCN 在四个图分类数据集上表现比 GCN/GraphSAGE 要好，但是随着复杂度的增加，该网络具有较高的方差，特别是在密集的图结构上。因此，当图变得不那么稀疏时，即随着平均度数的增加，TAGCN 的表现会更好。</p>
<h4 id="图卷积和图池化比较">图卷积和图池化比较</h4>
<p>在本文提到的池化操作中，DiffPool 通常比其他方法表现更好。Top-k 表现不佳，表明他需要自动编码器结构才能表现更好。并且只有 DiffPool 表现始终比没有池化好。</p>
<h4 id="总结">总结</h4>
<p>图卷积的结果适用于图卷积的图池化。 带有池化的 TAGCN 通常比带有池化的 GCN 和 GraphSAGE 性能更好，并且更容易过度拟合，该情况可能是由于相同的原因。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>池化操作</tag>
        <tag>图卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenBackdoor: A Unified Evaluation of Textual Backdoor Learning: Frameworks and Benchmarks</title>
    <url>/2023/03/16/OpenBackdoor-A-Unified-Evaluation-of-Textual-Backdoor-Learning-Frameworks-and-Benchmarks/</url>
    <content><![CDATA[<p>Reading notes about OpenBackdoor.</p>
<span id="more"></span>
<h2 id="Abstract">Abstract</h2>
<p>This paper focus on textual backdoor attacks, which highlights two issues in privious backdoor learning evaluations:</p>
<ol>
<li>real-wolrd scenarios differs</li>
<li>evaluation ignore that poisoned samples’ stealthy and semantic-preserving</li>
</ol>
<p>Contribution:</p>
<ol>
<li>categorize existing scenarios</li>
<li>new stealthy and semantic-preserving metrics</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>backdoor</tag>
        <tag>toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>POST-TRAINING DETECTION OF BACKDOOR ATTACKS FOR TWO-CLASS AND MULTI-ATTACK SCENARIOS</title>
    <url>/2022/04/08/POST-TRAINING-DETECTION-OF-BACKDOOR-ATTACKS-FOR-TWO-CLASS-AND-MULTI-ATTACK-SCENARIOS/</url>
    <content><![CDATA[<p>POST-TRAINING DETECTION OF BACKDOOR ATTACKS FOR TWO-CLASS AND MULTI-ATTACK SCENARIOS abstract。</p>
<span id="more"></span>
<h2 id="Architectrue">Architectrue</h2>
<p>文章定义了一个新的量 期望可转移性（Expected Transferablitiy），作为统计量独立检查每个类，并且能够根据经验评估。<br>
<img src="/2022/04/08/POST-TRAINING-DETECTION-OF-BACKDOOR-ATTACKS-FOR-TWO-CLASS-AND-MULTI-ATTACK-SCENARIOS/algo.png" alt="算法"></p>
<p>该方法的特点：</p>
<ul>
<li>可以对二分类网络进行后门检测</li>
<li>需要干净的数据</li>
<li>一致的阈值，1/2</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>后门植入检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Practical Detection of Trojan Neural Networks: Data-Limited and Data-Free Cases</title>
    <url>/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/</url>
    <content><![CDATA[<p>Practical Detection of Trojan Neural Networks: Data-Limited and Data-Free Cases abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/arch.png" alt="架构图"></p>
<h2 id="主要贡献">主要贡献</h2>
<ul>
<li>data-limite TrojanNet detector(DL-TND)</li>
<li>data-free TrojanNet detector(DF-TND)</li>
</ul>
<h2 id="后门攻击">后门攻击</h2>
<p>后门攻击可以被分为两类：</p>
<ul>
<li>trigger-driven，触发器驱动的，当图片中存在特定图案时该样本被错误分类至目标分类</li>
<li>clean-label，干净的标签，意思是污染样本的标签是正确的，但是注入的数据在嵌入空间内导致错误表示，使得网络学习到错误的映射，因而该网络会在分类该测试输入类别时，将其识别为目标类别。</li>
</ul>
<h2 id="扰动表示">扰动表示</h2>
<p><img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/perturbation.png" alt="扰动公式"></p>
<h2 id="DL-TND：有限数据下的后门网络检测">DL-TND：有限数据下的后门网络检测</h2>
<p>通过将通用扰动和每张图的对抗性结合来设计检测器。<br>
<img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/perturbation.png" alt="扰动公式"><br>
**无指定目标的通用扰动：**在被错误分类的集合中寻找一个通用扰动，并且保证正确分类的数据不被影响。<br>
<img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/loss-latk.png" alt="latk损失函数公式"><br>
上式确保扰动会改变 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>k</mi><mo>−</mo></mrow></msub></mrow><annotation encoding="application/x-tex">D_{k-}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 的分类预测，下式会确保不改变原有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">D_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的分类预测。<br>
<img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/loss-latk%5E.png" alt="latk损失函数公式"></p>
<p>**有指向目标的每个图像的扰动：**如果标签 <code>k</code> 是后门攻击的目标标签，我们假设 将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>k</mi><mo>−</mo></mrow></msub></mrow><annotation encoding="application/x-tex">D_{k-}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span> 中的每个图像向 目标类 <code>k</code> 扰动，可以像式(2)中的通用对抗样本一样，他们通过类似的后门使得标签发生改变。<br>
由于后门的存在，因此通用扰动 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>u</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">u^{(k)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 和有目标分类图像扰动 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">s^{(k,i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span> 应该在欺骗模型误分类方面非常相似。</p>
<p>所以通过衡量两个扰动之间的相似程度来判断是否存在后门。</p>
<h2 id="DF-TND：无数据访问的后门网络检测">DF-TND：无数据访问的后门网络检测</h2>
<p>通过调查 logits 输出相对于 xi 和 x^i(p(i)) 的变化来检测模型是否是 TrojanNet。<br>
<img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/lk.png" alt="lk公式"></p>
<h2 id="实验效果">实验效果</h2>
<p><img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/res1.png" alt="有限数据实验结果"><br>
<img src="/2022/04/08/Practical-Detection-of-Trojan-Neural-Networks-Data-Limited-and-Data-Free-Cases/res2.png" alt="随机数据实验结果"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>后门植入检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy and Robustness in Federated Learning: Attacks and Defenses</title>
    <url>/2022/05/07/Privacy-and-Robustness-in-Federated-Learning-Attacks-and-Defenses/</url>
    <content><![CDATA[<p>Privacy and Robustness in Federated Learning: Attacks and Defenses abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>传统的中心式的机器学习方法无法有效处理隐私问题，联邦学习作为一种替代方案近年来得到发展。但是隐私问题并没有得到根本的解决，因此本文针对联邦学习面对的攻击和对应的防御手段对近5年的研究做出综述。</p>
<h2 id="Introduction">Introduction</h2>
<h4 id="根据分布式情况对联邦学习分类">根据分布式情况对联邦学习分类</h4>
<ul>
<li>Horizontally federated learning, HFL
<ul>
<li>HFL to business, H2B</li>
<li>HFL to consumers, H2C</li>
</ul>
</li>
<li>Vertically federated learning, VFL</li>
<li>Federated transfer learning, FTL</li>
</ul>
<h4 id="根据架构情况对联邦学习分类">根据架构情况对联邦学习分类</h4>
<ul>
<li>FL with Homogeneous Architectures</li>
<li>FL with Heterogeneous Architectures</li>
</ul>
<h4 id="联邦学习面临的威胁">联邦学习面临的威胁</h4>
<p>面临的威胁主要来自两个方面：</p>
<ul>
<li>malicious server</li>
<li>adversarial participant</li>
</ul>
<p><img src="/2022/05/07/Privacy-and-Robustness-in-Federated-Learning-Attacks-and-Defenses/malicious-part.png" alt="threat"></p>
<p>面临的主要攻击是：</p>
<ul>
<li>data poisoning</li>
<li>model poisoning</li>
</ul>
<p><img src="/2022/05/07/Privacy-and-Robustness-in-Federated-Learning-Attacks-and-Defenses/attacks.png" alt="attack"></p>
<h2 id="Threat-Model">Threat Model</h2>
<p>从几个侧面对攻击者进行归类:</p>
<ul>
<li>Insider vs Outsider</li>
<li>Training phase vs Inference phase</li>
<li>Privacy: semi-honest vs malicious</li>
<li>Robustnetss: untargeted vs targeted</li>
</ul>
<h2 id="Privacy-Attacks">Privacy Attacks</h2>
<p><img src="/2022/05/07/Privacy-and-Robustness-in-Federated-Learning-Attacks-and-Defenses/privacy-attack.png" alt="attack"></p>
<p>针对隐私的攻击有：</p>
<ul>
<li>Inferring Class Representatives</li>
<li>Inferring Membership</li>
<li>Inferring Properties</li>
<li>Inferring Training Inputs and Labels</li>
</ul>
<h2 id="Defences-against-privacy-attacks">Defences against privacy attacks</h2>
<ul>
<li>Homomorphic Encryption</li>
<li>Secure Multiparty Computation, SMC</li>
<li>Differential Privacy</li>
</ul>
<h2 id="Poisoning-attacks">Poisoning attacks</h2>
<p><img src="/2022/05/07/Privacy-and-Robustness-in-Federated-Learning-Attacks-and-Defenses/poison-attack.png" alt="attack"></p>
<p>投毒攻击有：</p>
<ul>
<li>Untargeted, 无针对目标，旨在损害模型准确率和性能</li>
<li>Targeted，有目标的，如后门攻击</li>
</ul>
<h2 id="Defences-against-poisoning-attacks">Defences against poisoning attacks</h2>
<p><img src="/2022/05/07/Privacy-and-Robustness-in-Federated-Learning-Attacks-and-Defenses/defences-poison.png" alt="defences"></p>
<h2 id="Discussion-and-Promising-Direction">Discussion and Promising Direction</h2>
<ul>
<li>Curse of Dimensionality</li>
<li>Rethinking Current Privacy Attacks</li>
<li>Rethinking Current Defences</li>
<li>Optimizing Defence Mechanism Deployment</li>
<li>Test-phase Privacy in FL</li>
<li>Test-phase Roubustness in FL</li>
<li>Relationship with GDPR</li>
<li>Threats and Protection of VFL and FTL</li>
<li>Vulnerabilities to Free-riding Participants</li>
<li>More Possibilities in FL with Heterogeneous Architectures</li>
<li>Decentralized FL</li>
<li>Efficient FL with Single Round Communication</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>robustness</tag>
        <tag>Federated Learning</tag>
        <tag>privacy</tag>
      </tags>
  </entry>
  <entry>
    <title>ProPatrol: Attack Investigation via Extracted High-Level Tasks</title>
    <url>/2022/04/19/ProPatrol-Attack-Investigation-via-Extracted-High-Level-Tasks/</url>
    <content><![CDATA[<p>ProPatrol: Attack Investigation via Extracted High-Level Tasks abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>内核审计日志是对网络攻击进行取证调查的宝贵信息来源。然而，审计日志中粗粒度的依赖信息会导致构建的攻击图包含错误或者规模过大。<br>
为了解决这个问题，提出本方法。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/19/ProPatrol-Attack-Investigation-via-Extracted-High-Level-Tasks/arch.png" alt="arch"></p>
<p>为了解决这个问题，作者提出了一个系统 PROPATROL，该系统里使用了在安全敏感环境中使用的企业应用程序系列中的开放式分区设计。<br>
本方法的优点是，不依赖源代码或者二进制指令，而仅需要应用结构的先验知识即可开展分析。<br>
一言以蔽之，该系统就是要将大量的系统执行划分成彼此独立的应用/进程执行。</p>
<h2 id="思路和实现">思路和实现</h2>
<p>学习了一个模型将溯源信息输出到活动的执行单元，一个执行单元就是应用程序的一部分，它处理作为用户活动的输入或者一组输入。</p>
<h3 id="基于规则的活动执行单元识别">基于规则的活动执行单元识别</h3>
<p><img src="/2022/04/19/ProPatrol-Attack-Investigation-via-Extracted-High-Level-Tasks/rules.png" alt="rules"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击调查</tag>
      </tags>
  </entry>
  <entry>
    <title>ProTracer: Towards Practical Provenance Tracing by Alternating Between Logging and Tainting</title>
    <url>/2022/04/14/ProTracer-Towards-Practical-Provenance-Tracing-by-Alternating-Between-Logging-and-Tainting/</url>
    <content><![CDATA[<p>ProTracer: Towards Practical Provenance Tracing by Alternating Between Logging and Tainting abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>现有的溯源分析方法要么遭受依赖爆炸问题，要么要求巨大的空间和运行时开销，这阻碍了他们在实践中的应用。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/14/ProTracer-Towards-Practical-Provenance-Tracing-by-Alternating-Between-Logging-and-Tainting/arch.png" alt="arch"></p>
<p>提出 ProTracer，一个轻量级的溯源跟踪系统，可以在系统事件日志记录和单元级污染传播之间交替。<br>
该技术建立在动态系统事件处理的基础架构上，该基础架构具有非常轻量级的内核模块和处理并发、无序事件处理的复杂用户空间守护程序。</p>
<p>溯源分析的基本方法：</p>
<p><img src="/2022/04/14/ProTracer-Towards-Practical-Provenance-Tracing-by-Alternating-Between-Logging-and-Tainting/eg-1.png" alt="arch"></p>
<p>Audit 架构：</p>
<p><img src="/2022/04/14/ProTracer-Towards-Practical-Provenance-Tracing-by-Alternating-Between-Logging-and-Tainting/audit.png" alt="arch"></p>
<p>系统主要分为两个部分：内核模块用户空间守护进程，其中内核模块负责采集 syscall 事件信息并把它们写入到 ring buffer，用户空间守护进程负责获取和处理这些事件，包括决定是否记录事件或者执行污点传播。</p>
<p><img src="/2022/04/14/ProTracer-Towards-Practical-Provenance-Tracing-by-Alternating-Between-Logging-and-Tainting/illustration.png" alt="arch"><br>
<img src="/2022/04/14/ProTracer-Towards-Practical-Provenance-Tracing-by-Alternating-Between-Logging-and-Tainting/eg-2.png" alt="arch"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源分析</tag>
      </tags>
  </entry>
  <entry>
    <title>RATSCOPE: Recording and Reconstructing Missing RAT Semantic Behaviors for Forensic Analysis on Windows</title>
    <url>/2022/04/07/RATSCOPE-Recording-and-Reconstructing-Missing-RAT-Semantic-Behaviors-for-Forensic-Analysis-on-Windows/</url>
    <content><![CDATA[<p>RATSCOPE: Recording and Reconstructing Missing RAT Semantic Behaviors for Forensic Analysis on Windows abstract。</p>
<span id="more"></span>
<h2 id="Main-Contribution">Main Contribution</h2>
<ul>
<li>53个真实世界中的RAT家族研究</li>
<li>提出针对RAT的取证工具</li>
<li>针对RAT建模行为系统模块</li>
</ul>
<h2 id="Large-study-of-Real-world-RATs">Large-study of Real-world RATs</h2>
<h3 id="workflow">workflow</h3>
<p>RAT 包括两个重要的组成部分：</p>
<ul>
<li>RAT stub，受控端，在受害者主机上执行</li>
<li>RAT controller，控制端，在攻击者主机上远程控制受害者主机</li>
</ul>
<h3 id="收集到的-RAT-样本">收集到的 RAT 样本</h3>
<p><img src="/2022/04/07/RATSCOPE-Recording-and-Reconstructing-Missing-RAT-Semantic-Behaviors-for-Forensic-Analysis-on-Windows/rats-list.png" alt="RAT 样本表格"></p>
<h3 id="关于-RAT-的主要发现">关于 RAT 的主要发现</h3>
<ul>
<li>通常使用高级编程语言实现 RAT stubs，如C++，Delphi 和 Java</li>
<li>RATs 通常装备了非常多恶意功能，如键盘记录，屏幕录制，远程控制等</li>
<li>不同的 RAT 家族通常装备了相同的恶意功能</li>
<li>90% 的 RATs 只针对 WINDOWS 系统</li>
</ul>
<h2 id="系统设计">系统设计</h2>
<p><img src="/2022/04/07/RATSCOPE-Recording-and-Reconstructing-Missing-RAT-Semantic-Behaviors-for-Forensic-Analysis-on-Windows/arch.png" alt="系统架构"><br>
整个过程分为三个阶段：</p>
<ul>
<li>离线训练，通过正负样本对 RAT 的 phfs 进行建模，阐述了语义爆炸问题，并且提出了新的行为图模型来解决该问题(Agregated API Tree Record Graph, AATR)</li>
<li>在线记录</li>
<li>审计分析，AATR graph matcher 使用在线采集的数据和离线生成的 AATR 图进行 PHF 识别</li>
</ul>
<h3 id="AATR-解决的问题">AATR 解决的问题</h3>
<p>ETW 不为包括系统调用和 API 在内的任何低级数据提供输入参数，这会导致行为图模型方法出现严重的语义冲突问题。<br>
为了解决这个问题，提出 Aggregated API Tree Record Graph.</p>
<h3 id="语义冲突">语义冲突</h3>
<p><img src="/2022/04/07/RATSCOPE-Recording-and-Reconstructing-Missing-RAT-Semantic-Behaviors-for-Forensic-Analysis-on-Windows/semantic-collision.png" alt="语义冲突"></p>
<p>语义冲突是指在丢失底层信息的情况下，两种不同的应用行为表现为相同的语义图。</p>
<h3 id="通过-AATR-避免语义冲突">通过 AATR 避免语义冲突</h3>
<ul>
<li>使用系统调用 System call 来进行通用程序行为建模</li>
<li>使用调用树来补足缺失的语义</li>
<li>调用树可以方便地重建，因为系统调用属性和对应的触发 API 在 ETW 中是相邻的</li>
</ul>
<h3 id="基于-ETW-的审计记录系统">基于 ETW 的审计记录系统</h3>
<p>ETW 是 Windows 自带的审计记录系统，包括两个部分，一个记录器，一个解析器。并且还拥有两个重要的特点，不需要附加工具和负载低。</p>
<p>但是 ETW 也存在着缺点：</p>
<ul>
<li>效率问题，在处理大量事件的时候效率地</li>
<li>数据缺失问题，缺少重要的信息，如进程id等</li>
</ul>
<p>因此本文提出了方案改进了 ETW：</p>
<ul>
<li>过滤器，过滤特定应用的事件，识别，并且专注于对于审计有用的事件</li>
<li>语义恢复，补足进程id等重要的缺失信息</li>
</ul>
<h3 id="AATR-graph-generator">AATR graph generator</h3>
<p>问题：底层数据存在严重的数据冗余问题<br>
方案：去冗余算法</p>
<h3 id="AATR-graph-matcher">AATR graph matcher</h3>
<p>问题：底层数据存在噪声<br>
方案：最优部分图匹配方法，区别与确切匹配，具有一定的容错能力</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源采集工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Robust Estimators in High Dimensions without the Computational Intractability</title>
    <url>/2022/04/23/Robust-Estimators-in-High-Dimensions-without-the-Computational-Intractability/</url>
    <content><![CDATA[<p>Robust Estimators in High Dimensions without the Computational Intractability abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>本文研究在不可知环境中高维分布学习，其中允许攻击者任意破坏样本的 epsilon-fraction.<br>
即使在最基本的设置中，唯一已知的方法要么在计算上效率低下，要么因为误差保证中丢失了维度相关的因素。<br>
因此提出以下问题：高维不可知分布学习在算法上是否可行？</p>
<h2 id="本文工作">本文工作</h2>
<p>在本文的工作中，我们获得了第一个具有与维度无关的误差保证的高效计算算法，用于不可知地学习基本类的高维分布：</p>
<ul>
<li>单个高斯分布</li>
<li>超立方体上的乘积分布</li>
<li>两种乘积分布的混合（自然平衡条件下</li>
<li>球形高斯分布</li>
</ul>
<p>并且提出了三个算法：</p>
<ul>
<li>贪婪迭代算法，每次迭代过滤一些损坏的样本，通过计算修改后的样本协方差矩阵的最高绝对特征值来获得过滤器</li>
<li>依赖凸编程的算法，为样本计算适当的权重，通过近似分离预言来进行异常值鉴别</li>
<li>标准评估器：经验平均值 empirical average， 可能无法正确评估去掉了 epsilon-fraction 的异常样本，所以提出了新的浓缩边界</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>异常值检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Robust Learning-Enabled Intelligence for the Internet of Things: A Survey From the Perspectives of Noisy Data and Adversarial Examples</title>
    <url>/2022/04/11/Robust-Learning-Enabled-Intelligence-for-the-Internet-of-Things-A-Survey-From-the-Perspectives-of-Noisy-Data-and-Adversarial-Examples/</url>
    <content><![CDATA[<p>Robust Learning-Enabled Intelligence for the Internet of Things: A Survey From the Perspectives of Noisy Data and Adversarial Examples 综述abstract。</p>
<span id="more"></span>
<h2 id="abstract">abstract</h2>
<p><img src="/2022/04/11/Robust-Learning-Enabled-Intelligence-for-the-Internet-of-Things-A-Survey-From-the-Perspectives-of-Noisy-Data-and-Adversarial-Examples/ai-in-iot.png" alt="ai in iot"><br>
本文将讲究能够实现 iot 智能的高可靠性和高 resilience 的 robust 机器学习模型最新技术和代表性作品。<br>
将会关注鲁棒性的两个方面：</p>
<ul>
<li>机器学习模型训练数据包含噪声和恶意样本时的训练</li>
<li>神经网络和强化学习框架的可靠性</li>
</ul>
<p>对于数据去噪来说，现有工作主要从两个方面出发：</p>
<ul>
<li>对数据预处理，进行去噪和缺值补充</li>
<li>对模型加强，训练可以处理噪声和缺值的鲁棒性模型</li>
</ul>
<h2 id="AI-驱动的-iot-边缘计算和鲁棒性对-iot-应用的影响">AI 驱动的 iot 边缘计算和鲁棒性对 iot 应用的影响</h2>
<p>在这里给出了两个场景：</p>
<ul>
<li>噪声数据，由于设备或者人为故障产生的噪声数据和由于隐私等问题产生的缺值数据</li>
<li>对抗样本，攻击者投毒的恶意攻击样本<br>
其中关于数据补全或者异常值取出的研究如下：<br>
<img src="/2022/04/11/Robust-Learning-Enabled-Intelligence-for-the-Internet-of-Things-A-Survey-From-the-Perspectives-of-Noisy-Data-and-Adversarial-Examples/research1.png" alt="research list"></li>
</ul>
<h2 id="对抗样本的-robust-学习和机器学习模型的可靠性">对抗样本的 robust 学习和机器学习模型的可靠性</h2>
<h3 id="神经网络可靠性">神经网络可靠性</h3>
<p><img src="/2022/04/11/Robust-Learning-Enabled-Intelligence-for-the-Internet-of-Things-A-Survey-From-the-Perspectives-of-Noisy-Data-and-Adversarial-Examples/research2.png" alt="research list"></p>
<p>文章提出的模型可靠性的研究方向：</p>
<ul>
<li>learing with reject option，如下图，意为通过更大的测试集来训练一个稳定的子集，具体方法有 GAN 等，属于 How，如何获得一个健壮的模型</li>
<li>model understanding through subspace explanations (MUSEs)，通过子空间解释来理解模型，提高模型健壮性，属于 What，模型内部是怎样运作的，什么是健壮的模型，探究原理</li>
<li>tackling the reliability issues of DNNs from the perspective of software testing，从软件测试角度处理模型可靠性问题，单就软件测试的方式来看，属于 What，测试模型是否健壮</li>
<li>transfer learning，迁移学习主要应用在序列任务，在人机交互接口的应用中给出顺序执行的可解释性<br>
<img src="/2022/04/11/Robust-Learning-Enabled-Intelligence-for-the-Internet-of-Things-A-Survey-From-the-Perspectives-of-Noisy-Data-and-Adversarial-Examples/lwro.png" alt="learning with reject option"></li>
</ul>
<h3 id="神经网络可靠性评估">神经网络可靠性评估</h3>
<p>模型校准也广泛用于衡量模型预测的结果概率与这些结果的真实概率。</p>
<ul>
<li>Nixon 等人确定并检查了深度学习中模型校准的挑战，当前的校准指标无法考虑机器学习模型所做的所有预测，并且在估计校准误差方面效率低下，提出了几个新的校准指标，静态校准误差（static calibration error, SCE）、自适应校准误差（adaptive calibration error, ACE）、阈值ACE（thresholded ACE, TACE）</li>
<li>另外，有人提出了一种定量指标来评估神经网络的内在鲁棒性，该方法基于模型预测的最大 Kullback-Leibler(KL) 散度，也就是计算了 原始输入的两个预测 和 一定范围内扰动的对抗输入 之间的差异。该方法可以计算模型在一定约束条件下的上边界，衡量模型是否能够稳定输出预测结果</li>
</ul>
<h3 id="强化学习的可靠性">强化学习的可靠性</h3>
<p><img src="/2022/04/11/Robust-Learning-Enabled-Intelligence-for-the-Internet-of-Things-A-Survey-From-the-Perspectives-of-Noisy-Data-and-Adversarial-Examples/research3.png" alt="research list"></p>
<h3 id="强化学习可靠性评估">强化学习可靠性评估</h3>
<ul>
<li>强化学习持续控制测试框架，实现了9个持续控制强化学习算法，并且进行了测试</li>
<li>Henderson 等人专注于分析用于连续控制的 RL 的几种无模型策略梯度算法的可靠性</li>
<li>一组在不同方面可以定量测量可靠性的指标</li>
</ul>
<h2 id="研究挑战和公开话题">研究挑战和公开话题</h2>
<ul>
<li><strong>神经网络结构(structure of neural network)</strong>:通常神经网络设计不考虑输出结果的可靠性，在网络结构中添加一层评估结果可靠性的方法是可取的，而如何设计这样的层以及如何保持不进入复杂开销是具有挑战性的</li>
<li><strong>模型可解释性(interpretability of black-box learning models)</strong>:导致可靠性问题的重要原因就是模型不具有可解释性，这也是 ai 的一大难题，如何有效提升模型可解释性与有人参与的决策的网络，仍然是一个很难的研究问题</li>
<li><strong>鲁棒性测试(robust testing)</strong>:现阶段还没有一个系统的测试框架来支撑模型输入输出自动化评估和对应的错误行为检测</li>
<li><strong>可靠性评估(measuring reliability)</strong>:在模型可靠性评估方面，潜在的研究方向有：如何表征模型不同部分对于可靠性的重要性，如何设计一个可以跨场景使用的统一标准</li>
<li><strong>基于模型的强化学习(model-based RL)</strong>:如何保证基于模型的强化学习模型的可靠性和安全性仍然是一个悬而未决的问题</li>
<li><strong>0day漏洞(zero-day vulnerability)</strong>:如何及时有效检测和缓解0day漏洞依然是一个问题，一些有希望的方案可以解决这个重要问题：pang 提出了新的训练步骤和阈值来检测。然后对于真实世界中的攻击仍然还有距离。</li>
<li><strong>强化学习中的伦理问题(ethic in RL)</strong></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>针对含沙的数据
<ul>
<li>缺值填补</li>
<li>训练可处理异常值的模型</li>
</ul>
</li>
<li>如何获得鲁棒性的模型（how）
<ul>
<li>添加对抗样本作为训练数据</li>
<li>添加鲁棒层</li>
<li>……</li>
</ul>
</li>
<li>模型是否具有鲁棒性（鲁棒性评估，what）
<ul>
<li>模型自身鲁棒性</li>
<li>对抗攻击时鲁棒性表现</li>
</ul>
</li>
<li>模型是否可解释，因为可解释了就可以分析其鲁棒性（why）</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>robustness</tag>
        <tag>iot</tag>
      </tags>
  </entry>
  <entry>
    <title>SEAL: Storage-efficient Causality Analysis on Enterprise Logs with Query-friendly Compression</title>
    <url>/2022/04/19/SEAL-Storage-efficient-Causality-Analysis-on-Enterprise-Logs-with-Query-friendly-Compression/</url>
    <content><![CDATA[<p>SEAL: Storage-efficient Causality Analysis on Enterprise Logs with Query-friendly Compression abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>因果分析使攻击取证自动化，并通过关联因果相关但在时间上遥远的系统时间来寸进行为检测。<br>
尽管该方法是有效的，但是该分析在存储和处理大量系统事件方面存在固有的大数据挑战，这些系统事件是从现实网络中数十万终端主机不断收集的。</p>
<p>此外，安全漏洞的分析有效性依赖于存储长期综合历史事件的假设，因此，为了使因果关系分析实用并适用于企业环境，解决扩展性（scalability）的问题迫在眉睫。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/19/SEAL-Storage-efficient-Causality-Analysis-on-Enterprise-Logs-with-Query-friendly-Compression/arch.png" alt="arch"></p>
<p>因此提出了 SEAT，一种新的应用于因果分析的数据压缩方法。基于对系统时间数据的信息论观察，我们的方法实现了无损压缩并支持对历史事件的近实时检索。</p>
<p>在压缩阶段，研究了由系统日志引起的因果图，并探索了丰富的边缘减少的可能方法。</p>
<p>在查询阶段，最大速率下解压缩是有可能执行的，实验表明 SEAL 在真实数据集上分别提供了 2.63 倍和 12.94 倍的数据压缩。并且 89% 的压缩数据集上的查询比不压缩数据集上要快，二者返回了相同的结果。</p>
<h2 id="思路与实现">思路与实现</h2>
<p>LogGC、NodeMerge和本方法SEAL的比较：</p>
<p><img src="/2022/04/19/SEAL-Storage-efficient-Causality-Analysis-on-Enterprise-Logs-with-Query-friendly-Compression/eg-cmp.png" alt="graph cmp"></p>
<p>一个溯源图精简的实例：</p>
<p><img src="/2022/04/19/SEAL-Storage-efficient-Causality-Analysis-on-Enterprise-Logs-with-Query-friendly-Compression/eg-proc.png" alt="eg process"></p>
<h3 id="查询友好的压缩算法-Query-friendly-Compression-QFC">查询友好的压缩算法 Query-friendly Compression, QFC</h3>
<p>对数据进行了图结构压缩和边属性压缩，具体压缩算法如下：</p>
<p><img src="/2022/04/19/SEAL-Storage-efficient-Causality-Analysis-on-Enterprise-Logs-with-Query-friendly-Compression/algo-gsc.png" alt="algo"></p>
<p>边属性压缩案例：</p>
<p><img src="/2022/04/19/SEAL-Storage-efficient-Causality-Analysis-on-Enterprise-Logs-with-Query-friendly-Compression/eg-edgec.png" alt="edge compression"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>因果分析</tag>
      </tags>
  </entry>
  <entry>
    <title>SAQL: A Stream-based Query System for Real-Time Abnormal System Behavior Detection</title>
    <url>/2022/04/13/SAQL-A-Stream-based-Query-System-for-Real-Time-Abnormal-System-Behavior-Detection/</url>
    <content><![CDATA[<p>Saql: A Stream-based Query System for Real-Time Abnormal System Behavior Detection abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>APT 攻击 emerging，针对系统活动的监控成为了一种解决方案，但是阻止攻击者造成深层次的损害是一个时间敏感的任务，现有的方案无法在可接受时间内大规模的溯源数据上进行基于专家知识的异常检测。</p>
<p>因此提出本方案解决该问题。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/13/SAQL-A-Stream-based-Query-System-for-Real-Time-Abnormal-System-Behavior-Detection/arch.png" alt="arch"></p>
<p>本文提出的是一种新型的基于流的查询系统，该系统将企业中多个主机聚合的实时事件源作为输入，并且提供异常查询引擎，该引擎查询事件源根据特定异常活动来识别异常行为。</p>
<p>为了促进基于专家知识的异常表达任务，系统提供了一种特定的查询语言 SAQL，给分析人员提供了：</p>
<ul>
<li>基于规则的异常检测</li>
<li>基于事件序列的异常检测</li>
<li>基于异常值的异常检测</li>
</ul>
<p><img src="/2022/04/13/SAQL-A-Stream-based-Query-System-for-Real-Time-Abnormal-System-Behavior-Detection/query1.png" alt="query"><br>
<img src="/2022/04/13/SAQL-A-Stream-based-Query-System-for-Real-Time-Abnormal-System-Behavior-Detection/query2.png" alt="query"><br>
<img src="/2022/04/13/SAQL-A-Stream-based-Query-System-for-Real-Time-Abnormal-System-Behavior-Detection/query3.png" alt="query"><br>
<img src="/2022/04/13/SAQL-A-Stream-based-Query-System-for-Real-Time-Abnormal-System-Behavior-Detection/query4.png" alt="query"></p>
<h3 id="SAQL语言设计">SAQL语言设计</h3>
<h4 id="多事件特征匹配">多事件特征匹配</h4>
<ul>
<li>全局限制</li>
<li>事件特征</li>
<li>滑动窗口</li>
<li>事件时间关系</li>
<li>事件属性关系</li>
</ul>
<h4 id="状态计算">状态计算</h4>
<ul>
<li>状态块</li>
<li>状态变量</li>
<li>状态集群</li>
</ul>
<h4 id="告警条件检查">告警条件检查</h4>
<h4 id="返回和过滤">返回和过滤</h4>
<h3 id="SAQL-执行引擎">SAQL 执行引擎</h3>
<h4 id="查询执行引擎">查询执行引擎</h4>
<h4 id="并发查询引擎">并发查询引擎</h4>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源分析管理平台</tag>
      </tags>
  </entry>
  <entry>
    <title>SLEUTH: Real-time Attack Scenario Reconstruction from COTS Audit Data</title>
    <url>/2022/04/06/SLEUTH-Real-time-Attack-Scenario-Reconstruction-from-COTS-Audit-Data/</url>
    <content><![CDATA[<p>SLEUTH: Real-time Attack Scenario Reconstruction from COTS Audit Data abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>安全人员很难从传统的 ISD/SIEM 工具中大量的告警信息中快速有效提取出实际攻击场景。<br>
因此本文设计了一种基于标签的攻击分析技术实时生成攻击场景。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/06/SLEUTH-Real-time-Attack-Scenario-Reconstruction-from-COTS-Audit-Data/arch.png" alt="架构图"><br>
整体系统架构大致分为溯源信息采集、图生成、基于图的分析和攻击场景重现四个部分：</p>
<ul>
<li>溯源信息采集</li>
<li>图生成</li>
<li>基于图的分析</li>
<li>攻击场景重现</li>
</ul>
<h2 id="挑战">挑战</h2>
<p>本文需要实时对攻击告警进行检测、分析和重现攻击场景，由此对以下地方提出了更高的要求：</p>
<ul>
<li>事件存储和分析</li>
<li>事件实体优先级</li>
<li>场景重建</li>
<li>处理攻击期间的正常活动</li>
<li>快速、交互式的推理能力</li>
</ul>
<h2 id="主存内的依赖图设计">主存内的依赖图设计</h2>
<p>为了尽量降低内存占用，通过多种方法降低内存的使用：</p>
<ul>
<li>存储数据结构</li>
<li>指针</li>
<li>相对时间戳</li>
<li>etc.</li>
</ul>
<h2 id="标签和攻击检测">标签和攻击检测</h2>
<p>标签分为两类，机密性标签和可信度标签，其中可信度标签有：</p>
<ul>
<li>Benign authentic</li>
<li>Benign</li>
<li>Unknown</li>
</ul>
<p>机密性标签分为：</p>
<ul>
<li>Secret</li>
<li>Sensitive</li>
<li>Private</li>
<li>Public</li>
</ul>
<p>对于进程来说，拥有两种标签，但是对于数据来说只有机密性标签。<br>
针对不同的实体采用不同的策略获得其标签：</p>
<ul>
<li>已经存在的或远程实体 -&gt; 初始化策略（tag initialization policies）</li>
<li>系统运行期间新建的 -&gt; 标签传递策略（tag propagation policies）</li>
<li>攻击 -&gt; 检测策略（detection policies）</li>
<li>其余没有特定标记策略指定的源将会被标记为 <code>Unknown</code>，没有特定传播策略指定的实体将会采用默认策略</li>
</ul>
<h3 id="基于标签的攻击检测">基于标签的攻击检测</h3>
<p>根据攻击行为的一般步骤：</p>
<ul>
<li>部署攻击者的代码到目标系统</li>
<li>替换或者修改重要文件</li>
<li>泄漏敏感信息</li>
</ul>
<p>定义了以下攻击者目标和手段的攻击检测策略：</p>
<ul>
<li>非信任的代码执行，Untrusted code execution</li>
<li>低信任度代码修改，Modification by subjects with lower code t-tag</li>
<li>机密信息泄漏，Confidential data leak</li>
<li>非信任数据执行准备，Preparation of untrusted data for execution</li>
</ul>
<p>这种检测方法的优点是不会被中间步骤稀释，不管当数据经过多少次中间步骤，最终执行时均能出发报警。并且该方法还可以和外部的检测器配合，如果外部检测器将一个实体标记为可以，在本系统中该实体将会被标记为 <code>Unknown</code>，然后检测策略将会根据该信息进行推理验证。</p>
<h2 id="策略框架">策略框架</h2>
<p>此部分介绍了本文的策略框架，详见论文第4章。</p>
<h2 id="基于标签的双向分析">基于标签的双向分析</h2>
<h3 id="反向分析">反向分析</h3>
<p>反响分析的目的是寻找攻击者入口节点，分析的起点是检测策略生成的告警。</p>
<h3 id="前向分析">前向分析</h3>
<p>前向分析的目的是评估攻击行动的危害。</p>
<h3 id="场景重建">场景重建</h3>
<p>通过剪枝、合并等操作生成一个简化后的攻击场景。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源采集工具</tag>
      </tags>
  </entry>
  <entry>
    <title>STATEFUL DETECTION OF MODEL EXTRACTION ATTACKS</title>
    <url>/2022/04/09/STATEFUL-DETECTION-OF-MODEL-EXTRACTION-ATTACKS/</url>
    <content><![CDATA[<p>STATEFUL DETECTION OF MODEL EXTRACTION ATTACKS abstract。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/09/STATEFUL-DETECTION-OF-MODEL-EXTRACTION-ATTACKS/arch.png" alt="模型检测架构图"><br>
文章提出了 VarDetect 来检测模型萃取攻击，相比现有的工作有以下优点：</p>
<ul>
<li>可以成功分出三种不同的攻击，该模型将攻击分为三类</li>
<li>VarDetect 不需要访问攻击者数据</li>
<li>对两类自适应攻击也有效</li>
</ul>
<p><img src="/2022/04/09/STATEFUL-DETECTION-OF-MODEL-EXTRACTION-ATTACKS/varDetect.png" alt="varDetect架构图"><br>
具体检测步骤为：</p>
<ul>
<li>将输入的杨被送入编码器获取其参数分布</li>
<li>将参数排列获得嵌入向量</li>
<li>计算 MMD 判断是否为异常</li>
</ul>
<p>注：MMD 为 Maximum Mean Discrepancy 最大平均差异，现有研究成果表明，如果两个数据集分布相同，那么他们的 MMD 趋近于 0.</p>
<h3 id="具体算法">具体算法</h3>
<p><img src="/2022/04/09/STATEFUL-DETECTION-OF-MODEL-EXTRACTION-ATTACKS/algo.png" alt="算法"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>模型萃取攻击检测</tag>
      </tags>
  </entry>
  <entry>
    <title>SortPool:An End-to-End Deep Learning Architecture for Graph Classification</title>
    <url>/2022/03/29/SortPool-An-End-to-End-Deep-Learning-Architecture-for-Graph-Classification/</url>
    <content><![CDATA[<p>SortPool:An End-to-End Deep Learning Architecture for Graph Classification 读书笔记。</p>
<span id="more"></span>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/03/29/SortPool-An-End-to-End-Deep-Learning-Architecture-for-Graph-Classification/arch.png" alt="架构图"></p>
<h2 id="具体实现">具体实现</h2>
<h3 id="图卷积层">图卷积层</h3>
<p><img src="/2022/03/29/SortPool-An-End-to-End-Deep-Learning-Architecture-for-Graph-Classification/gcn.png" alt="公式"></p>
<p>图卷积可以分为四步：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">XW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>，线性变换</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mtext> </mtext></msup><mi>Y</mi></mrow><annotation encoding="application/x-tex">A^~ Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.363em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mspace nobreak mtight"><span class="mtight"> </span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>，<code>Y := XW</code>节点信息传播</li>
<li>正则化，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>D</mi><mrow><mi>i</mi><mi>i</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mi>X</mi><mi>W</mi></mrow><annotation encoding="application/x-tex">D^{-1}_{ii} XW</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1311em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8542em;"><span style="top:-2.4231em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ii</span></span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></li>
<li>逐点非线性激活函数 <code>f</code></li>
</ul>
<h3 id="SortPooling-层">SortPooling 层</h3>
<p>排序依据：根据节点在图中的结构化角色来进行排序。<br>
由文中证明可得，在图卷积层输出的正好是连续的WL颜色（continuous WL colors）。<br>
在 SortPooling layer，输入首先根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Z</mi><mi>h</mi></msup></mrow><annotation encoding="application/x-tex">Z^h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span>逐行排序，然后将输出作为节点最精炼的连续WL颜色，然后使用该颜色对节点进行排序。</p>
<h2 id="总结">总结</h2>
<p>本文提出的架构主要面向图分类任务。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>池化操作</tag>
        <tag>图卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Spectral Signatures in Backdoor Attacks</title>
    <url>/2022/08/24/Spectral-Signatures-in-Backdoor-Attacks/</url>
    <content><![CDATA[<p>Spectral Signatures in Backdoor Attacks abstract。</p>
<span id="more"></span>
<h2 id="Summary">Summary</h2>
<p>本文的贡献是证明了后门攻击的一个新的属性：频谱特征（spectral signature），具体来说，后门攻击会在频谱特征上留下可以被检测到的特征，通过该特征可以识别和过滤误标签输入。</p>
<p>还提供了一些关于后门相关的理解，为什么我们期望过参数化的神经网络会自然地嵌入后门，为什么这通常会导致后门攻击在频谱上留下特征。</p>
<h2 id="嵌入表示的频谱特征">嵌入表示的频谱特征</h2>
<p>我们频谱特征的概念来自于最近鲁棒性统计相关工具的启发。当给定标签的训练集中包含后门样本时，该标签的训练样本由两个子集组成。其中：</p>
<ul>
<li>大部分是干净的数据</li>
<li>小部分是误标签的后门样本</li>
</ul>
<p>鲁棒性统计攻击表明，如果两个子集的均值相对于总体的方差充分分离，则可以奇异值分解来检测和删除损坏的数据点。</p>
<p>一个简单的尝试是直接在数据输入向量上应用该工具，但是如下图所示，数据集中的高方差意味着总体没有足够分离，无法使这些方法发挥作用。</p>
<p><img src="/2022/08/24/Spectral-Signatures-in-Backdoor-Attacks/fig-1.png" alt="fig-1"></p>
<p>但同时，上图也显示，在表示特征层级，数据集中两个子集确实分离了。直观来说，分类器的任何特征表示都倾向于增强后门信号，因为后门本身就是分类的一个强有力的指标。因此，随着信号增强，后门样本与干净样本的区别越来越大。</p>
<p>所以可以使用鲁棒性统计工具来进行后门样本的检测和过滤。我们在实验中验证了这个想法，并且证明可以有效地进行训练数据集的后门样本过滤。</p>
<p>后续也详细描述了使用鲁棒性统计方法更强有力的保证是必要的，因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>l</mi><mn>2</mn></msub><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">l_2 norms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0197em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span> 等弱统计方法效果并不好。</p>
<p>另一条线是投毒攻击用来降低模型的泛化准确率，影响函数提供了一种可能的方式来检测攻击，但并不能直接应用于不会导致典型测试实例错误分类的后门攻击。</p>
<h2 id="基于频谱特征的后门样本检测方法">基于频谱特征的后门样本检测方法</h2>
<p><img src="/2022/08/24/Spectral-Signatures-in-Backdoor-Attacks/fig-3.png" alt="fig-3"></p>
<p><img src="/2022/08/24/Spectral-Signatures-in-Backdoor-Attacks/alg-1.png" alt="algo-1"></p>
<h2 id="实验结果">实验结果</h2>
<p><img src="/2022/08/24/Spectral-Signatures-in-Backdoor-Attacks/tab-2.png" alt="tab-2"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>AI Backdoor Attacks</tag>
      </tags>
  </entry>
  <entry>
    <title>This is WhyWe Can’t Cache Nice Things: Lightning-Fast Threat Hunting using Suspicion-Based Hierarchical Storage</title>
    <url>/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/</url>
    <content><![CDATA[<p>This is WhyWe Can’t Cache Nice Things: Lightning-Fast Threat Hunting using Suspicion-Based Hierarchical Storage abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>近来因果分析的方法可以加速事件反应，但是只是在因果图构建后才行。不幸的是现有的因果图生成技术主要是离线的，并且通常需要耗费很长的时间，给攻击者很大的时间窗口来擦除脚印获得持续访问并移动到其他机器。<br>
为了解决此问题，提出本文方法。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/arch.png" alt="arch"></p>
<p>为了解决上述问题，提出了 SWIFT，一个威胁攻击调查系统来提供高吞吐量的因果关系跟踪和实时因果图生成功能。</p>
<ul>
<li>设计了一个内存中的图形数据库，它能够以最少的磁盘操作实现空间高效的图形存储和在线因果图跟踪。</li>
<li>提出了一种分层存储系统，该系统将因果图的取证相关部分保存在主内存中，同时将其余部分存储在磁盘中。</li>
<li>为了在调查过程中识别相关的因果图，设计了一个异步缓存落盘策略，该策略计算因果图中最可疑的部分，并仅在主内存中缓存该部分。</li>
</ul>
<h2 id="威胁模型及假设">威胁模型及假设</h2>
<p><img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/hunting.png" alt="arch"><br>
<img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/eg-1.png" alt="arch"></p>
<h2 id="前提假设">前提假设</h2>
<p><img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/def-1.png" alt="arch"><br>
<img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/def-2.png" alt="arch"></p>
<h2 id="节点为中心的因果图">节点为中心的因果图</h2>
<h3 id="可疑因果路径">可疑因果路径</h3>
<p><img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/algo-1.png" alt="arch"><br>
<img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/eg-2.png" alt="arch"></p>
<h3 id="溯源缓存">溯源缓存</h3>
<p><img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/algo-2.png" alt="arch"></p>
<h3 id="可疑缓存">可疑缓存</h3>
<p><img src="/2022/04/14/This-is-WhyWe-Can%E2%80%99t-Cache-Nice-Things-Lightning-Fast-Threat-Hunting-using-Suspicion-Based-Hierarchical-Storage/algo-3.png" alt="arch"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源分析管理平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Security and privacy for 6G: A survey on prospective technologies and challenges</title>
    <url>/2022/06/22/Security-and-privacy-for-6G-A-survey-on-prospective-technologies-and-challenges/</url>
    <content><![CDATA[<p>Security and privacy for 6G: A survey on prospective technologies and challenges abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>本综述系统描述了6G技术在物理、链接和服务方面有关安全和隐私的问题，并且还描述了现有安全框架和最新技术的失败教训。<br>
两个主要经验是：</p>
<ul>
<li>6G存在新的攻击向量，特别是6G无线技术</li>
<li>物理层安全、人工智能安全等新技术是缓解攻击的重要手段</li>
</ul>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/06/22/Security-and-privacy-for-6G-A-survey-on-prospective-technologies-and-challenges/arch.png" alt="arch"></p>
<h2 id="AI’s-Impact-on-6G-Security">AI’s Impact on 6G Security</h2>
<h3 id="AI-as-guardian：-AI-for-enhancing-6G-security">AI as guardian： AI for enhancing 6G security</h3>
<p>结合 AI 可以提高传统的安全方法的有效性和处理复杂攻击的能力，同时 AI 也作为一项受欢迎的技术被应用到了提升系统性能的地方，包括但不限于下列领域：</p>
<ul>
<li>在维护信任网络中识别节点行为检测内部攻击者</li>
<li>预测网络攻击并且重定向流量，对网络变更做智能推荐和分离可疑服务</li>
<li>优化无线与计算控制策略</li>
<li>决定设备恢复优先级</li>
<li>审查流量/网络访问预测攻击事件，过滤恶意流量</li>
</ul>
<p>当然，应用 AI 也存在着各种挑战，例如：</p>
<ul>
<li>AI 成为攻击者目标，其脆弱性导致系统被破坏</li>
<li>AI 算力需求与实时性问题</li>
<li>AI 道德问题</li>
<li>AI 可能成为攻击者的武器的问题</li>
</ul>
<p><img src="/2022/06/22/Security-and-privacy-for-6G-A-survey-on-prospective-technologies-and-challenges/ai-solution.png" alt="ai-solution"></p>
<h3 id="AI-as-a-target-Security-attacks-against-6G-AI-empowered-engines-and-defense-appproaches">AI as a target: Security attacks against 6G AI-empowered engines and defense appproaches</h3>
<p>AI 很容易成为攻击者的目标， 下图展示了 AI-based 系统面临的主要攻击：</p>
<ul>
<li>data poisoning</li>
<li>algorithm poisoning</li>
<li>model poisoning</li>
</ul>
<p><img src="/2022/06/22/Security-and-privacy-for-6G-A-survey-on-prospective-technologies-and-challenges/main-attacks.png" alt="main_attack"></p>
<p>基本而言为了保护 AI-based 系统，主要有三种方法：</p>
<ul>
<li>提升数据质量，enhance data quality</li>
<li>模型保护，model protection</li>
<li>输出完整性恢复，output integrity restoration</li>
</ul>
<h3 id="AI-as-a-weapon-Ethical-AI-Superintelligent-AI-AI-Regulation">AI as a weapon: Ethical AI/Superintelligent AI/AI Regulation</h3>
<p>AI 可以被用作攻击武器已经成为大家的共识，攻击者可以利用 AI 系统攻击防御系统。<br>
FusionRipper可以公婆多传感器融合设计，并提出两个针对自动驾驶汽车的攻击， off-load and wrong-wau attack，FusionRipper包括两个部分：</p>
<ul>
<li>预测易受攻击的时间段</li>
<li>基于漏洞分析调度使用指数欺骗来接管漏洞</li>
</ul>
<p>FusionRipper给我们的启示是，攻击者现在可以利用 AI 技术发起更加复杂的攻击。</p>
<p>IBM 开发的 DeepLocker 可以通过正常应用来隐藏恶意软件等等。</p>
<h3 id="Summary-of-lessons-learned-from-AI’s-impact-on-6G-security">Summary of lessons learned from AI’s impact on 6G security</h3>
<p>AI 可以帮助提升现有技术的两个方面：</p>
<ul>
<li>系统检测性能，物理层通道状态评估的准确性、物理层认证</li>
<li>自动化，自动学习异常行为</li>
</ul>
<p>总的来说，可以从 AI 对 6G 的影响中学习到 3 个重要的经验教训：</p>
<ul>
<li>AI 并不是解决 6G 安全问题的万金油，有优点，也有其自身缺陷</li>
<li>AI 只能检测攻击的发生而不能说明攻击为何发生，也就是说明攻击发生的原理</li>
<li>AI 并不总是一个正面角色，也可能引入脆弱性或者被应用为攻击手段</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Survey</tag>
        <tag>6G</tag>
        <tag>安全与隐私</tag>
      </tags>
  </entry>
  <entry>
    <title>Threats, attacks and defenses to federated learning: issues, taxonomy and perspectives</title>
    <url>/2022/05/08/Threats-attacks-and-defenses-to-federated-learning-issues-taxonomy-and-perspectives/</url>
    <content><![CDATA[<p>Threats, attacks and defenses to federated learning: issues, taxonomy and perspectives abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>前人工作只综述了训练阶段联邦学习面临的问题，本文总结了联邦学习整个生命周期面临的问题。</p>
<h2 id="联邦学习全周期流程">联邦学习全周期流程</h2>
<p><img src="/2022/05/08/Threats-attacks-and-defenses-to-federated-learning-issues-taxonomy-and-perspectives/phases.png" alt="phases"><br>
联邦学习被分为三个方面：</p>
<ul>
<li>数据和行为审计阶段</li>
<li>训练阶段</li>
<li>预测阶段</li>
</ul>
<h2 id="数据和行为审计阶段">数据和行为审计阶段</h2>
<p>因为 local worker 对数据有着完全的控制权，所以是的数据质量审计和历史行为审计很难开展。被随意篡改的数据可以危害模型的性能表现甚至植入后门等。<br>
由于联邦学习的分布特性，并且数据在各个节点设备上，导致很难对其开展数据质量评估（the Data Quality Assessment）。<br>
其他方法则是针对历史行为展开分析。</p>
<h2 id="训练阶段">训练阶段</h2>
<p>训练阶段会遭受投毒攻击、隐私推断攻击等。</p>
<h3 id="Privacy-leakage">Privacy leakage</h3>
<p>导致隐私推断攻击的主要原因有：</p>
<ul>
<li>嵌入层的泄漏</li>
<li>全连接层的泄漏</li>
<li>模型梯度的泄漏</li>
</ul>
<p>具体攻击有：</p>
<ul>
<li>Membership inference attacks</li>
<li>Class represntative inference attacks</li>
<li>Propertiy inference attacks</li>
<li>Data reconstruction attacks</li>
</ul>
<p><img src="/2022/05/08/Threats-attacks-and-defenses-to-federated-learning-issues-taxonomy-and-perspectives/privacy-infer.png" alt="Threat model of privacy inference"><br>
<img src="/2022/05/08/Threats-attacks-and-defenses-to-federated-learning-issues-taxonomy-and-perspectives/pi-in-fl.png" alt="Privacy inference attacks against FL"></p>
<h3 id="Poisoning-attacks">Poisoning attacks</h3>
<p>投毒攻击大致可以分为数据投毒和模型投毒两类。<br>
现有针对投毒攻击的防御方法大致可以分为两类：</p>
<ul>
<li>鲁棒性聚合 Robustness Aggregation</li>
<li>差分隐私 Differential Privacy</li>
</ul>
<h2 id="预测阶段">预测阶段</h2>
<p><img src="/2022/05/08/Threats-attacks-and-defenses-to-federated-learning-issues-taxonomy-and-perspectives/pi-when-pred.png" alt="Privacy inference attacks against FL"></p>
<h2 id="总结与收获">总结与收获</h2>
<ul>
<li>关键词：data quality assessment</li>
<li>A unified sample selection framework for output noise filtering: An error-bound perspective</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>Federated Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Threat Modeling and Attack Simulations of Connected Vehicles: Proof of Concept</title>
    <url>/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This paper reviews research in the field, showing that not much work has been done in the combined area of connected vehicles and threat modeling with attack simulations. We have implemented and conducted attack simulations on two vehicle threat models using a tool called securiCAD. Our work serves as a proof of concept of the approach and indicates that the approach is useful. Especially if more research of vehicle-specific vulnerabilities, weaknesses, and countermeasures is done in order to provide more accurate analyses, and to include this in a more tailored vehicle metamodel.</span><br></pre></td></tr></table></figure>
<p>abstract中指出：</p>
<ul>
<li>文章回顾了本领域的研究，指出在网联汽车和威胁模型的交叉领域，使用攻击仿真的研究并不多</li>
<li>作者使用 <code>securiCAD</code> 在两个汽车威胁模型上进行了攻击仿真</li>
<li>文章验证并指出该方法（基于攻击仿真威胁建模）是有效的</li>
</ul>
<span id="more"></span>
<h2 id="威胁建模">威胁建模</h2>
<p>文章在两款易受攻击的车型上进行了威胁建模，给出汽车的网络拓扑图和数据流图，如下：</p>
<p><img src="/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/network_topology.jpg" alt="网络拓扑图"></p>
<p><img src="/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/dataflow.jpg" alt="数据流图"></p>
<h3 id="安全设置">安全设置</h3>
<p>为每一个资产分配了一个安全设置(<code>security settings</code>)，其中包括攻击的后果，其值的范围是 <code>0 - 10</code>。使用具有安全设置和后果的系统模型，可以进行定量计算，如计算风险值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Risk = Consequence X Probability</span><br></pre></td></tr></table></figure>
<p>根据设备和文档对模型中的资产进行安全设置评分。</p>
<h2 id="汽车攻击模拟">汽车攻击模拟</h2>
<p>攻击模拟的结果包括风险矩阵，攻击路径和攻击时间图（Time to Compromise graph，TTC），TTC图表示基于某一特定攻击路径攻破特定设备的可能性分布。</p>
<p><img src="/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/risk_matrix.jpg" alt="风险矩阵"></p>
<p><img src="/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/attack_path.jpg" alt="攻击路径"></p>
<p><img src="/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/attack_path_1.jpg" alt="攻击路径图"></p>
<p><img src="/2021/07/08/Threat-Modeling-and-Attack-Simulations-of-Connected-Vehicles-Proof-of-Concept/ttc_graph.jpg" alt="TTC图"></p>
<p>攻击模拟结果显示，建模的车辆并不是完全安全的，根据风险矩阵，我们可以推测汽车的风险等级，我们也可以改变安全设置来查看该设置如何影响整体安全等级。根据攻击路径，我们可以发现可以实施哪些应对措施。最后的 <code>TTC</code> 图提供了从汽车适应力方面衡量汽车安全的方法，为比较汽车架构设计提供了一种定量的方法。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>汽车安全</tag>
        <tag>威胁建模</tag>
        <tag>攻击模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Topology-Aware Network Pruning using Multi-stage Graph Embedding and Reinforcement Learning</title>
    <url>/2023/09/27/Topology-Aware-Network-Pruning-using-Multi-stage-Graph-Embedding-and-Reinforcement-Learning/</url>
    <content><![CDATA[<p>notes of <code>Topology-Aware Network Pruning using Multi-stage Graph Embedding and Reinforcement Learning</code>.</p>
<h2 id="Problem-Statement">Problem Statement</h2>
<p>(big background)Model compression is an essential technique for depolying model on power and memory-constrained resources. (problem statement)Existing method often rely on human expertise and focus on parameters’ local importance, <code>ignoring the rich topology information within DNNs</code>.</p>
<h2 id="Main-Idea">Main Idea</h2>
<p>In this paper, author propose a novel multi-stage graph embedding technique based on graph neural networks (GNNs) to identify DNN topologies and use reinforcement learning (RL) to find a suitable compression policy.</p>
<ul>
<li>graph neural network to identify <code>DNN topologies</code></li>
<li>RL to optimize compression policy</li>
</ul>
<p><img src="/2023/09/27/Topology-Aware-Network-Pruning-using-Multi-stage-Graph-Embedding-and-Reinforcement-Learning/overview.png" alt="overview"></p>
<p>Main Procedure:</p>
<ul>
<li>hierarchical graph representation</li>
<li>multi-stage graph embedding</li>
<li>learning-based pooling</li>
<li>RL-based policy(use m-GNN)</li>
</ul>
<h2 id="Pros-and-Cons">Pros and Cons</h2>
<p>Pros:</p>
<ul>
<li>hierarchical graph representation keep the DNN topologies information</li>
<li>multi-staged graph embedding keep the graph structure as much as possible</li>
<li>use RL approximate the best pruning policy</li>
</ul>
<p>Cons:</p>
<ul>
<li>?(to be done)</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>graph neural network</tag>
        <tag>network pruning</tag>
        <tag>reinforcement learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Towards a Timely Causality Analysis for Enterprise Security</title>
    <url>/2022/04/14/Towards-a-Timely-Causality-Analysis-for-Enterprise-Security/</url>
    <content><![CDATA[<p>Towards a Timely Causality Analysis for Enterprise Security abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>随着 APT 攻击的涌现，攻击因果分析成为了分析该类攻击的重要手段。 但是由于该类分析是一个时间敏感的任务，所以构建一个能够及时提取出攻击信息的因果溯源系统是第一步。 然而之前的工作无法达到这个要求，该类工作主要集中于因果依赖关系剪枝，将无关的攻击事件去除。<br>
因此本文提出一种解决该问题的方法。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/14/Towards-a-Timely-Causality-Analysis-for-Enterprise-Security/arch.png" alt="arch"></p>
<p>文章提出 PROITRACKER，一个前后向因果关系跟踪器，可以在溯源过程中自动优先考虑异常因果关系依赖的调查。<br>
特别是，针对系统事件进行优先级评估，并通过事件稀有程度建立了一个参考模型。</p>
<h2 id="时间约束的异常优先因果跟踪">时间约束的异常优先因果跟踪</h2>
<p><img src="/2022/04/14/Towards-a-Timely-Causality-Analysis-for-Enterprise-Security/algo-1.png" alt="arch"></p>
<p>上述为基本算法，还设计了事件优先级，事件的优先级通过扇出、事件稀有度和数据流打分。<br>
下一步是为优先度函数的参数分配权值。</p>
<h2 id="参考模型">参考模型</h2>
<h3 id="数据采集">数据采集</h3>
<p>首先采集相似主机上的数据，其次对数据进行抽象，最后使用时间窗口来限定范围和计数。</p>
<p><img src="/2022/04/14/Towards-a-Timely-Causality-Analysis-for-Enterprise-Security/score.png" alt="arch"></p>
<h3 id="参考分数定义">参考分数定义</h3>
<p><img src="/2022/04/14/Towards-a-Timely-Causality-Analysis-for-Enterprise-Security/def-3.png" alt="arch"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>溯源分析管理平台</tag>
      </tags>
  </entry>
  <entry>
    <title>UISCOPE:Accurate, Instrumentation-free, and Visible Attack Investigation for GUI Applications</title>
    <url>/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/</url>
    <content><![CDATA[<p>UISCOPE: Accurate, Instrumentation-free, and Visible Attack Investigation for GUI Applications abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>当前针对 GUI 程序的攻击调查方案存在准确率低的问题（依赖爆炸导致的）、需要额外工具并且可视化程度低。</p>
<ul>
<li>分析结果不准确</li>
<li>需要额外的工具</li>
<li>缺乏可视化</li>
</ul>
<p>针对 GUI-related 攻击，提出 UISCOPE，一种新型的用于 GUI 应用程序的新型准确的、无额外工具且具有可视化的攻击调查系统。</p>
<p>与其他方法的比较：</p>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/comparasion.png" alt="comparasion"></p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/arch.png" alt="arch"></p>
<p>本文的核心观点在于在 UI 元素/事件 和 底层系统事件 上同时进行因果分析，然后将系统事件与UI事件关联以提高精度和可视化。长时间运行的进程被划分为单独的UI转换，底层系统事件归因于这些转换，从而使得结果准确。<br>
生成的图表包含因果相关的用户熟悉的UI元素，使其易于访问。</p>
<h2 id="具体实现">具体实现</h2>
<h3 id="UI元素和事件采集器">UI元素和事件采集器</h3>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/ui-collector.png" alt="ui-collector"></p>
<h3 id="系统事件采集器">系统事件采集器</h3>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/system-collector.png" alt="system-collector"></p>
<h3 id="事件分析定义">事件分析定义</h3>
<p><strong>UI Control Dependency</strong>:当一个UI组件可以直接影响另外的UI组件的时候，我们认为他们有控制依赖关系。</p>
<p><strong>UI Content Dependency</strong>:当UI组件是树形结构组织的，类似于父节点拥有整个网页，子节点为其中一个元素，认为这种关系是内容依赖。</p>
<p><strong>UI-System Dependency</strong>:如果一个UI组件导致系统事件，则认为他们有 UI-System 依赖。</p>
<p><strong>System-System Dependency</strong>:系统实体之间有调用关系，则认为他们有系统间依赖。</p>
<h3 id="UI-事件分析器">UI 事件分析器</h3>
<p>分析算法如下：</p>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/algo.png" alt="algo"></p>
<p>UI 事件分析器分析案例：</p>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/eg.png" alt="eg"></p>
<h3 id="系统事件分析器">系统事件分析器</h3>
<p>使用现有研究方法中的标准的因果分析方法。</p>
<h3 id="关联分析器">关联分析器</h3>
<h4 id="UI-System-Dependency">UI-System Dependency</h4>
<p>采集器从两个方面采集数据：可视化的前端和详尽信息的后端。</p>
<p>基于以下两个观察提出基于时间戳属性的方法：</p>
<ul>
<li>在某一具体时间，一个应用仅有一个当前聚焦的 UI 树</li>
<li>系统事件和UI事件通常同时被相同的攻击行为触发</li>
</ul>
<p>也就是说这两类事件在时间上是同时触发的，time-aligned.</p>
<p>系统和UI事件基于两个机制来进行关联：</p>
<ul>
<li>初始事件，通常系统实体会跟一系列系统事件相关</li>
<li>时间戳，根据上述特点关联</li>
</ul>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/algo2.png" alt="algo"></p>
<h4 id="后台活动">后台活动</h4>
<p>后台活动观察：</p>
<ul>
<li>大多数新的网站活动在短时间内减少，并且后台活动不常见</li>
<li>大多数 socket 县城在网页加载期间初始化</li>
<li>后台活动通常是重复活动</li>
</ul>
<p>关联分析案例：</p>
<p><img src="/2022/04/12/UISCOPE-Accurate-Instrumentation-free-and-Visible-Attack-Investigation-for-GUI-Applications/eg2.png" alt="eg"></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击调查</tag>
      </tags>
  </entry>
  <entry>
    <title>TrojanZoo: Towards Unified, Holistic, and Practical Evaluation of Neural Backdoors</title>
    <url>/2023/03/12/TrojanZoo-Towards-Unified-Holistic-and-Practical-Evaluation-of-Neural-Backdoors/</url>
    <content><![CDATA[<p>Contribution analysis of TrojanZoo.</p>
<span id="more"></span>
<h2 id="Summary-in-a-word">Summary in a word</h2>
<p>Aim to bridge the gap the current situation: the lack of evaluation on exsiting attacks and defenses.</p>
<p>The first open-source platform for evaluating neural backdoor attacks/defenses in a unified, holistic, and practical manner.<br>
<img src="/2023/03/12/TrojanZoo-Towards-Unified-Holistic-and-Practical-Evaluation-of-Neural-Backdoors/arch-trojanzoo.png" alt="arch-trojanzoo"></p>
<h2 id="Main-contribution">Main contribution</h2>
<ol>
<li>Open-source framework, includes attacks, defenses and plenty of evaluation metrics.</li>
<li>Systematic study on existing attaks/defenses, and unveiling their complex design spectrum.</li>
<li>Further explored existing attacks/defenses, and got intersting findings.</li>
</ol>
<h2 id="Experiments">Experiments</h2>
<ol>
<li>Analysed different attacks manifest intricate trade-offs among <code>effectiveness, evasiveness, transferability</code>.</li>
<li>Analysed different defenses on the topic below:
<ul>
<li>robustness vs. utility</li>
<li>detection accuracy of different attaks</li>
<li>detection accuracy vs. recovery capability</li>
<li>execution time</li>
</ul>
</li>
</ol>
<h2 id="Conclusion">Conclusion</h2>
<p>It’s an open-source framework for attacks/defenses research, and main contribution of the paper is the analysis of attacks and defenses.</p>
<p>It reveals several important findings in the experiment.</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>backdoor</tag>
        <tag>toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>UNICORN: Runtime Provenance-Based Detector for Advanced Persistent Threats</title>
    <url>/2021/08/27/UNICORN-Runtime-Provenance-Based-Detector-for-Advanced-Persistent-Threats/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Advanced Persistent Threats (APTs) are difficult todetect due to their “low-and-slow” attack patterns and frequent use of zero-day exploits. We present UNICORN, an anomaly- based APT detector that effectively leverages data provenance analysis. From modeling to detection, UNICORN tailors its design specifically for the unique characteristics of APTs. Through extensive yet time-efficient graph analysis, UNICORN explores provenance graphs that provide rich contextual and historical information to identify stealthy anomalous activities without pre- defined attack signatures. Using a graph sketching technique, it summarizes long-running system execution with space efficiency to combat slow-acting attacks that take place over a long time span. UNICORN further improves its detection capability using a novel modeling approach to understand long-term behavior as the system evolves. Our evaluation shows that UNICORN outperforms an existing state-of-the-art APT detection system and detects real- life APT scenarios with high accuracy.</span><br></pre></td></tr></table></figure>
<p>abstract中主要介绍了：</p>
<ul>
<li>APT 攻击的特点是 “低且慢” 的攻击模型和 zero-day 漏洞的频繁使用</li>
<li>文中提出的 UNICORN 是一种基于异常的 APT 检测工具</li>
<li>UNICORN 使用起源图，起源图中提供了丰富的上下文和历史信息，以识别没有预定义攻击特征的异常活动</li>
<li>采用了图形绘制技术，有效地总结了长时间运行的系统执行，以对抗在长时间跨度内发生的慢动作攻击</li>
</ul>
<span id="more"></span>
<h2 id="威胁模型">威胁模型</h2>
<p>APT 场景的假设是，攻击者可以非法地获取系统访问权限并且计划长期潜伏不被发现。攻击者可能在不同的阶段使用不同的攻击技术，UNICORN 的目的是检测出主机生成的起源图上的任何阶段的攻击行为。我们假设，相比攻击，UNICORN 会优先检测主机全局异常操作，并且在模型初始阶段没有攻击发生。</p>
<p>数据收集框架的完整性是 UNICORN 正确性的核心，我们假设 Linux security modules 可以正确地为 CamFlow 提供参考监控器的保证。同样对其他数据收集框架进行了类似的假设。</p>
<p>虽然作者假设 UNICORN 为端点上的安全监控器，但是其流式传输来源数据的能力使得他也能够检测主机之外的攻击。</p>
<h2 id="设计">设计</h2>
<h4 id="起源信息输入">起源信息输入</h4>
<p>UNICORN 接受运行在一个或多个系统上运行的数据收集系统生成的数据流，该流由属性标记的边。</p>
<p>数据收集系统构建了一个关系整个系统起源并且具有偏序保证的 DAG，该 DAG 允许高仿的流式计算和完全的上下文分析。</p>
<p>即使使用其他的系统也同样可以获取起源信息，文中使用了 CamFlow 获取起源信息。</p>
<h4 id="构建实时运行的内存直方图">构建实时运行的内存直方图</h4>
<p>UNICORN 可以构建一个表示整个系统执行历史的流式图形直方图，当新边到达图形数据流时更新直方图元素的计数。</p>
<p>通过迭代探索较大的图邻域，它可以发现带执行上下文的系统实体之间的因果关系。</p>
<p>这是UNICORN构建高效数据结构的第一步，有助于上下文化图形分析。具体而言，直方图中的每个元素描述了图的唯一子结构，同时考虑了附加到子结构中的顶点和边的异构标签，以及这些边的时间顺序。直方图中的每一个元素都描述了图的唯一子结构，即带上下文的图分析。其中考虑到了直方图中附加的异构标签/附加到子结构中的顶点和边的异构标签/以及附加到子结构内顶点和边的异构标签/以及这些边的时间顺序。</p>
<p>为了适应正常系统执行过程中的预期行为变化，UNICORN 定期对与最近事件没有因果关系的直方图元素的影响进行权重衰减。慢慢忘记不相关的过去事件使我们能够在整个系统正常运行期间有效地建模元状态。这并不意味着 UNICORN 忘记了信息丰富的执行历史，相反他可以使用图中的信息流依赖项来保持最新的/重要的/上下文相关的信息。攻击者可以在 APT 攻击中缓慢渗透受害者系统，希望基于时间的 IDS 最终忘记初始攻击，但是此类攻击无法打破对于最终成功攻击的信息流依赖。</p>
<p>对于构建内存直方图有两个要求：</p>
<ul>
<li>能够表示长时间跨度的因果关系</li>
<li>必须能够实时地实现基于实时图数据流的算法，阻止攻击的发生，而不是仅仅检测攻击的发生</li>
</ul>
<p>具体构建采用了一种基于一维同构WL测试的线性时间快速Weisfeiler-Lehman（WL）子树图核算法，该算法优势是在对图的辨识能力要比许多最先进的图学算法效果更好。</p>
<p><img src="/2021/08/27/UNICORN-Runtime-Provenance-Based-Detector-for-Advanced-Persistent-Threats/graph_histogram_generation_algo.png" alt="图直方图生成算法"></p>
<h4 id="周期地计算一个固定大小的缩略图">周期地计算一个固定大小的缩略图</h4>
<p>在纯流媒体环境中，当 UNICORN 总结整个来源图时，唯一直方图的数量可以任意增长。这种大小上的变化使得有效计算两个直方图之间的相似性具有挑战性，并且设计用于后期建模和检测的算法不切实际。</p>
<p>因此 UNICORN 采用了一种保持相似性的散列技术，将直方图转化为缩略图。缩略图是可增量维护的，这意味着 UNICORN 不需要在内存中保存整个起源图，而且缩略图的大小是恒定的，并且缩略图保留了两个图形直方图之间的标准化 jaccard 相似性。</p>
<p>在后续分析中，这种距离保持特性对于基于相同图相似性度量的聚类算法尤为重要。</p>
<p>UNICORN 使用 HistoSketch 进行缩略图的生成，该算法可以保证 数据相似度 的一致性，并且该算法是固定时间的算法，可以满足实时数据流的计算要求。</p>
<h4 id="将缩略图聚集到模型中">将缩略图聚集到模型中</h4>
<p>UNICORN 建立了一个正常的系统执行模型，并在没有攻击知识的情况下识别异常活动，然而于传统的集群方式不同，UNICRON 利用其流化能力生成进化模型。该模型通过在其执行的各个阶段对系统活动进行集群来捕获单个执行中的行为变化，但当攻击者可能破坏系统时，UNICORN 不会在运行时动态修改模型，因此他更适合部署在具有潜在 APT 攻击并长期运行的系统中。</p>
<h4 id="流变体和复杂性">流变体和复杂性</h4>
<p>在流式环境中，只在新到达的顶点和未来临域受新边影响的顶点上运行算法 1. 在每个起源实体或活动使用多个顶点来表示对应对象的不同版本或状态的起源图中，我们只需要计算/更新每个新边的目标顶点的邻域，因为顶点的所有传入边在任何传出边之前到达。</p>
<p><img src="/2021/08/27/UNICORN-Runtime-Provenance-Based-Detector-for-Advanced-Persistent-Threats/fig_2.png" alt="图与边"></p>
<p>如图2，UNICORN 利用这种偏序来最小化计算，这在处理大型图时尤为重要。并在实施时通过批量处理进一步降低了计算量。所以算法 1 实际运行时的复杂度更低，与原始一维Weisfeiler-Lehman算法的运行时复杂度近似相等：使用R-hop邻域，复杂度为O（R | E |）。</p>
<h4 id="对概念漂移的直方图元素进行权重衰减">对概念漂移的直方图元素进行权重衰减</h4>
<p>APT 潜在攻击的持续时间很长，这表明一个好的模型必须能够涵盖系统的长期行为，然后系统行为通常会随着时间的推移而改变，这导致流式起源图的基本统计特征发生变化，这种现象被叫做概念漂移。</p>
<p>UNICORN通过使用直方图元素计数的指数权重衰减来逐渐忘记过时的数据，从而解释了系统行为的这种变化。分配权重与数据的年龄成反比。</p>
<p>对于概念漂移，UNICORN 创建了进化模型来捕捉系统中的正常改变，当然，是在训练的过程中创建该模型，而不是在部署阶段。</p>
<p><img src="/2021/08/27/UNICORN-Runtime-Provenance-Based-Detector-for-Advanced-Persistent-Threats/evoluation_algo.png" alt="生成进化树"></p>
<h4 id="入侵检测场景的适用性">入侵检测场景的适用性</h4>
<p>通过权重衰减参数 lambda 来维护逐步遗忘的数据，使得 UNICORN 能够关注当前事件和具有因果关系的数据。在部署期间动态演化模型极有可能被长期 APT 攻击所污染。</p>
<h4 id="异常检测">异常检测</h4>
<p>在部署阶段，异常检测将会如上述步骤所中所介绍的周期地生成缩略图，当获得一张缩略图的时候， UNICORN 会将该缩略图与所有建模时学习到的子模型进行比较，将其拟合到每个子模型的簇中。假设 UNICORN 会从系统启动开始监控，并且跟踪每一个子模块内的系统状态转换。要在任何子模型中被视为有效，缩略图图必须适合当前状态或者（其中一个）下一个状态（在缩略图捕获系统执行中的状态转换的情况下）；否则，它被认为是异常的。因此我们检测到两种形式的异常行为：不适合现有集群的缩略图和集群之间的无效转换。</p>
<p>以上就是本文设计内容abstract，后续实施与评估不再赘述。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
        <tag>APT</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>centos volume management</title>
    <url>/2023/09/27/centos-%E5%8D%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsblk </span><br><span class="line">vgextend centos /dev/sdb</span><br><span class="line">vgremove data</span><br><span class="line">vgextend centos /dev/sdb</span><br><span class="line">vgextend centos /dev/sdc</span><br><span class="line">lsblk</span><br><span class="line">lvcreate -l +100%FREE -n home centos</span><br><span class="line">lsblk </span><br><span class="line">mkfs.ext4 /dev/centos/home </span><br><span class="line">rm -rf /mnt/tmp/</span><br><span class="line">mkdir /mnt/tmp</span><br><span class="line">mount /dev/centos/home /mnt/tmp/</span><br><span class="line">cp -aR /home/ /mnt/tmp/</span><br><span class="line">umount /dev/centos/home</span><br><span class="line">vim /etc/fstab </span><br><span class="line">mount -a </span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>techniques</category>
        <category>volume management</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>You Are What You Do: Hunting Stealthy Malware via Data Provenance Analysis</title>
    <url>/2022/04/27/You-Are-What-You-Do-Hunting-Stealthy-Malware-via-Data-Provenance-Analysis/</url>
    <content><![CDATA[<p>You Are What You Do: Hunting Stealthy Malware via Data Provenance Analysis abstract。</p>
<span id="more"></span>
<h2 id="解决的问题">解决的问题</h2>
<p>对于传统检测工具而言，很难检测现在的具有隐蔽性的恶意软件。本文针对此问题提出一种方法来检测该类软件。</p>
<h2 id="Architecture">Architecture</h2>
<p><img src="/2022/04/27/You-Are-What-You-Do-Hunting-Stealthy-Malware-via-Data-Provenance-Analysis/arch.png" alt="arch"></p>
<h2 id="思路及实现">思路及实现</h2>
<p>为了检测隐蔽的恶意软件，决定 PROVDETECTOR 有以下特点：</p>
<ul>
<li>仅学习正常数据的异常检测</li>
<li>使用因果路径，系统事件序列</li>
<li>仅学习溯源图上一部分因果路径</li>
</ul>
<h3 id="溯源图构建">溯源图构建</h3>
<p>略</p>
<h3 id="表示提取-Representation-Extraction">表示提取 Representation Extraction</h3>
<p>PROVDETECTOR 采用因果路径作为输入特征，具体因果路径示例如下：</p>
<p><img src="/2022/04/27/You-Are-What-You-Do-Hunting-Stealthy-Malware-via-Data-Provenance-Analysis/causal-graph.png" alt="causal graph"></p>
<p>直接从溯源图中提取出全部路径将会导致依赖爆炸问题，因此采用基于稀有度的路径选择算法进行路径选取，选 tok K。</p>
<h3 id="嵌入-Embedding">嵌入 Embedding</h3>
<p>即使获取了 top K 路径之后还存在着各种问题：</p>
<ul>
<li>因果路径长度不同</li>
<li>节点和边的标签是非结构化数据，例如文件名</li>
</ul>
<p><strong>Intuition</strong>：将因果路径作为一个句子。</p>
<p>使用 doc2vec 的 PV-DM 模型来学习路径的嵌入，这个方法有几个优点：</p>
<ul>
<li>自监督，可以仅学习好的数据</li>
<li>能够保持相似性，原路径相似映射到向量空间中他们也是距离更近的</li>
<li>能够考虑到词序</li>
</ul>
<h3 id="异常检测">异常检测</h3>
<p>对溯源数据进行观察得到以下观点：</p>
<ul>
<li>计算机程序和系统是复杂和动态的，很难用数学概率分布模型对程序行为进行建模</li>
<li>相似的进程可能有着不同的工作流，在嵌入空间中很难用一条曲线来区分正常和异常的数据</li>
</ul>
<p>基于溯源数据的特点，PROVDETECTOR 使用 局部异常因子 Local Outlier Factor 作为检测模型，该方法是一种基于密度的方法。如果一个点的局部密度低于其邻居，则该点被视为异常值。</p>
<p><strong>最终决策（Final Decision Making）</strong>：使用基于阈值的方法来做最终决定，这种方法可以在路径选择过程中提前停止，减少检测开销。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>攻击检测</tag>
      </tags>
  </entry>
  <entry>
    <title>codechecker概览</title>
    <url>/2021/07/02/codechecker%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h2 id="codechecker介绍">codechecker介绍</h2>
<p><code>codechecker </code> 是一款代码审计工具，可以扫描源码中可能存在的漏洞。该工具的主要特点有两个：</p>
<ul>
<li><code>clang sa/clang tidy</code> 的多文件扫描，使用 <code>tu_collector</code> 对多个文件做了翻译单元的聚合，然后调用 <code>clang sa/clang tidy</code> 进行扫描</li>
<li>项目管理服务器和报告展示界面</li>
</ul>
<p>工具仓库地址：<a href="https://github.com/Ericsson/codechecker">https://github.com/Ericsson/codechecker</a></p>
<span id="more"></span>
<h2 id="整体架构">整体架构</h2>
<p><img src="/2021/07/02/codechecker%E6%A6%82%E8%A7%88/infrastructure.png" alt="img"></p>
<p>目录：</p>
<p>编译命令记录</p>
<ul>
<li>
<p>记录编译器指令，如make, cmake</p>
</li>
<li>
<p>将编译器指令转化成为JSON格式</p>
</li>
</ul>
<p>编译命令处理</p>
<ul>
<li>
<p>参数过滤</p>
</li>
<li>
<p>C/C++标准检查</p>
</li>
<li>
<p>编译目标检测</p>
</li>
<li>
<p>gcc/g++ 硬编码路径收集</p>
</li>
</ul>
<p>交叉编译单元和静态分析的预处理</p>
<ul>
<li>
<p>交叉编译单元：针对每一个编译动作生成AST输出</p>
</li>
<li>
<p>统计分析：收集不同的信息，返回值检查等，这些信息可以在静态分析步骤被重用</p>
</li>
</ul>
<p>分析运行</p>
<ul>
<li>
<p>Multiple analyzers run parallel using the collected information in the pre analysis step if available</p>
</li>
<li>
<p>processes one Buildaction</p>
</li>
<li>
<p>constructs the analysis command</p>
</li>
<li>
<p>runs the static analyzer analyzer</p>
</li>
<li>
<p>postprocesses analysis results if required</p>
</li>
<li>
<p>collect failure information in case the analysis failed(compilation error or crash)</p>
</li>
</ul>
<p>报告存储和可视化服务器</p>
<p>数据库</p>
<ul>
<li>
<p>Configuration database:</p>
</li>
<li>
<p>authentication/session information</p>
</li>
<li>
<p>production configuration （database connection information…)</p>
</li>
<li>
<p>Report database:</p>
</li>
<li>
<p>Store multiple analyzer run results.</p>
</li>
<li>
<p>Data can be used to generate analysis statistics</p>
</li>
</ul>
<p>命令行客户端</p>
<ul>
<li>
<p>Can be used for CI integration in a jenkins job</p>
</li>
<li>
<p>provide multiple output types</p>
</li>
</ul>
<p>web浏览器</p>
<h2 id="工具使用流">工具使用流</h2>
<p><img src="/2021/07/02/codechecker%E6%A6%82%E8%A7%88/workflow.png" alt="img"></p>
<p>1.codechecker log运行给定的编译命令并且记录执行的编译步骤。这会生成一个JSON格式的输出文件（编译数据库）。</p>
<p>2.codechecker analyze使用前面得到的JSON数据执行项目分析，生成分析结果，结果使用plist格式表示。</p>
<p>3.此步骤可以进行多种不同的分析：</p>
<ul>
<li>
<p>codechecker parse 展示分析结果</p>
</li>
<li>
<p>codechecker store 存储结果到指定服务器</p>
</li>
<li>
<p>codechecker cmd diff 比较两个分析结果的</p>
</li>
</ul>
<p>从功能上分为两大部分：</p>
<ul>
<li>
<p>分析</p>
</li>
<li>
<p>展示</p>
</li>
</ul>
<p>从使用方式上分为两种：</p>
<ul>
<li>
<p>命令行</p>
</li>
<li>
<p>web UI</p>
</li>
</ul>
<p>README.md中给出的示例：</p>
<ol>
<li>执行分析</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CodeChecker check -b &quot;cd ~/your-project &amp;&amp; make clean &amp;&amp; make&quot; -o ./results</span><br></pre></td></tr></table></figure>
<p>check命令和analyze命令的区别是，check会将在标准输出里打印分析结果，analyze需要log命令输出的JSON文件作为输入。check相当于log命令+analyze命令。</p>
<p><img src="/2021/07/02/codechecker%E6%A6%82%E8%A7%88/example.png" alt="img"></p>
<h2 id="服务器其他功能">服务器其他功能</h2>
<ul>
<li>
<p>用户认证授权功能</p>
</li>
<li>
<p>产品管理</p>
</li>
<li>
<p>执行管理</p>
</li>
<li>
<p>执行展示和比较</p>
</li>
<li>
<p>漏洞路径展示</p>
</li>
<li>
<p>产品漏洞统计</p>
</li>
</ul>
<h2 id="命令行与Web界面的区别">命令行与Web界面的区别</h2>
<p>分析器调用：</p>
<ul>
<li>
<p>分析器只能够使用命令行命令invoke来启用</p>
</li>
<li>
<p>分析在用户本地执行</p>
</li>
</ul>
<p>存储分析报告到服务器：</p>
<p>使用store命令进行分析报告存储</p>
<p>报告索引和可视化：</p>
<table>
<thead>
<tr>
<th>Feature name</th>
<th><a href="https://github.com/Ericsson/codechecker/blob/master/docs/web/user_guide.md#cmd">Command-line</a></th>
<th><a href="https://github.com/Ericsson/codechecker/blob/master/www/userguide/userguide.md">Web GUI</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Listing basic (file, check message, …) report summary</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Listing advanced (detection status, review, …) report summary</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>Basic (file path, check name, …) filtering of reports</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Advanced (detection status, detection date, …) filtering</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>Printing bug path for report</td>
<td><a href="https://github.com/Ericsson/codechecker/blob/master/docs/analyzer/user_guide.md#parse">Only for local output folder</a></td>
<td>✓</td>
</tr>
<tr>
<td>Visualisation of bug path in the code</td>
<td><a href="https://github.com/Ericsson/codechecker/blob/master/docs/analyzer/user_guide.md#parse">Only through exporting to HTML</a></td>
<td>✓</td>
</tr>
<tr>
<td>Listing reports in the same file</td>
<td>Only through filters</td>
<td>✓</td>
</tr>
<tr>
<td>Listing all reports in a product</td>
<td>✗</td>
<td>✓</td>
</tr>
</tbody>
</table>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>git相关命令</title>
    <url>/2021/06/30/git%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Git-全局设置">Git 全局设置</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;your_email@163.com&quot;</span><br></pre></td></tr></table></figure>
<h2 id="创建-git-仓库">创建 git 仓库</h2>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir  your_repo_dir</span><br><span class="line">cd your_repo_dir</span><br><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md # 添加文件到暂存区</span><br><span class="line">git status -sb # 查看暂存区状态</span><br><span class="line">git commit -m &quot;first commit&quot; # 提交文件并且带注释</span><br><span class="line">git commit #不带注释的提交</span><br><span class="line">git checkout -b testBranch # 生成testBranch并转到该分支</span><br><span class="line">git branch test # 生成test分支或者转到该分支</span><br><span class="line">git branch -d test # 删除test分支</span><br><span class="line"># 文件修改完成后，需要合并分支，首先切换到主分支然后合并</span><br><span class="line">git checkout master</span><br><span class="line">git merge test</span><br><span class="line">git remote add origin your_remote_repo_address # 将本地仓库提交到远程地址</span><br><span class="line">git push -u origin master # 将本地仓库推送更新到远程地址</span><br><span class="line">git pull # 将远程仓库更新到本地来</span><br></pre></td></tr></table></figure>
<h2 id="更新子模块">更新子模块</h2>
<p>当网络不好的时候，<code>git pull</code> 容易出错，此时 <code>clone</code> 有子模块的 <code>repo</code> 极易出错，使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<h2 id="常见错误">常见错误</h2>
<h3 id="fatal-unable-to-access-‘xxxxx’-Failed-to-connect-to-xxxx-port-443-Timed-out">fatal: unable to access ‘xxxxx’: Failed to connect to xxxx  port 443: Timed out</h3>
<p>可能是 <code>https</code> 或者 代理的问题，第一种解决方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure>
<p>取消代理，重新 <code>git clone</code> 尝试。<br>
如果第一种不行，可能是 <code>https</code> 服务器的问题，第二种解决方法：<br>
<strong>使用 <code>http</code> 协议</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://example.github/example.git</span><br></pre></td></tr></table></figure>
<h3 id="fatal-unable-to-access-github-OpenSSL-SSL-read-Connection-was-reset-errno-10054">fatal: unable to access github: OpenSSL SSL_read: Connection was reset, errno 10054</h3>
<p>原因是可能被墙了，解决方法如下：</p>
<ol>
<li>
<p>修改 <code>host</code> 映射，具体参照 <a href="https://www.cnblogs.com/xym4869/p/13262061.html">无法连接github</a></p>
</li>
<li>
<p>更新DNS缓存</p>
<ul>
<li>
<p>Mac用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br><span class="line">sudo dscacheutil -flushcache</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Windows用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>此问题参考博文，<a href="https://www.cnblogs.com/xym4869/p/13284364.html">使用git克隆github上的项目失败：unable to access github: OpenSSL SSL_read: Connection was reset, errno 10054</a></p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>techniques</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>mitre-attack 工具调研</title>
    <url>/2021/10/08/mitre-attack-%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="mitre-attack-工具调研">mitre-attack 工具调研</h2>
<p>调研 github 上 mitre-attack 相关的工具，目标是<strong>寻找能够把审计记录映射到 mitre-attack 对应战术和技术上的工具</strong>。</p>
<span id="more"></span>
<h3 id="atomic-red-team">atomic-red-team</h3>
<p>仓库链接：<a href="https://github.com/redcanaryco/atomic-red-team">https://github.com/redcanaryco/atomic-red-team</a></p>
<p>Atomic Red Team 是一个能够映射到 mitre-attack 框架上的测试库，安全团队可以使用该工具方便、快速地测试他们的环境。</p>
<p>该项目是一个用于测试的集合，以 mitre-attack 框架的编号进行分类，需要进行那一项技术的安全测试可以执行对应的测试，有较为详细的说明和代码实例，但是与现在的目标有所区别。</p>
<h3 id="sysmon-modular">sysmon-modular</h3>
<p>是面向 windows 系列的审计日志工具，因为使用 linux 系列的平台，windows 系列工具与目标不符合。</p>
<p>值得一提的是该项目的关于配置和 mitre-attack 的映射还是比较全的，只是暂时并不会使用 windows 系列系统作为实验环境。</p>
<h3 id="ATTACK-Tools">ATTACK-Tools</h3>
<p>该项目是一个 ATT&amp;CK 相关的工具库，提供了两个工具，一个是 数据模型，另一个是 攻击视图，可以用来模拟攻击者攻击。</p>
<p>可以通过 SQL 语句使用数据模型，并提供了一个 sqlite 示例文件。</p>
<h3 id="BLUESPAWN">BLUESPAWN</h3>
<p>一个基于异常活动检测的蓝队实时监控系统的系统，该项目也是基于 windows 系统的。该项目拥有多个模式，如：</p>
<ul>
<li>Hunt：捕获恶意行为的证据</li>
<li>Mitigate： 通过应用安全设置来加固系统</li>
<li>Monitor： 持续监控系统可能存在的恶意行为</li>
<li>Scan： 扫描 Hunt 模式下捕获的恶意行为，确认是否是真实的恶意行为还是误报</li>
<li>其他</li>
</ul>
<h3 id="ThreatHunting">ThreatHunting</h3>
<p>一个可以将 sysmon 日志记录映射到 mitre-attack 框架上的 splunk app，该项目有详细的文档。</p>
<h3 id="sentinel-attack">sentinel-attack</h3>
<p>一个 Azure 上的快速部署工具，可以快速配置 sysmon，开展威胁狩猎实验。</p>
<h3 id="atomic-threat-coverage">atomic-threat-coverage</h3>
<p>这是一个可以自动生成可采取行动的分析，基于 mitre-attack 攻击模型，想要从检测、响应、缓解和模拟角度进行威胁发现和防御的工具。</p>
<p>该项目的产出有：</p>
<ul>
<li>Atlassian 汇总知识库</li>
<li>markdown 知识库</li>
<li>可视化工具</li>
</ul>
<h3 id="auditd-attack">auditd-attack</h3>
<p>一个将 Linux Auditd 规则映射到 mitre-attack 框架上的工具。平台是与目标相符的，但是此项目是从 auditd 规则上进行对应，跟现有的记录对应还有一定差距。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>survey</category>
      </categories>
      <tags>
        <tag>mitre-attack</tag>
        <tag>tools</tag>
        <tag>mapping</tag>
      </tags>
  </entry>
  <entry>
    <title>基于攻击路径图的入侵意图识别</title>
    <url>/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="abstract">abstract</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了预测攻击者高层次的攻击目标，感知网络的安全态势，提出入侵意图识别方法．给出入侵意图的概念及其分类，提出一种基于层次化的攻击路径图．利用攻击路径图对攻击者的意图可达性、意图实现概率、意图实现 的最短路径和攻击路径预测进行定量分析．应用有向图的最小割理论制定防护措施阻止攻击者意图的实现，为管 理员的决策提供依据．实验验证了该方法的可行性和有效性．</span><br></pre></td></tr></table></figure>
<p>abstract指出论文内容主要有：</p>
<ul>
<li>给出入侵意图的分类</li>
<li>提出基于层次化的攻击路径图</li>
<li>可用于意图可达性、意图实现概率、意图实现最短路径和攻击路径预测进行定量分析</li>
</ul>
<span id="more"></span>
<h2 id="意图识别内容">意图识别内容</h2>
<h3 id="入侵意图">入侵意图</h3>
<img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/taxonomy.jpg" alt="入侵意图分类">
<h3 id="层次化的攻击路径图">层次化的攻击路径图</h3>
<p>定义：</p>
<ul>
<li>弱点集合 <code>V:&#123;v_CVE, v_pre, v_post&#125;</code></li>
<li>主机集合 <code>H</code>，端口集合 <code>theta</code></li>
<li>攻击者可能达到的意图集合 <code>I</code>，<code>I</code> 为一个四元组 <code>&#123;i_name, i_target, i_pre, i_post&#125;</code></li>
<li>模型输入为：网络拓扑信息、弱点信息、入侵意图信息</li>
<li>推理生成的路径图有：弱点级、主机级、保护域级</li>
</ul>
<h3 id="攻击路径图生成">攻击路径图生成</h3>
<p>算法简介：</p>
<ul>
<li>
<p>攻击者已经获得了较高的权限而不会再获取较低的权限</p>
</li>
<li>
<p>攻击者不会第二次入侵已经获得权限的主机</p>
</li>
<li>
<p>输入：主机集合、主机的弱点集合、主机间的连接关系</p>
</li>
<li>
<p>输出：攻击路径图</p>
</li>
</ul>
<p>算法实现（根据弱点层、主机层和保护域分）：</p>
<ul>
<li>从主机 <code>h</code> 出发，从权限 <code>none</code> 出发，查找所有满足 <code>v_j+1 X v_pre 属于 v_j X v_post</code> 条件的点，并将 <code>v_j 和 v_j+1</code> 添加到顶点集，边 <code>v_j -&gt; v_j+1</code> 添加到边集，知道达到 <code>user</code> 或 <code>root</code> 权限，即生成主机 <code>h</code> 的以 <code>none</code> 为始节点、以 <code>user/root</code> 权限为终节点、以弱点为中间结点的攻击路径图</li>
<li>假设从 <code>h_0</code>  的权限出发，满足 <code>(h_0, h_1, theta)</code> 属于 <code>C</code> 且通过主机 <code>h_0</code> 能获取 <code>h_1</code> 的权限，则 <code>h_1</code> 是新增的节点，边 <code>h_0 -&gt; h_1</code> 是新增的有向边</li>
<li>假设 <code>D1, D2</code> 是2个保护域且攻击者已经获取主机 <code>h1</code> 的权限，主机 <code>h1 属于 D1, h2 属于 D2</code>，如果攻击者能获取 <code>h2</code> 的权限，则 <code>D2</code> 是新增的节点，边 <code>D1 -&gt; D2</code> 是新增的有向边</li>
</ul>
<h2 id="基于攻击路径图的入侵意识识别模型">基于攻击路径图的入侵意识识别模型</h2>
<h3 id="意图识别的可达性分析">意图识别的可达性分析</h3>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/reachable_analysis.jpg" alt="可达性分析定义"></p>
<p>根据此定义，可以将可达性分析转化成节点之间的路径搜索问题，文章还提出了使用矩阵进行可达性法系的方法，在此不再赘述。</p>
<h3 id="意图识别的概率分析">意图识别的概率分析</h3>
<p>文章考虑弱点的三个属性：难易程度 <code>Q</code>，隐蔽性 <code>S</code> 和期望收益 <code>R</code>给出了弱点 <code>v</code> 的利用概率：</p>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/pro_of_vul.jpg" alt="概率分析"></p>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/weight.jpg" alt="权值"></p>
<p>给出单步利用概率后，又给出了多步的权限跃迁概率，<code>r</code> 为该路径上依次利用的弱点数：</p>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/pro_of_trans.jpg" alt="概率分析"></p>
<p>在主机级攻击路径图中，攻击者为了实现意图 <code>i</code>，实现该意图，可能有 <code>k</code> 条攻击路径，假设每条路径有 <code>g</code> 个节点，则意图 <code>i</code> 实现的概率为：</p>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/pro_of_int.jpg" alt="概率分析"></p>
<h3 id="意图实现的最短路径">意图实现的最短路径</h3>
<p>最短路径为边权之和最小</p>
<h3 id="基于意图的路径预测">基于意图的路径预测</h3>
<p>使用贝叶斯对每条能够到达意图的攻击路径求其相对概率</p>
<h2 id="入侵意图阻断">入侵意图阻断</h2>
<h3 id="基于最小割的入侵意图阻断">基于最小割的入侵意图阻断</h3>
<p>求最小割算法：</p>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/min_cut.jpg" alt="求最小割"></p>
<p>在攻击路径图中，切断通往意图的所有路径从而阻止攻击者的入侵意图实现，可以达到网络安全防护的目标。因此，移除攻击路径图中的最小顶点割集是意图实现的经济且行之有效的方法。</p>
<p><img src="/2021/07/13/%E5%9F%BA%E4%BA%8E%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%9A%84%E5%85%A5%E4%BE%B5%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB/min_cost.jpg" alt="最小花费"></p>
<p>上式是 <code>F</code> 是移除该点的花费，包括时间成本、金钱成本和其他成本。 <code>delta</code> 为最小花费。</p>
<p>最后文章通过实例，验证了方法的有效性。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>papers</category>
        <category>abstract</category>
      </categories>
      <tags>
        <tag>意图识别</tag>
        <tag>攻击图</tag>
      </tags>
  </entry>
  <entry>
    <title>新建Linux账号并赋予sudo权限</title>
    <url>/2021/06/30/%E6%96%B0%E5%BB%BALinux%E8%B4%A6%E5%8F%B7%E5%B9%B6%E8%B5%8B%E4%BA%88sudo%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>添加账号并建立所属目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su </span><br><span class="line">useradd username -m -s /bin/bash</span><br><span class="line">passwd username</span><br><span class="line">mkdir /home/username</span><br><span class="line">chown username:username -R /home/username</span><br><span class="line">chgrp root /home/usesrname</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>赋予<code>sudo</code>权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visudo -f  /etc/sudoers</span><br><span class="line">username ALL(ALL):ALL</span><br></pre></td></tr></table></figure>
<p>添加常用软件<code>conda</code>环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=&quot;/home/ubuntu/anaconda3/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>techniques</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：恶意代码检测与分析</title>
    <url>/2022/02/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件安全分析与应用第8章恶意代码检测与分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>恶意代码检测与分析
<ul>
<li>恶意代码分析基础
<ul>
<li>恶意代码分类</li>
<li>恶意代码分析的目的</li>
<li>典型分析流程</li>
<li>软件漏洞利用分析</li>
</ul>
</li>
<li>静态分析
<ul>
<li>杀毒软件扫描</li>
<li>文件类型确定</li>
<li>文件哈希计算</li>
<li>字符串信息提取</li>
<li>文件元数据提取</li>
<li>混淆代码识别</li>
<li>代码反汇编</li>
</ul>
</li>
<li>动态分析
<ul>
<li>动态分析环境构建</li>
<li>动态行为分析</li>
<li>动态调试分析</li>
<li>反虚拟化分析对抗</li>
<li>反自动化分析对抗</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="恶意代码分类">恶意代码分类</h2>
<ul>
<li>蠕虫 worm</li>
<li>木马 trojan horse</li>
<li>后门 backdoor</li>
<li>僵尸程序 bot</li>
<li>下载器 downloader</li>
<li>rootkit</li>
<li>恐吓软件 scareware</li>
<li>勒索软件 ransomware</li>
</ul>
<h2 id="静态分析">静态分析</h2>
<p>使用现有工具进行静态分析，首先确认是否该样本已经被主流安全工具确认为恶意代码。</p>
<h2 id="动态分析">动态分析</h2>
<p>静态分析获得恶意代码的初步信息后，可以使用动态分析技术，通过运行可以代码，观察其行为。<br>
动态分析包含一下步骤：</p>
<ul>
<li>动态分析环境构建</li>
<li>动态行为分析</li>
<li>动态调试分析</li>
<li>反虚拟化分析对抗</li>
<li>反自动化分析对抗</li>
</ul>
<h4 id="动态行为分析">动态行为分析</h4>
<p>系统、进程监控其实常用的系统级别分析软件，wireshark 是常用的网络流量监控分析软件。</p>
<h4 id="动态调试分析">动态调试分析</h4>
<p>动态调试是软件分析的重要手段，常用的工具有 OllyDbg 和 WinDbg 等。</p>
<h4 id="反虚拟化分析对抗">反虚拟化分析对抗</h4>
<p>恶意代码为了避免自身被发现和分析，通常会采用一些反调试、反分析技术来对抗分析过程。所以需要进行配置对抗恶意代码中的虚拟化检测功能。</p>
<h4 id="反自动化分析对抗">反自动化分析对抗</h4>
<p>为了绕过自动化检测分析，恶意代码编写者不断尝试采用各种技术来对抗自动化分析系统。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>snmp操作简介</title>
    <url>/2021/10/13/snmp%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>主要介绍了以下操作：</p>
<ol>
<li>snmp服务的安装</li>
<li>snmp相关的一些简单操作</li>
</ol>
<p>Windows下可以开启snmp服务的代理端，不过如果要进行网络管理需要安装专用的nms软件，如果是简单的操作则需要安装net-snmp或者snmputil来实现.<br>
Linux下主要使用到的软件是snmp snmpd snmp-mibs-downloader</p>
<span id="more"></span>
<h3 id="系统信息及操作">系统信息及操作</h3>
<p>系统信息：Linux  4.15.0-70-generic #79~16.04.1-Ubuntu SMP x86_64</p>
<h3 id="本地测试">本地测试</h3>
<ol>
<li>安装snmp</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install snmp snmpd</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看安装版本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@flyinfort:~$ snmpd -v</span><br><span class="line"></span><br><span class="line">NET-SNMP version:  5.7.3</span><br><span class="line">Web:               http://www.net-snmp.org/</span><br><span class="line">Email:             net-snmp-coders@lists.sourceforge.net</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动和查看snmpd服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@flyinfort:~$ sudo service snmpd start </span><br><span class="line">user@flyinfort:~$ sudo service snmpd status </span><br><span class="line">● snmpd.service - LSB: SNMP agents</span><br><span class="line">   Loaded: loaded (/etc/init.d/snmpd; bad; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 三 2019-11-20 16:36:04 CST; 11s ago</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line">  Process: 19003 ExecStop=/etc/init.d/snmpd stop (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 19047 ExecStart=/etc/init.d/snmpd start (code=exited, status=0/SUCCES</span><br><span class="line">   CGroup: /system.slice/snmpd.service</span><br><span class="line">           └─19053 /usr/sbin/snmpd -Lsd -Lf /dev/null -u snmp -g snmp -I -smux m</span><br><span class="line"></span><br><span class="line">11月 20 16:36:04 flyinfort systemd[1]: Starting LSB: SNMP agents...</span><br><span class="line">11月 20 16:36:04 flyinfort snmpd[19047]:  * Starting SNMP services:</span><br><span class="line">11月 20 16:36:04 flyinfort snmpd[19051]: /etc/snmp/snmpd.conf: line 145: Warning</span><br><span class="line">11月 20 16:36:04 flyinfort snmpd[19051]: /etc/snmp/snmpd.conf: line 147: Warning</span><br><span class="line">11月 20 16:36:04 flyinfort snmpd[19051]: Turning on AgentX master support.</span><br><span class="line">11月 20 16:36:04 flyinfort systemd[1]: Started LSB: SNMP agents.</span><br><span class="line">11月 20 16:36:04 flyinfort snmpd[19053]: NET-SNMP version 5.7.3</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>walk命令查看MIB信息库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@flyinfort:~$ snmpwalk -v 2c -c public localhost 1.3.6.1.2.1.1.1</span><br><span class="line">iso.3.6.1.2.1.1.1.0 = STRING: &quot;Linux flyinfort 4.15.0-70-generic #79~16.04.1-Ubuntu SMP Tue Nov 12 14:01:10 UTC 2019 x86_64&quot;</span><br></pre></td></tr></table></figure>
<p>在这个命令中localhost之后的一串数字就是我们之前学到的OID，这一个OID：1.3.6.1.2.1.1.1是MIB中对象标识符，在这个对象里面会存储一些跟系统主机相关的一些信息。<br>
在网上会有相关的OID的具体含义的网页，例如： <code>http://www.ttlsa.com/monitor/snmp-oid/</code>可以对应查找</p>
<ol start="5">
<li>安装启动trapd监听trap信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install snmptrapd</span><br><span class="line"></span><br><span class="line">sudo snmptrapd -d -f -Lo</span><br></pre></td></tr></table></figure>
<p>上面命令中的选项表示：<br>
-C ： 表示不使用net-snmp默认路径下的配置文件snmptrapd.conf；<br>
-c ： 指定snmptrapd.conf文件；<br>
-d ： 显示收到和发送的数据报，通过这个选项可以看到数据报文；<br>
-f ： 默认情况下，snmptrapd是在后台中运行的，加上这个选项，表示在前台运行；<br>
-L ： 指定日志记录在哪里，后面的o表示直接输出到屏幕上，如果是跟着f表示日志记录到指定的文件中；<br>
可通过snmptrapd -h查看命令帮助了解该命令的使用。<br>
6. 本机发送trap信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo snmptrap -v1 -c public localhost 1.3.6.1.4.1.1 10.10.12.219 2 3 1000 1.3.6.1.9.9.44.1.2.1 i 12 1.3.4.1.2.3.1 s test_snmptrap</span><br></pre></td></tr></table></figure>
<p>下面是snmpdtrapd接受到的我们发送的trap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Received 82 byte packet from UDP: [127.0.0.1]:48964-&gt;[127.0.0.1]:162</span><br><span class="line">0000: 30 50 02 01  00 04 06 70  75 62 6C 69  63 A4 43 06    0P.....public.C.</span><br><span class="line">0016: 06 2B 06 01  04 01 01 40  04 0A 0A 0C  DB 02 01 02    .+.....@........</span><br><span class="line">0032: 02 01 03 43  02 03 E8 30  29 30 0E 06  09 2B 06 01    ...C...0)0...+..</span><br><span class="line">0048: 09 09 2C 01  02 01 02 01  0C 30 17 06  06 2B 04 01    ..,......0...+..</span><br><span class="line">0064: 02 03 01 04  0D 74 65 73  74 5F 73 6E  6D 70 74 72    .....test_snmptr</span><br><span class="line">0080: 61 70                                                 ap</span><br><span class="line"></span><br><span class="line">No access configuration - dropping trap.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="网络测试">网络测试</h3>
<p>由于我们之前是在自己本机进行的一些操作，所以现在进行网络测试，网络测试需要对snmpd的配置进行一些修改。</p>
<ol>
<li>配置节点<br>
修改配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/snmp/snmpd.conf</span><br></pre></td></tr></table></figure>
<p>注意在修改配置文件的时候需要管理员权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">view   systemonly  included   .1.3.6.1.2.1.1</span><br><span class="line">view   systemonly  included   .1.3.6.1.2.1.25.1</span><br></pre></td></tr></table></figure>
<p>将上面两句注释掉，注释完了之后，在下面添加新的一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">view   systemonly  included   .1</span><br></pre></td></tr></table></figure>
<p>这样子就可以获取更多节点的信息了，我们修改的是对应的OID如果是之前的那两句的意思是只获取那两个的对应的实体的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user@flyinfort:/etc/snmp$ service snmpd restart </span><br><span class="line">user@flyinfort:/etc/snmp$ snmpwalk -v 2c -c public localhost .1.3.6.1.4.1.2021.4.3.0</span><br><span class="line">iso.3.6.1.4.1.2021.4.3.0 = INTEGER: 8169468</span><br></pre></td></tr></table></figure>
<p>这是查看了一下内存的使用<br>
2. 允许远程主机访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  Listen for connections from the local system only</span><br><span class="line">agentAddress  udp:127.0.0.1:161</span><br><span class="line">#  Listen for connections on all interfaces (both IPv4 *and* IPv6)</span><br><span class="line">#agentAddress udp:161,udp6:[::1]:161</span><br></pre></td></tr></table></figure>
<p>snmpd默认的设置是只对本地主机开放的，远程无法获取我们本地的snmp的信息修改config文件使其可以远程访问<br>
将上面的<code>agentAddress  udp:127.0.0.1:161</code>注释掉，将<code>agentAddress udp:161,udp6:[::1]:161</code>取消注释即可，然后重新启动snmpd服务<br>
此时最好再次查看确保snmpd服务已经启动。<br>
3. 在windows上开启snmp服务远程获取Linux主机信息<br>
在Windows上开启snmp服务的一般的功能上，控制面板-&gt;程序和功能-&gt;启用和关闭windows功能-&gt;选择snmp服务。可以打开服务面板重启snmp服务。<br>
想要查看我们远程linux主机的MIB信息需要用到其他工具，在这里使用的snmputil（net-snmp在win上安装麻烦些，暂时还没安装成功），支持get walk等命令。在此处查看远程主机的系统信息。可以看到和我们在本地看到的信息是一致的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\workspace\softwares\snmputil&gt;SNMPUTIL.EXE walk 10.164.222.198 public .1.3.6.1.2.1.1.1</span><br><span class="line">Variable = system.sysDescr.0</span><br><span class="line">Value    = String Linux flyinfort 4.15.0-70-generic #79~16.04.1-Ubuntu SMP Tue Nov 12 14:01:10 UTC 2019 x86_64</span><br><span class="line"></span><br><span class="line">End of MIB subtree.</span><br><span class="line"></span><br><span class="line">D:\workspace\softwares\snmputil&gt;SNMPUTIL.EXE walk 10.164.222.198 public .1.3.6.1.4.1.77.1.2.25.1.1</span><br><span class="line">End of MIB subtree.</span><br></pre></td></tr></table></figure>
<h3 id="环境搭建简介">环境搭建简介</h3>
<p>环境：Linux flyinfort 4.15.0-96-generic #97~16.04.1-Ubuntu SMP Wed Apr 1 03:03:31 UTC 2020 x86_64<br>
在这里使用easysnmp简单演示一下。<br>
easysnmp使用手册：<a href="https://easysnmp.readthedocs.io/en/latest/">https://easysnmp.readthedocs.io/en/latest/</a><br>
如果没有net-snmp的话，easysnmp是基于net-snmp的，首先要安装net-snmp。<br>
安装了net-snmp的话直接安装就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libsnmp-dev snmp-mibs-downloader</span><br></pre></td></tr></table></figure>
<p>net-snmp下载地址：<a href="http://www.net-snmp.org/">http://www.net-snmp.org/</a><br>
按照net-snmp的安装指南安装net-snmp：</p>
<ol>
<li>Run ./configure</li>
<li>Optionally edit include/net-snmp/net-snmp-config.h</li>
<li>make</li>
<li>Run the next command as root:</li>
<li>make install</li>
<li>configure the agent</li>
</ol>
<p>根据easysnmp的使用手册安装easysnmp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc python-dev</span><br><span class="line">pip install easysnmp</span><br></pre></td></tr></table></figure>
<p>easysnmp安装完了之后就可以使用easysnmp来进行一些操作了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from easysnmp import snmp_walk</span><br><span class="line">res = snmp_walk(&#x27;1.3.6.1.2.1.1.1&#x27;, hostname=&#x27;localhost&#x27;, community=&#x27;public&#x27;, version=2)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;SNMPVariable value=&#x27;Linux flyinfort 4.15.0-96-generic #97~16.04.1-Ubuntu SMP Wed Apr 1 03:03:31 UTC 2020 x86_64&#x27; (oid=&#x27;iso.3.6.1.2.1.1.1.0&#x27;, oid_index=&#x27;&#x27;, snmp_type=&#x27;OCTETSTR&#x27;)&gt;]</span><br></pre></td></tr></table></figure>
<p>关于更多easysnmp的操作可以在<code>https://easysnmp.readthedocs.io/en/latest/</code>,easysnmp的使用手册上查阅。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>techniques</category>
        <category>snmp</category>
      </categories>
      <tags>
        <tag>snmp</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：模糊测试</title>
    <url>/2022/02/14/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>软件安全分析与应用第6章模糊测试读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>模糊测试
<ul>
<li>基本原理与组成</li>
<li>基础方法与技术</li>
<li>模糊测试优化方法
<ul>
<li>灰盒</li>
<li>白盒</li>
<li>基于反馈的模糊测试</li>
</ul>
</li>
<li>分布式模糊测试
<ul>
<li>分布式控制结构</li>
<li>分布式模糊测试策略</li>
<li>动态适应机制</li>
</ul>
</li>
<li>典型工具与案例
<ul>
<li>Peach</li>
<li>Sulley</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="系统组成">系统组成</h2>
<ol>
<li>
<p>数据生成模块</p>
<p>负责批量生成测试用例，策略包含数据的语法格式与数据生成方法。数据生成方法包括字段数据的生成策略和字段数据的组合策略。</p>
<ul>
<li>字段生成</li>
<li>约束字段计算</li>
<li>复合字段组装</li>
<li>文件生成</li>
</ul>
</li>
<li>
<p>环境控制模块</p>
<p>负责测试对象的控制和运行环境的维护。测试对象控制的目标包含测试目标软件的启动、暂停、终止以及数据交互过程，此外还有测试服务目标网络连接的创建、传输、断开等。</p>
<ul>
<li>进程管理</li>
<li>环境管理</li>
<li>测试数据交互</li>
<li>残余信息清理</li>
</ul>
</li>
<li>
<p>状态监控模块</p>
<p>检测对象的运行状态，捕获程序执行过程中出现的异常，记录触发该异常的测试用例。</p>
<ul>
<li>异常捕获</li>
<li>异常现场保存</li>
<li>流量捕获</li>
<li>进程监控</li>
</ul>
</li>
</ol>
<h2 id="优化方法">优化方法</h2>
<h4 id="灰盒">灰盒</h4>
<p>通过逆向分析程序二进制代码和输入数据的标准格式，生成有针对性的违背数据格式规范的测试数据，从而提高模糊测试的效率。</p>
<h4 id="白盒">白盒</h4>
<p>结合符号执行可以有效提高模糊测试的效率。分析程序指令，将程序中内存于寄存器的值表示为输入变量的表达式，然后联立每个分支语句所代表的约束表达式，再用符号执行技术求出程序执行各路径分支的一个满足条件的测试用例。通过这些测试用例，可以覆盖更多的分支，实现在减少测试用例的同时提高代码覆盖率。</p>
<h4 id="基于反馈的模糊测试">基于反馈的模糊测试</h4>
<p>模糊测试过程是一个循环的反复测试过程，通过统计分析前序测试用例特征于测试结果特征，可以指导后续测试数据的生成，这称为基于反馈的模糊测试方法。</p>
<h2 id="分布式模糊测试">分布式模糊测试</h2>
<p>软件功能复杂性的增加使得通过硬件性能增长提高的模糊测试的效率变得微不足道，为了解决这个问题，使用分布式计算的方式，同时对多个程序进行测试，提高模糊测试效率。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：污点传播分析</title>
    <url>/2022/02/16/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E6%B1%A1%E7%82%B9%E4%BC%A0%E6%92%AD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件安全分析与应用第7章污点传播分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>污点传播分析
<ul>
<li>基本原理</li>
<li>主要方法
<ul>
<li>污点源识别</li>
<li>污点内存映射</li>
<li>污点动态跟踪</li>
<li>传播规则设计</li>
<li>污点误用检测</li>
</ul>
</li>
<li>典型系统
<ul>
<li>TaintCheck 系统</li>
<li>TEMU 系统</li>
<li>AOTA 系统</li>
</ul>
</li>
<li>典型实例分析
<ul>
<li>分析环境搭建</li>
<li>污点传播过程</li>
<li>污点回溯分析</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="应用领域">应用领域</h2>
<p>主要应用领域有：</p>
<ul>
<li>恶意代码检测(恶意代码通常依赖特定的外部数据)</li>
<li>软件漏洞挖掘(构造测试样本触发漏洞)</li>
<li>敏感数据泄漏(跟踪敏感数据)</li>
</ul>
<h2 id="主要方法">主要方法</h2>
<h4 id="污点源识别">污点源识别</h4>
<p>污点分析的第一项工作就是进行污点源的识别，而完整、高效的污点源识别是保证后续污点分析正确性的前提。<br>
目前，主要的污点源识别方法分为两类：</p>
<ul>
<li>无约束识别，所有外部数据识别为污点数据</li>
<li>有约束识别，只将特定数据识别为污点数据</li>
</ul>
<h4 id="污点内存映射">污点内存映射</h4>
<p>映射过程可以分为三种方法：</p>
<ul>
<li>简单映射</li>
<li>页表映射</li>
<li>复杂映射</li>
</ul>
<h4 id="污点动态跟踪">污点动态跟踪</h4>
<p>污点动态跟踪是污点分析主要的中间过程，也是整个分析过程中最为复杂的一项。在动态跟踪过程中，一般需要涉及3个阶段，即：</p>
<ul>
<li>污点指令监控</li>
<li>污点传播计算</li>
<li>污点状态更新（影子内存更新）</li>
</ul>
<h4 id="传播规则设计">传播规则设计</h4>
<ul>
<li>规则的完备性和精确性</li>
<li>面向原始指令或者中间指令</li>
<li>规则的分类和表示形式</li>
</ul>
<h4 id="污点误用检测">污点误用检测</h4>
<p>在污点传播计算的过程中，不仅要时刻跟踪记录污点的扩散情况，同时还需要在程序的“关键点”检测是否有污点数据被错误使用，即污点误用检测。<br>
另外在确定程序的关键点后，还需要给出相关的误用检测规则。</p>
<h2 id="典型系统">典型系统</h2>
<p>TaintCheck 是一套面向恶意代码自动检查、分析以及攻击特征生成的动态污点分析系统，接住了二进制代码插桩工具 Valgrind 来实现程序的动态跟踪。<br>
该工具主要由3个功能模块组成：</p>
<ul>
<li>TaintSeed</li>
<li>TaintTracker</li>
<li>TaintAssert</li>
</ul>
<p>TEMU 系统是著名的开元二进制分析平台 BitBlaze 的重要组成部分，主要负责完成程序的动态分析任务。与 TaintCheck 相比，TEMU 不仅在硬件模拟器 QEMU 的基础上实现了面向全系统跟踪的污点分析功能，同时通过基础污点分析引擎和丰富的调用接口实现了一套高可用的插件机制，利用该机制可以快速构建面向不同应用领域的污点分析应用系统。</p>
<p>AOTA 系统是一套面向 windows 大规模二进制应用程序的高实用性动态污点分析系统。该系统主要有以下特点：</p>
<ul>
<li>在硬件虚拟化平台上构建完全透明的动态分析环境</li>
<li>提供离线或者半在线污点分析，保证了对于大规模程序的分析效率</li>
<li>在系统级重放的基础上构建自动化分析与并行化分析过程</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：移动智能终端应用软件安全性分析</title>
    <url>/2022/02/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E7%A7%BB%E5%8A%A8%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件安全分析与应用第11章移动智能终端应用软件安全性分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>移动智能终端应用软件安全性分析
<ul>
<li>Android 系统安全框架
<ul>
<li>权限机制</li>
<li>沙箱</li>
</ul>
</li>
<li>Android 软件典型安全问题
<ul>
<li>隐私窃取</li>
<li>应用重打包</li>
<li>组件安全问题</li>
</ul>
</li>
<li>静态分析
<ul>
<li>权限分析</li>
<li>组件分析</li>
<li>代码分析</li>
<li>重打包应用检测</li>
</ul>
</li>
<li>动态分析
<ul>
<li>数据流分析</li>
<li>数据流分析工具</li>
<li>动态行为分析</li>
<li>动态行为分析工具</li>
</ul>
</li>
<li>实际案例</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Android-系统安全框架">Android 系统安全框架</h2>
<h4 id="权限机制">权限机制</h4>
<p>权限机制是 Android 安全机制的基础，Android 系统通过权限机制来控制每个应用可访问的资源或可执行的操作。</p>
<h4 id="沙箱隔离">沙箱隔离</h4>
<p>Android 系统除了为每个应用分配了不同的 UID 以使用更细粒度的权限管理机制，还未每个应用分配了一个 Dalvik 虚拟机实例，每一个应用程序及其 Dalvik 虚拟机运行于一个独立的 Linux 进程空间。<br>
底层 linux 系统的进程内存管理机制确保进程内容是独立的，而应用的权限确保不同应用的资源不能互相访问，于是形成了天然的隔离沙箱。</p>
<h2 id="Android-软件典型安全问题">Android 软件典型安全问题</h2>
<h4 id="隐私窃取">隐私窃取</h4>
<p>在用户不知情的情况下获得用户信息。</p>
<h4 id="应用重打包">应用重打包</h4>
<p>修改应用，添加恶意代码，并重新打包发布。</p>
<h4 id="组件安全问题">组件安全问题</h4>
<p>Android 应用程序有4个基本组件，分别为活动（activity）、服务（service）、内容提供者（content provider）、广播接收器（broadcast receiver）。<br>
这些组件出现的问题将会直接影响整个 Android 应用，存在的隐患有：</p>
<ul>
<li>组件暴露</li>
<li>Activity 覆盖攻击</li>
<li>Intent 劫持</li>
</ul>
<h2 id="静态分析">静态分析</h2>
<h4 id="权限分析">权限分析</h4>
<p>权限的使用一定程度上反映了应用程序可能具有的功能，因此通过权限使用来分析 Android 应用的安全性是一个直观的切入点。</p>
<h4 id="组件分析">组件分析</h4>
<p>Drozer 提供了针对组安全的分析检测功能，具体有：</p>
<ul>
<li>查找完整包名</li>
<li>列出被测应用的详细信息</li>
<li>列出被测应用暴露的组件</li>
<li>查看暴露的 Activity 组件信息</li>
<li>查看暴露的 Broadcast Receiver 组件信息</li>
<li>查看暴露的 Service 组件信息</li>
<li>查看暴露的 Content Provider 组件信息</li>
<li>列出可用的 URI</li>
<li>检查可以实施 SQL 租入攻击的 URI</li>
</ul>
<h4 id="代码分析">代码分析</h4>
<p>代码是实现应用功能的根本，所以分析 Android 应用中是否存在安全问题，最重要的是分析具体代码。<br>
典型的工具有：</p>
<ul>
<li>FlowDroid（流程图构建、污点传播分析）</li>
<li>Androguard（静态工具组合）</li>
<li>Androbugs（应用漏洞检测）</li>
<li>IDA Pro</li>
</ul>
<h4 id="重打包检测">重打包检测</h4>
<ul>
<li>签名检查</li>
<li>应用相似性检测</li>
<li>基于特征文件的相似性检测</li>
</ul>
<h2 id="动态分析">动态分析</h2>
<h4 id="数据流分析工具">数据流分析工具</h4>
<ul>
<li>Panda for Android</li>
<li>TaintDroid</li>
</ul>
<h4 id="动态行为分析">动态行为分析</h4>
<p>目前主流的动态行为分析技术有：</p>
<ul>
<li>动态调试技术</li>
<li>程序插桩技术</li>
<li>沙盒技术</li>
</ul>
<h4 id="动态行为分析典型工具">动态行为分析典型工具</h4>
<ul>
<li>Xposed框架</li>
<li>Anubis</li>
<li>DroidBox</li>
<li>金刚恶意软件智能分析系统</li>
</ul>
<h2 id="案例分析">案例分析</h2>
<ul>
<li>AndroidSSL 漏洞（漏洞分析）</li>
<li>恶意应用分析</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：程序切片</title>
    <url>/2022/01/28/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<p>软件安全分析与应用第4章程序切片读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>程序切片
<ul>
<li>概述
<ul>
<li>相关知识</li>
<li>基本原理</li>
</ul>
</li>
<li>静态切片
<ul>
<li>基于数据流</li>
<li>基于图可达性</li>
</ul>
</li>
<li>动态切片
<ul>
<li>基于程序依赖图</li>
<li>基于动态依赖图</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="概述">概述</h2>
<p>程序切片是指从程序中提取出满足一定约束条件的代码片段。</p>
<h4 id="相关知识">相关知识</h4>
<ol>
<li>控制流</li>
<li>数据流</li>
<li>代码块</li>
<li>可达性</li>
<li>活性分析</li>
<li>程序依赖图</li>
</ol>
<h4 id="基本原理">基本原理</h4>
<p><strong>静态程序切片</strong>主要有两种方法，即为基于数据流方程的方法和基于程序依赖图可达性的切片方法。<br>
<strong>动态切片</strong>是一种仅关注在给定某个输入条件下对程序中某点的变量有影响的语句，动态切片的发现来源于程序动态调试的需要。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：符号执行</title>
    <url>/2022/01/29/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>软件安全分析与应用第5章符号执行读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>符号执行
<ul>
<li>基本模型
<ul>
<li>程序语义</li>
<li>符号执行树</li>
</ul>
</li>
<li>动态符号执行技术
<ul>
<li>SAGE</li>
</ul>
</li>
<li>并行符号执行技术
<ul>
<li>SCORE</li>
<li>Cloud9</li>
<li>SAGEN</li>
</ul>
</li>
<li>选择符号执行技术</li>
<li>符号执行案例</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本模型">基本模型</h2>
<p>使用符号变量代替具体值作为程序或者函数的参数，并模拟执行程序中的指令，各指令的操作都基于符号变量进行，其中操作数的值由符号和常量组成的表达式来表示。</p>
<p>符号执行中的程序语义：</p>
<ol>
<li>符号数据对象</li>
<li>程序语句（变量操作/跳转语句）</li>
<li>程序执行状态</li>
</ol>
<h4 id="符号执行树">符号执行树</h4>
<p>执行树是用来描述程序执行路径的树形结构。执行树中的一个节点对应程序中的一条语句，程序语句之间的执行顺序或跳转关系对应执行树中节点间的边。</p>
<p>执行树具有以下特点：</p>
<ol>
<li>每一个叶节点都有一组对应输入，使得程序执行到该逻辑分支</li>
<li>不存在两个叶节点存在相同的输入</li>
</ol>
<h4 id="约束求解">约束求解</h4>
<p>每个叶节点对应的执行路径可以由一组具体输入指导程序运行得到，这一组输入值可以借助约束求解值得到。<br>
现在的主流约束求解器主要基于两种理论模型：</p>
<ol>
<li>SAT问题（求解由布尔变量集合所构成的布尔函数，检验是否存在变量的一种分布使得该函数的取值为1）</li>
<li>SMT问题（在SAT基础上发展而来，将SAT求解只能解决命题逻辑公式拓展为可以解决一阶逻辑所表达的公式）</li>
</ol>
<p>在大量的SMT求解器中，最出众的莫过于由微软研究院设计的 Z3 求解器。</p>
<h2 id="动态符号执行技术">动态符号执行技术</h2>
<p>动态符号执行的执行过程分为以下步骤：</p>
<ol>
<li>使用随机的具体值作为程序初始输入开始实际执行，同时对实际执行路径上的带吗进行符号执行，并从当前执行路径的分支条件语句的谓词中搜集所有符号约束条件机器对应的真值</li>
<li>根据收集到的符号约束条件，按照一定的路径选择策略，对其中的某个约束条件进行取反，构造新的可行的路径约束</li>
<li>使用约束求解器求解出新的约束集合对应的具体输入，接着使用符号执行引擎对新输入值进行新一轮的分析</li>
</ol>
<p><strong>分代搜索算法</strong>是 SAGE 的路径搜索算法，也是其技术核心。</p>
<h2 id="并行符号执行技术">并行符号执行技术</h2>
<p>并行结束与符号执行技术结合，需要解决的关键问题：</p>
<ol>
<li>分布式环境下的路径搜索策略</li>
<li>分布式环境下的负载均衡策略</li>
</ol>
<h2 id="选择符号执行">选择符号执行</h2>
<p>当测试程序执行到测试人员感兴趣的程序片段时，对代码进行符号执行分析，即对遇到的所有路径进行分析。对不感兴趣的外部调用函数，对代码进行大路径具体执行。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：绪论与基础知识</title>
    <url>/2022/01/24/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BB%AA%E8%AE%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>软件安全分析与应用第1章第2章绪论与基础知识读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>基础知识
<ul>
<li>处理器硬件架构基础
<ul>
<li>CPU结构介绍</li>
<li>保护模式</li>
<li>特权级</li>
<li>中断处理与异常处理</li>
<li>调试支持</li>
<li>虚拟化支持</li>
</ul>
</li>
<li>反汇编及对抗技术
<ul>
<li>汇编语言</li>
<li>反汇编</li>
<li>代码混淆</li>
<li>反调试</li>
</ul>
</li>
<li>Windows操作系统基础
<ul>
<li>PE文件结构</li>
<li>进程管理</li>
<li>线程管理</li>
<li>内存管理</li>
<li>对象与句柄管理</li>
<li>文件系统</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="处理器硬件架构基础">处理器硬件架构基础</h2>
<h4 id="保护模式">保护模式</h4>
<p>IA-32架构的 CPU 有两种工作模式：实模式和保护模式，工作模式受到 CR0 和 PE 标志位控制。</p>
<p>CPU 刚开始初始化后工作在实模式下，PE 标志位值为0，使用20位地址，寻址空间1MB；当操作系统启动时，将 CPU 的 PE 标志位置1，开启保护模式，使用32为地址，内存寻址空间拓展到4GB。</p>
<p>实模式不支持多线程，不能实现权限分级；保护模式下引入内存的分页和分段管理机制，实现了内存分页和权限分级，并支持多线程、多任务。</p>
<h4 id="特权级">特权级</h4>
<p>CPU 支持 Ring0, Ring1, Ring2, Ring3 共 4 个权限级别， windows 只使用了 Ring0 和 Ring3 两个。<br>
为了进行代码段和数据段间的特权级校验，需要 3 种类型的特权级支持：当前特权级、描述符特权级和请求特权级。</p>
<h4 id="调试支持">调试支持</h4>
<p>程序调试是软件开发过程中进行排错和查错的过程，需要 CPU 架构的支持。</p>
<p>IA-32 架构的 CPU 中，标志位寄存器 EFLAGS 中的 IF、TF 标志用于调试模式的开启，将 TF 置 1 使 CPU 处于单步执行状态，即调试状态，同时需要将 IF 置 1，开启 CPU 的中断响应。</p>
<h2 id="反汇编及对抗技术">反汇编及对抗技术</h2>
<h4 id="反汇编">反汇编</h4>
<p>反汇编是将机器语言转换成汇编代码的过程，将人类难以理解的机器语言转换成具有符号语义的指令语言。<br>
基本的反汇编流程包括4个步骤：</p>
<ol>
<li>确定反汇编代码区域，区分程序的代码和数据段。</li>
<li>确定了程序代码入口后，读取该位置的二进制机器指令，执行表查找，将机器码的值与它对应的汇编语言助记符提取出来，然后根据指令状态机提取操作数。</li>
<li>获取指令并解码出所有的操作数后，需要对它的汇编语言等价形式进行格式化，输出反汇编代码。</li>
<li>完成一条指令的反汇编之后，重复上述过程，直到反汇编完整个程序中的指令代码。</li>
</ol>
<p>对于如何选择下一条指令，有两种方法：</p>
<ol>
<li>线性扫描</li>
<li>递归下降</li>
</ol>
<h4 id="代码混淆">代码混淆</h4>
<p>代码混淆是一种将计算机程序代码转换成一种功能上等价，但是难以阅读和理解的变形。代码混淆可以分为程序源代码混淆和二进制代码混淆。</p>
<p>二进制代码混淆是应用最广泛的混淆手段，大致可以分为两大类：</p>
<ol>
<li>反反汇编，代码加密或者使反汇编出错</li>
<li>指令控制流混淆，加大反汇编和理解分析难度</li>
</ol>
<p>反反汇编又分为对抗静态和动态反汇编技术两种，针对对抗静态反汇编技术，主要方法是插入不完整指令或者数据，例如花指令。<br>
另外，加密、加壳技术对代码进行保护也是常用的方法。</p>
<h2 id="反调试">反调试</h2>
<p>在程序逆向分析行业里，动态调试分析是最常用的分析方法之一，它能够弥补静态分析中难以处理代码加壳和花指令等混淆的不足。<br>
常见的反调试技术：</p>
<ol>
<li>基于调试特征检测的反调试，检测程序 PEB 结构中的标志位 beingDebug 是否被置为非 0，除此之外还有多个同样功能的标志位。</li>
<li>基于调试特征隐藏代码，使用异常中断指令 int3，并在异常处理中执行核心代码，以隐藏核心代码</li>
</ol>
<h2 id="Windows-操作系统">Windows 操作系统</h2>
<h4 id="进程管理">进程管理</h4>
<p>进程是计算机中的程序关于特定数据集合上的一次运行活动，是系统进行资源调度和分配的基本单位。</p>
<p><strong>EPROCESS结构</strong>包括内核进程块、进程标识、退出状态、创建时间、退出时间、工作集信息、虚拟内存信息、异常端口、调试器端口、访问令牌、句柄表、设备映射表、进程环境块、映像基地址、进程优先级、windows 子系统进程块、作业对象等属性。</p>
<p><strong>KPROCESS</strong>内核进程块是EPROCESS块的一个组成部分，包含了进程对象的额外属性信息，也被成为进程控制块（PCB），包含了Windows内核在调度线程时所需的基本信息。</p>
<p><strong>PEB</strong>进程环境块是 EPROCESS 块中指针指向的一个结构，其中包括了有关进程对象的额外信息，该结构处于进程的用户态内存中，部分信息需要用户代码维护。</p>
<h4 id="线程管理">线程管理</h4>
<p>线程是程序执行流的最小单元，是进程中的一个实体，是被操作系统独立调度和分派的基本单位。线程本身独占系统资源，与同属一个进程的其他线程共享进程所拥有的全部资源。</p>
<p><strong>ETHREAD</strong>是线程的基本结构，包含了内核线程块指针、创建时间和退出时间、所属进程的id标识、线程启动地址、定时器等属性。</p>
<p><strong>KTHREAD</strong>是线程结构中关键的数据结构，位于系统内存内核空间，包含了windows内核为正在运行的线程执行线程调度和同步而需要访问的信息。</p>
<p><strong>TEB</strong>线程环境块也位于进程的用户地址空间。</p>
<h4 id="内存管理">内存管理</h4>
<p>windows中内存空间分为用户太内存地址和内核空间地址。<br>
windows系统使用内存管理器进行内存管理，主要负责两个任务：</p>
<ol>
<li>将进程虚拟地址空间转译到物理内存</li>
<li>内存不足时将数据换页到磁盘</li>
</ol>
<h4 id="对象与句柄管理">对象与句柄管理</h4>
<p>Windows 使用对象模型为执行体中实现的各种内部服务提供一致的、安全的访问途径，并设计了对象管理器负责创建、删除、保护和跟踪对象。</p>
<p>当一个进程根据名称来创建或者打开对象时，系统返回一个句柄，进程需要根据该句柄对该对象进行访问和管理。<br>
对象句柄是一个索引，只想与对象相关的句柄表中的表项，通过句柄访问对象比直接使用名称访问对象高想，因为对象管理器可以跳过名称查找过程直接找到目标对象。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：软件安全分析基础工具</title>
    <url>/2022/01/26/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>软件安全分析与应用第3章软件安全分析基础工具读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>软件安全分析基础工具
<ul>
<li>静态分析工具
<ul>
<li>IDA Pro</li>
<li>Udis86</li>
<li>Capstone</li>
<li>PEiD</li>
<li>010Editor</li>
</ul>
</li>
<li>动态分析工具
<ul>
<li>Process Monitor</li>
<li>Wireshark</li>
<li>OllyDbg</li>
<li>WinDbg</li>
<li>Pin</li>
</ul>
</li>
<li>虚拟化辅助分析平台
<ul>
<li>VMWare Workstation</li>
<li>VirtualBox</li>
<li>QEMU</li>
<li>Xen</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="静态分析工具">静态分析工具</h2>
<p>静态分析是指在不运行软件程序的情况下，利用分析工具，采用语法分析、词法分析、控制流与数据流分析等技术手段对软件程序进行扫描。</p>
<h4 id="IDA-Pro">IDA Pro</h4>
<p>IDA Pro 是一款交互式的反汇编工具，简称 IDA。支持 Windows、Linux、Mac OS等主流操作系统，支持 Interl x86/x64、ARM、MIPS等数十种指令集的反汇编。</p>
<p>IDA 的常用功能有：</p>
<ol>
<li>反汇编，使用递归下降算法进行代码扫描，结果可以使用控制流图和地址顺序排列</li>
<li>反编译，将对应汇编代码反编译成 C/C++ 代码</li>
<li>导入表与导出表解析，导入表记录了程序调用的但执行代码不再程序中而在程序中，而在动态库文件（dll/so）的函数中，导出表是动态库文件特有的，记录了供其他动态库或程序模块调用的函数</li>
<li>函数符号表功能，pdb格式的符号库，通过符号表可以获得更多的语义信息用于逆向分析</li>
<li>查找功能，支持基于文本的查找和基于引用的查找</li>
<li>插件功能</li>
</ol>
<h4 id="Udis86">Udis86</h4>
<ol>
<li>Udis86 开发接口，是 Udis86 提供的一套反汇编第三方库，用户可以自行编写代码进行拓展</li>
<li>基于 Udis86 的反汇编工具，提供命令行，可以快速进行反汇编</li>
</ol>
<h4 id="Capstone">Capstone</h4>
<ol>
<li>Python 开发接口</li>
<li>C 语言开发接口</li>
</ol>
<h4 id="PEiD">PEiD</h4>
<p>PEiD 是 Windows 平台下常用的 PE 文件格式分析工具，用于提取 exe、dll、sys 等标准可执行程序的文件结构，也常用于检测程序加壳。目前该工具已经停止了更新。<br>
使用该工具可以进行：</p>
<ol>
<li>PE 格式信息提取</li>
<li>插件拓展与脱壳处理</li>
</ol>
<h4 id="010Editor">010Editor</h4>
<p>使用该工具可以进行文本编辑和文件编辑功能：</p>
<ol>
<li>文本编辑，支持文本编辑、二进制编辑以及十六进制编辑等</li>
<li>范本分析，该工具的特斯，用于对文件格式进行解析，提取文件的格式字段内容。</li>
</ol>
<h2 id="动态分析工具">动态分析工具</h2>
<h4 id="Pocess-Monitor">Pocess Monitor</h4>
<p>该工具是一款 Windows 下的进程监控工具，主要用于进程行为监控与记录，包括文件操作行为、注册表操作行为、网路行为等。<br>
具体功能如下：</p>
<ol>
<li>进程监控功能</li>
<li>文件监控功能</li>
<li>注册表监控</li>
<li>网络监控</li>
</ol>
<h4 id="Wireshark">Wireshark</h4>
<p>主要功能：</p>
<ol>
<li>流量采集功能</li>
<li>协议分析功能</li>
</ol>
<h4 id="OllyDbg">OllyDbg</h4>
<p>该工具是 Windows 平台反汇编动态调试追踪工具，只支持 Ring3 界的的用户态程序，主要功能有：</p>
<ol>
<li>调试功能</li>
<li>Trace 功能</li>
</ol>
<h4 id="WinDbg">WinDbg</h4>
<p>主要功能：</p>
<ol>
<li>符号功能</li>
<li>调试功能</li>
<li>命令介绍</li>
<li>内核调试</li>
</ol>
<h4 id="Pin">Pin</h4>
<p>Pin 是一块二进制代码插桩分析框架，提供 4 种粒度的代码插桩模式：INS 级别、TRACE 级别、RTN 级别和 IMG 级别。</p>
<h2 id="虚拟化辅助分析平台">虚拟化辅助分析平台</h2>
<h4 id="VMWare-Workstation">VMWare Workstation</h4>
<h4 id="VirtualBox">VirtualBox</h4>
<h4 id="QEMU">QEMU</h4>
<h4 id="Xen">Xen</h4>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：网络协议逆向分析</title>
    <url>/2022/02/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件安全分析于应用第10章网络协议逆向分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>网络协议逆向分析
<ul>
<li>格式逆向
<ul>
<li>字段划分</li>
<li>字段间关系识别</li>
<li>字段功能语义恢复</li>
</ul>
</li>
<li>状态机恢复
<ul>
<li>消息类型识别</li>
<li>状态机推断和化简</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="格式逆向">格式逆向</h2>
<h4 id="字段划分">字段划分</h4>
<ul>
<li>基于分隔符的划分方法</li>
<li>基于消息处理指令上下文差异的划分方法</li>
<li>基于字段来源回溯的划分方法</li>
</ul>
<h4 id="字段间关系识别">字段间关系识别</h4>
<ul>
<li>基于分隔符作用域的字段关系恢复</li>
<li>长度字段识别</li>
</ul>
<h4 id="字段功能语义识别">字段功能语义识别</h4>
<ul>
<li>基于字符串比较指令分析的关键字识别</li>
<li>基于运行环境语义的字段语义恢复</li>
</ul>
<h2 id="状态机恢复">状态机恢复</h2>
<h4 id="消息类型识别">消息类型识别</h4>
<ul>
<li>基于关键字的消息类型识别</li>
<li>基于消息文本特征的分类方法</li>
</ul>
<h4 id="状态机推断和化简">状态机推断和化简</h4>
<ul>
<li>遍历</li>
<li>合并</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：动态污点分析</title>
    <url>/2022/01/22/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%8A%A8%E6%80%81%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析技术第10章动态污点分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>动态污点分析
<ul>
<li>基本原理</li>
<li>方法实现</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>TaintCheck</li>
<li>Argos</li>
<li>TaintDroid</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>动态污点分析在程序运行的基础上，对数据流或者控制流进行监控，从而实现对数据在内存中的显式传播、数据误用等操作进行跟踪和检测。<br>
根据流，动态污点分析可以归类为：</p>
<ol>
<li>基于数据流的</li>
<li>基于控制流的<br>
根据范围，动态污点分析可以归类为：</li>
<li>用户进程级</li>
<li>全系统级</li>
</ol>
<p>动态污点分析的基本步骤有：</p>
<ol>
<li>污点数据标记</li>
<li>污点动态跟踪</li>
<li>污点误用检查</li>
</ol>
<p>优点是低误报和高可信。</p>
<p>缺点是：</p>
<ol>
<li>漏报率高</li>
<li>平台相关性高</li>
<li>资源消耗大</li>
</ol>
<h2 id="实现">实现</h2>
<p>动态代码插桩：在被分析的程序的控制流中，插入用户定义的代码，从而对程序的行为进行监控的方法。</p>
<p>根据时机的不同，可以被分为：</p>
<ol>
<li>源代码插桩</li>
<li>编译时插桩</li>
<li>链接时插桩</li>
<li>运行时插桩</li>
</ol>
<p>污点敏感点，即 Sink 点，是污点数据有可能被误用的指令或者系统调用。主要可以分为：</p>
<ol>
<li>跳转地址</li>
<li>格式化字符串</li>
<li>系统调用参数</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p><strong>TaintCheck</strong>：基于开源的x86模拟器Valgrind设计实现，先将机器指令翻译成为 ucode,然后将 ucode 传递给TaintCheck，根据指令类型执行相应的操作或者报警。<br>
<strong>Argos</strong>：主要用作主机蜜罐，分析被检测到的攻击，检测 0day 漏洞攻击。<br>
<strong>TrainDroid</strong>：针对安卓应用的动态监测软件。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>dynamic taint analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全分析与应用：软件漏洞挖掘与分析</title>
    <url>/2022/02/18/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件安全分析与应用第9章软件漏洞挖掘与分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>软件漏洞挖掘与分析
<ul>
<li>基础知识
<ul>
<li>典型漏洞类型
<ul>
<li>溢出（堆、栈、整数）</li>
<li>重用（use after free）</li>
<li>web漏洞（sql、xss）</li>
</ul>
</li>
<li>漏洞利用</li>
<li>漏洞防护</li>
</ul>
</li>
<li>软件漏洞机理分析
<ul>
<li>脆弱点分析</li>
<li>路径分析</li>
<li>内存分布分析</li>
<li>分析实例</li>
</ul>
</li>
<li>软件漏洞利用
<ul>
<li>攻击链构造</li>
<li>攻击路径出发</li>
<li>保护机制绕过</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基础">基础</h2>
<p>利用漏洞可以进行：</p>
<ul>
<li>执行代码</li>
<li>信息窃取</li>
<li>权限提升</li>
<li>拒绝服务</li>
<li>认证绕过</li>
</ul>
<h4 id="典型漏洞类型">典型漏洞类型</h4>
<ul>
<li>栈溢出</li>
<li>堆溢出</li>
<li>重用（use after free）</li>
<li>整数溢出</li>
<li>其他（sql、xss）</li>
</ul>
<h4 id="漏洞利用技术">漏洞利用技术</h4>
<p><strong>内存喷射</strong>技术的代表技术是堆喷射技术（heap spray），主要用于攻击IE、Firefox浏览器等常用软件。传统堆喷射技术的关键在于，在内存中申请大量的具有固定大小的对象，在其中填入相同内容，每一个对象中间都含有若干NOP指令序列和攻击代码，这样使得进程的地址空间被大量的注入代码所占据。在程序的控制流被劫持时，大量的包含攻击代码的碎片能够提高EIP转移达到目标的概率，碎片中的NOP指令形成指令缓冲区，使得EIP转移目标仅需要在一定的误差范围内，即可引发攻击代码的执行。</p>
<ul>
<li>NOP：空指令</li>
<li>EIP：寄存器，存储cpu要读取的地址</li>
</ul>
<p><strong>ROP</strong>（Return-Oriented Programming），是指攻击者从已有的库或者可执行文件中提取指令片段，构建攻击代码。</p>
<p><strong>基于内存地址信息泄漏构造利用</strong>，由于DEP和ASLR的同时使用，使得攻击者即使能够找到ROP代码片段，也很难在内存中关联起来。对此有两种方法解决：</p>
<ul>
<li>寻找未随机化的模块</li>
<li>针对全部模块都被随机化的情况，利用程序在运行时泄漏的信息来构造 ROP</li>
</ul>
<h4 id="漏洞防护">漏洞防护</h4>
<p>针对软件漏洞的形成机理和利用方法，研究人员也提出了与之对应的防护方法，主要包括针对栈溢出的 Stack Cookie，针对堆溢出的 SAFE 堆释放操作，针对控制流劫持攻击的数据区执行保护（Data Execution Protection, DEP)和地址随机化（Address Space Layout Randomization, ASLR）等机制。<br>
<strong>Stack Cookie</strong>在堆栈中保存一个cookie值，如果堆栈溢出该数据被覆盖则停止执行。<br>
<strong>DEP</strong>面对的主要目标是缓冲区溢出，缓冲区溢出攻击需要在数据段写可执行的攻击代码，然后劫持控制流转移到攻击代码。具体实现方法是将数据段代码标记为不可执行代码。<br>
<strong>ASLR</strong>也是针对缓冲区溢出的保护措施，通过堆、栈、动态库等布局的随机化，增加攻击者的攻击难度。主要对以下4类地址进行随机化：</p>
<ul>
<li>堆地址</li>
<li>栈基址</li>
<li>PE文件映像基址</li>
<li>进程环境块</li>
</ul>
<h2 id="机理分析">机理分析</h2>
<h4 id="路径分析">路径分析</h4>
<ul>
<li>基于污点传播的路径指令序列提取</li>
<li>基于符号执行的路径条件提取</li>
</ul>
<h4 id="内存布局分析">内存布局分析</h4>
<ul>
<li>输入数据直接映射</li>
<li>输入数据可逆计算后映射</li>
</ul>
<p>使用经过修改的污点传播算法可以进行数据映射的分析.</p>
<h2 id="漏洞利用">漏洞利用</h2>
<p>漏洞利用有：</p>
<ul>
<li>攻击链构建</li>
<li>攻击路径触发</li>
<li>保护机制绕过</li>
</ul>
<h4 id="攻击链构建">攻击链构建</h4>
<p>攻击链构建的目标是在内存中找到能够放置控制流转移代码的空间，在放入控制流代码转移后，使得被劫持的控制流能够顺利转移到 ShellCode.<br>
常见的跳板指令有：</p>
<ul>
<li>call/jmp register</li>
<li>calljmp [register+offset]</li>
<li>连续指令序列</li>
</ul>
<h4 id="攻击路径触发">攻击路径触发</h4>
<p>攻击路径触发是漏洞利用中较为重要的一环，最终利用的生成是通过重构输入的方式实现的，其目标是通过构造输入数据，使程序能够执行到控制流劫持点。</p>
<h4 id="保护机制绕过">保护机制绕过</h4>
<p>操作系统使用了数据执行保护、堆栈 cookie、ASLR 等技术对可能发生的漏洞攻击进行保护。所以攻击者需要对此类保护机制进行绕过，常用的方法有：</p>
<ul>
<li>pop+jmp 间接控制 EIP</li>
<li>调用 API 关闭 DEP</li>
<li>JIT Spraying</li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：基于二进制代码对比的漏洞分析</title>
    <url>/2022/01/22/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%9F%BA%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析技术第12章基于二进制代码对比的漏洞分析。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>基于二进制代码对比的漏洞分析
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>文本</li>
<li>图同构</li>
<li>结构化</li>
<li>软件补丁</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Bindiff</li>
<li>Eye Binary Diffing Suite</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p><strong>补丁对比技术</strong>是一种通过对比打补丁前后的目标代码，分析发现两个版本的程序之间差异的技术。<br>
<strong>二进制代码对比</strong>最终目的是寻找打补丁前后程序的差异。有以下几种方法：</p>
<ol>
<li>基于文本的对比，输出结果范围大，漏洞定位精度差，误报率高</li>
<li>基于图同构的对比，指令级和函数级图同构对比，受编译器优化影响大</li>
<li>基于结构化对比，受编译器影响大，存在局部影响全局的问题</li>
<li>综合对比技术</li>
</ol>
<h2 id="实例分析">实例分析</h2>
<p>以CNNVD-201112-203为例，进行实例分析流程如下：</p>
<ol>
<li>漏洞信息搜集</li>
<li>搭建测试环境</li>
<li>补丁对比（获取汇编代码差异，明确分析对象到具体的目标函数和子函数）</li>
<li>静态分析（定位发生问题的代码）</li>
<li>动态调试（验证猜想）</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p><strong>Bindiff</strong>是针对二进制文件差异型对比工具，协助安全人员迅速找到反汇编代码的差异之处和相似之处。<br>
<strong>Eye Binary Diffing Suite</strong> 使用了基于结构化签名的对比算法，并且使用其他方法作为辅助。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：定理证明</title>
    <url>/2022/01/21/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>软件漏洞分析技术第8章定理证明读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>定理证明
<ul>
<li>基本原理
<ul>
<li>技术框架</li>
<li>特点</li>
</ul>
</li>
<li>方法实现
<ul>
<li>程序转换</li>
<li>属性描述</li>
<li>定理证明</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Saturn</li>
<li>ESC/Java</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>定理证明的基本步骤：</p>
<ol>
<li>用逻辑的方法将系统规范的功能和性质形式化为逻辑形式的模型</li>
<li>将系统设计实现也形式化为逻辑形式的模型</li>
<li>用数学定理进行推导证明实现的模型等价于或者蕴含规范的模型</li>
</ol>
<p>定理证明的优点：</p>
<ol>
<li>误报率很低</li>
<li>可以处理无限状态空间问题</li>
<li>只要程序表达为规范形式，就可以进行推理验证安全属性</li>
</ol>
<p>定理证明的缺点：</p>
<ol>
<li>需要程序员输入额外注释</li>
<li>交互式定理证明系统需要与用户交互</li>
<li>形式化程序转化为定理表达式存在困难，并且证明推理过程过于抽象，缺乏运行过程信息</li>
<li>漏洞产生过程的能力较差</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p><strong>Saturn</strong>：该工具的实现主要基于函数abstract，同时基于条件约束进行分析。<br>
<strong>ESC/Java</strong>：该工具用来检测 Java 漏洞。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：基于模式的漏洞分析</title>
    <url>/2022/01/22/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析技术第11章基于模式的漏洞分析。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>基于模式的漏洞分析
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>反汇编分析</li>
<li>逆向中间表示</li>
<li>漏洞模式建模</li>
<li>漏洞模式检测</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>BinNavi</li>
<li>BAP</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>基于模式的漏洞分析基本步骤：</p>
<ol>
<li>建立漏洞模式</li>
<li>对二进制程序进行反汇编，获得汇编代码</li>
<li>将汇编代码转化为中间表示</li>
<li>中间表示的漏洞模式匹配</li>
</ol>
<p>二进制文件结构，根据平台不同有不同的文件格式：</p>
<ol>
<li>Windows 下的 PE（portable executable）</li>
<li>UNIX 下的 ELF（Executable and Linkable Format）</li>
<li>iOS 与 Mac OS 的 Mach-O（Mach object）</li>
</ol>
<h2 id="方法实现">方法实现</h2>
<p>由于x86指令集非常复杂，难以建立漏洞模式，所以需要对汇编代码进一步抽象，转化为中间表示建立漏洞模式。<br>
反汇编的基本算法：</p>
<ol>
<li>确定反汇编代码区域</li>
<li>确定指令的起始地址</li>
<li>读取初始地址的值，执行一次表查找，对应二进制操作码的值和汇编语言助记符</li>
<li>获取指令与操作数，等价转化成汇编语言</li>
<li>下一条指令，并重复3-5</li>
</ol>
<p>当前最主要的反汇编策略：</p>
<ol>
<li>线性扫描策略，不能区分数据和代码</li>
<li>控制流递归扫描，不能处理间接代码路径，如指针寻址跳转等</li>
</ol>
<p>反汇编的不足之处：</p>
<ol>
<li>代码与数据的区分</li>
<li>静态反汇编工具不能得到动态信息</li>
<li>指令长度可变</li>
</ol>
<p>漏洞建模一般从两个层面考虑：</p>
<ol>
<li>特定漏洞的模式</li>
<li>通用漏洞的模式</li>
</ol>
<p><strong>漏洞模式检测</strong><br>
在模式抽取的基础上，才能进行后续的漏洞模式的检测，抽取的内容有：</p>
<ol>
<li>抽取可控变量</li>
<li>抽取约束条件</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p><strong>BinNavi</strong>：能够分析输入数据流在程序中的传播路径，将程序控制流图形化表示，辅助分析人员。<br>
<strong>BAP</strong>：基于中间语言进行漏洞分析。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：数据流分析</title>
    <url>/2022/01/19/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析第4章数据流分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>数据流分析
<ul>
<li>基本原理
<ul>
<li>基本概念
<ul>
<li>程序路径
<ul>
<li>流不敏感</li>
<li>流敏感</li>
<li>路径敏感</li>
</ul>
</li>
<li>路径范围
<ul>
<li>过程内（函数内）</li>
<li>过程间（函数间）</li>
</ul>
</li>
</ul>
</li>
<li>检测程序漏洞</li>
<li>辅助支持技术</li>
</ul>
</li>
<li>方法实现
<ul>
<li>检测</li>
<li>作为辅助技术</li>
</ul>
</li>
<li>实例分析
<ul>
<li>检测</li>
<li>作为辅助技术</li>
</ul>
</li>
<li>典型工具
<ul>
<li>Fortify SCA</li>
<li>Coverity Prevent</li>
<li>FindBugs</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="基本原理">基本原理</h3>
<p>在应用数据流分析直接进行漏洞检测时，可以通过词法分析、语法分析、控制流分析以及其他程序分析技术对代码进行分析，将程序代码转化为抽象语法树（abstract syntax tree, AST）、三地址码（three address code, TAC）等关键代码中间表示，并且获得程序的控制流图、调用图等数据结构。</p>
<h3 id="方法实现">方法实现</h3>
<p><strong>抽象语法树</strong>：抽象语法树是程序抽象语法结构的树状表现形式。<br>
<strong>三地址码</strong>：三地址码类似汇编指令，有不多于三个的运算分量。<br>
<strong>静态单赋值形式</strong>：静态单赋值形式是一种程序语句或者指令的表示形式，其代码通常是指静态单赋值形式的三地址码。<br>
<strong>控制流图</strong>：控制流图通常是指用于描述程序过程内的控制流的有向图。<br>
<strong>调用图</strong>：调用图是描述程序中函数之间的调用和被调用关系的有向图。</p>
<h4 id="漏洞分析规则">漏洞分析规则</h4>
<ol>
<li>规则的状态机模型</li>
<li>变量取值相关的检测规则</li>
</ol>
<h4 id="辅助分析">辅助分析</h4>
<ol>
<li>指向分析</li>
<li>取值分析</li>
</ol>
<h3 id="典型工具">典型工具</h3>
<p><strong>Fortify SCA</strong>：通过分析应用程序可能会执行的所有路径，从源代码层次识别软件的漏洞，并提供完整的漏洞分析报告。该工具主要有四个部分组成：</p>
<ol>
<li>前端，用于源代码的分析。</li>
<li>分析引擎，包括数据流引擎、语义疫情、结构引擎、控制流引擎和配置引擎。</li>
<li>分析规则库，不同缺陷类型的分析规则。</li>
<li>审计工作台或控制管理界面，驱动整个分析过程。</li>
</ol>
<p><strong>Coverity Prevent</strong>:与 Fortiy SCA 相似，但是 Coverity Prevent 比较重视检测的深度和精度。</p>
<p><strong>FindBugs</strong>：该工具倾向于使用简单的、应用范围更广的技术来检测漏洞，而不是使用复杂的、特定的程序缺陷技术。主要分析单线程正确性问题、线程同步正确性问题、性能问题和程序安全问题。该工具的主要检测器有：</p>
<ol>
<li>类结构和类的层级结构的分析。</li>
<li>线性扫描代码。</li>
<li>程序结构分析。</li>
<li>数据流分析。</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：智能灰盒测试</title>
    <url>/2022/01/22/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%99%BA%E8%83%BD%E7%81%B0%E7%9B%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>软件漏洞分析技术第13章智能灰盒测试读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>智能灰盒测试
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>动态符号执行</li>
<li>路径控制与定向遍历</li>
<li>路径约束求解</li>
<li>漏洞触发数据生成</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Dart</li>
<li>Smart fuzzing</li>
<li>BitBlaze</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>二进制漏洞分析中应用最普遍的方法是模糊测试（fuzzing），但是存在着明显的缺陷，测试用例的生成存在盲目性。<br>
该盲目性产生与两个方面：</p>
<ol>
<li>没有结合系统具体代码实现（没有系统的先验知识）</li>
<li>测试用例独立</li>
</ol>
<p>针对这些问题，测试方法转向智能模糊测试（smart fuzzing），通过先验知识提高测试用例的有效率。具体的方法有：</p>
<ol>
<li>符号执行，增加覆盖率</li>
<li>路径控制，去除冗余无效用例</li>
<li>…</li>
</ol>
<p>智能灰盒测试基本步骤：</p>
<ol>
<li>静态分析，将二进制程序反汇编然后转化成为中间语言表示</li>
<li>符号执行收集路径条件</li>
<li>利用约束求解工具，求解能够执行的路径</li>
<li>针对此类路径生成测试用例</li>
</ol>
<h2 id="方法实现">方法实现</h2>
<p>动态符号执行获取程序可能的执行路径。</p>
<p>路径控制与定向遍历增强漏洞分析的针对性，采用模式匹配等静态分析的方法，识别出漏洞相关路径，并重点对漏洞相关路径进行遍历，提高漏洞分析的准确率。</p>
<p>漏洞触发数据可以分为漏洞触发条件建模、触发条件与路径条件求解和漏洞触发的输入数据三步。</p>
<h2 id="实例分析">实例分析</h2>
<p>智能灰盒测试技术力图避免盲目地对路径进行搜索遍历。<br>
智能灰盒测试的基本步骤为：</p>
<ol>
<li>静态分析技术识别出待测试代码区域</li>
<li>动态二进制插桩技术跟踪目标程序执行路径</li>
<li>设计动态污点分析方案对路径进行分析，并使用覆盖关键路径的策略进行代码敏感区域逼近</li>
<li>约束求解方法计算覆盖敏感区域的执行路径相对应的程序输入</li>
<li>自动化测试</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p><strong>Dart</strong>使用导向性随即测试金属进行漏洞检测。<br>
<strong>Smart fuzzing</strong>采用动静结合的方式，将程序的执行流程导向最容易触发漏洞的状态空间，提升 fuzzing 效率。<br>
<strong>BitBlaze</strong>同样采用动静结合的方式对二进制程序进行分析。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：模型检测</title>
    <url>/2022/01/21/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>软件漏洞分析技术第7章模型检测读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>模型检测
<ul>
<li>基本原理
<ul>
<li>技术框架</li>
<li>技术特点</li>
</ul>
</li>
<li>方法实现
<ul>
<li>程序建模</li>
<li>安全缺陷属性描述</li>
<li>程序漏洞检测</li>
</ul>
</li>
<li>实例分析
<ul>
<li>线性时序逻辑检查</li>
<li>分布式软件漏洞检测</li>
</ul>
</li>
<li>典型工具
<ul>
<li>SLAM</li>
<li>MOPS</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>模型检测（model checking）基于状态转换系统来判断程序的安全性质，基本分析步骤如下：</p>
<ol>
<li>将软件构造为状态机等抽象模型</li>
<li>使用模态/时序逻辑公式等形式化表达描述安全属性</li>
<li>对模型进行遍历验证安全属性，判断是否存在漏洞</li>
</ol>
<p>该方法优点有：</p>
<ol>
<li>自动化程度高</li>
<li>可以检测多种属性</li>
<li>对有限状态系统而言，算法可终止</li>
<li>模型检测能够给出诊断信息</li>
</ol>
<p>该方法的不足有：</p>
<ol>
<li>状态空间爆炸</li>
<li>建模时，对时序、执行路径等安全属性边界的近似处理难度大</li>
<li>软件中可能存在数据无限性和控制无限性</li>
<li>检测对象为抽象模型，最终结果准确性取决于模型的准确性</li>
</ol>
<h2 id="安全缺陷属性描述">安全缺陷属性描述</h2>
<p>安全缺陷属性是指对实际编程开发中发现的不良变成习惯、程序逻辑错误代码等质量缺陷代码进行总结抽象，然后使用形式化语言描述建模形成用于检测的时序模式。</p>
<p><strong>检测算法</strong>：模型检测算法比较多，如 labeling算法、fixpoint算法等。</p>
<h2 id="典型工具">典型工具</h2>
<p><strong>SLAM</strong>：该工具的应用对象是 windows 设备驱动程序，检测 API 库函数是否遵循文档说明中给出的使用规则。该工具可以对c程序进行自动抽象建模和验证。<br>
<strong>MOPS</strong>：MOPS 是用于c语言程序漏洞和防御规则的一致性检测的工具。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：污点分析</title>
    <url>/2022/01/21/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析技术第5章读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>污点分析
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>基于数据流</li>
<li>基于依赖关系</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Pixy</li>
<li>TAJ</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>污点分析的一般步骤：</p>
<ol>
<li>识别污点信息的产生，并且标记污点信息</li>
<li>利用特定规则跟踪分析污点信息在程序中的传播过程</li>
<li>在关键点检测程序操作是否会受到污点信息的影响</li>
</ol>
<p>基于污点分析的漏洞挖掘可以通过两种方式实现：</p>
<ol>
<li>基于数据流的污点分析</li>
<li>基于依赖关系的污点分析（污点数据控制流）</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：模糊测试</title>
    <url>/2022/01/22/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>软件漏洞分析技术第9章模糊测试读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>模糊测试
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>输入数据关联分析</li>
<li>测试用例构建</li>
<li>测试异常分析</li>
<li>框架</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Peach</li>
<li>Sulley</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="概念">概念</h2>
<p>模糊测试是当前最流行的黑盒测试方法，基本步骤有：</p>
<ol>
<li>向待测程序提供大量特殊构造的数据作为输入</li>
<li>监视程序的运行过程中产生的异常并且记录导致异常的输入</li>
<li>人工进一步定位漏洞位置</li>
</ol>
<h2 id="方法实现">方法实现</h2>
<p>了解程序对于数据的结构化要求，有针对性地通过变异或者生成的方式构建测试用例。<br>
对于复杂的数据格式，使用数据块模型进行描述。<br>
常用的测试用例构造算法有：</p>
<ol>
<li>随机</li>
<li>强制性测试</li>
<li>预先生成测试用例</li>
<li>遗传算法</li>
<li>错误注入与模糊式启发</li>
</ol>
<h4 id="测试异常分析">测试异常分析</h4>
<p>在模糊测试过程中，首先通过分类过滤并获取程序的某些运行时信息（尤其是异常发生时的），对记录下来的信息进行重点分析。<br>
具体的监控方法有：</p>
<ol>
<li>系统调试接口</li>
<li>异常即时过滤</li>
<li>异常影响分析与漏洞危害判定</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p><strong>Peach</strong>：代码可以重用，并且能够在使用过程中变得更加智能。<br>
<strong>Sulley</strong>：该工具的特点有使用简单且极富弹性，日志记录丰富且可以重现测试用例，代码可重用性高，基于路径的分析，追踪、代码覆盖度和度量，错误检测和恢复。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：漏洞分析基础</title>
    <url>/2022/01/16/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>软件漏洞分析技术漏洞分析基础部分读书笔记。</p>
<span id="more"></span>
<h2 id="软件漏洞">软件漏洞</h2>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>漏洞
<ul>
<li>漏洞概述
<ul>
<li>漏洞定义</li>
<li>漏洞特点
<ul>
<li>持久性与时效性</li>
<li>广泛性与具体性</li>
<li>可利用性与隐蔽性</li>
</ul>
</li>
</ul>
</li>
<li>漏洞分类与分级
<ul>
<li>漏洞分类
<ul>
<li>早期漏洞分类</li>
<li>多维度漏洞分类</li>
<li>综合性漏洞分类</li>
<li>漏洞库中的漏洞分类</li>
</ul>
</li>
<li>漏洞分级
<ul>
<li>CNNVD</li>
<li>微软</li>
<li>US-CERT</li>
<li>CVSS</li>
</ul>
</li>
</ul>
</li>
<li>漏洞的影响</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="漏洞分析发展历程">漏洞分析发展历程</h2>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>漏洞分析发展历程
<ul>
<li>软件漏洞分析
<ul>
<li>广义漏洞分析
<ul>
<li>漏洞挖掘</li>
<li>漏洞检测</li>
<li>漏洞应用</li>
<li>漏洞消除</li>
<li>漏洞管控</li>
</ul>
</li>
<li>狭义漏洞分析
<ul>
<li>特指漏洞挖掘</li>
<li>架构安全分析</li>
<li>源代码漏洞分析</li>
<li>二进制漏洞分析</li>
<li>运行系统漏洞分析</li>
</ul>
</li>
</ul>
</li>
<li>原始萌芽阶段
<ul>
<li>通信安全</li>
<li>分析萌芽</li>
<li>信息加密</li>
</ul>
</li>
<li>初步发展阶段
<ul>
<li>计算机安全</li>
<li>单一化漏洞挖掘</li>
<li>操作系统防护</li>
</ul>
</li>
<li>高速发展阶段
<ul>
<li>互联网安全</li>
<li>多样化漏洞分析</li>
<li>信息系统防护</li>
</ul>
</li>
<li>综合治理阶段
<ul>
<li>网际安全</li>
<li>系统化漏洞管控</li>
<li>防御体系建设</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="漏洞分析技术概述">漏洞分析技术概述</h2>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>漏洞分析技术概述
<ul>
<li>漏洞分析技术体系</li>
<li>软件架构安全分析
<ul>
<li>形式化架构分析技术</li>
<li>工程化架构分析技术</li>
</ul>
</li>
<li>源代码漏洞分析
<ul>
<li>基于中间表示的分析技术
<ul>
<li>数据流分析</li>
<li>符号执行</li>
<li>污点分析</li>
</ul>
</li>
<li>基于逻辑推理的分析技术
<ul>
<li>模型检测</li>
<li>定理证明</li>
</ul>
</li>
</ul>
</li>
<li>二进制漏洞分析
<ul>
<li>静态漏洞分析技术</li>
<li>动态漏洞分析技术</li>
<li>动静结合的漏洞分析技术</li>
</ul>
</li>
<li>运行系统漏洞分析
<ul>
<li>信息收集
<ul>
<li>网络拓扑</li>
<li>操作系统</li>
<li>应用软件</li>
<li>公开资产</li>
</ul>
</li>
<li>漏洞检测
<ul>
<li>配置管理检测
<ul>
<li>MBSA</li>
<li>Metasploit</li>
</ul>
</li>
<li>通信协议验证
<ul>
<li>Nessus</li>
<li>Nmap</li>
</ul>
</li>
<li>授权认证检测
<ul>
<li>Nessus</li>
<li>WebScarab</li>
</ul>
</li>
<li>数据验证测试
<ul>
<li>WVS</li>
<li>AppScan</li>
</ul>
</li>
<li>数据安全性验证
<ul>
<li>Wireshark</li>
</ul>
</li>
</ul>
</li>
<li>漏洞确认</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="漏洞分析技术体系">漏洞分析技术体系</h3>
<p><img src="/2022/01/16/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%BD%93%E7%B3%BB.png" alt="软件漏洞分析体系图"></p>
<h3 id="软件架构安全分析">软件架构安全分析</h3>
<p>软件架构安全分析研究在软件设计构成中发现缺陷并且避免设计有缺陷的软件。</p>
<h4 id="形式化架构分析技术">形式化架构分析技术</h4>
<p>形式化分析技术主要使用形式化方法统一描述软件架构和安全需求，然后检测软件架构是否满足安全需求。形式化分析技术主要包括UMLsec建模描述分析法、软件架构模型法、离散时间马尔可夫转移链法和组件系统架构描述法。</p>
<h4 id="工程化分析技术">工程化分析技术</h4>
<p>工程化分析技术从攻击者的角度考虑软件面临的安全问题，实用性强，但是自动化程度较低。工程化分析技术包括场景分析法、错误用例分析法、威胁建模法。</p>
<h3 id="源代码漏洞分析">源代码漏洞分析</h3>
<p>源代码漏洞分析是针对高级语言编写的程序进行分析以发现漏洞的方法。<br>
源代码漏洞分析通常使用静态分析方法。源代码分析在不运行软件的前提下进行分析，分析对象可以是源代码，也可以是其他形式的中间代码，例如 Java 程序的字节码。静态漏洞分析系统或者缺陷分析系统通常选择源代码作为分析对象，这是因为：</p>
<ol>
<li>该类工具通常在程序开发阶段使用，源代码是可见的。</li>
<li>相比于编译后的中间代码，源代码有着更丰富的语义信息。</li>
</ol>
<h4 id="基于中间表示的分析技术">基于中间表示的分析技术</h4>
<p>基于中间表示的分析技术以编译原理为主要基础技术，基本思想是先将源代码翻译为便于分析的中间表示，同时根据需要构建一些用于分析的数据结构，如控制流图、调用图等，然后根据一些预定义的分析规则对中间表示进行遍历，以判断分析规则所描述的漏洞是否存在。<br>
基于中间表示的分析技术包括数据流分析、符号执行和污点传播等。</p>
<h5 id="数据流分析">数据流分析</h5>
<p>数据流分析是一种用来获取有关数据如何沿着程序执行路径流动的相关信息的分析技术，被广泛用于编译构成中的代码优化。<br>
数据流分析一般从程序的一个控制流图开始，数据流分析主要有前向分析（forward analysis）、后向分析（backward analysis）两种。基于格（lattice）与不动点（fixpoint）理论的数据流分析是目前被广泛使用的技术。</p>
<h5 id="符号执行">符号执行</h5>
<p>符号执行是使用符号值代替数字值执行程序的技术，在使用符号执行技术的分析过程中，分析系统将程序中变量的取值表示为符号和常量组成的计算表达式，将程序计算的输出表示为符号的函数。</p>
<h5 id="污点分析">污点分析</h5>
<p>污点分析是一种跟踪并分析污点信息在程序中流动的技术，污点分析技术将所感兴趣的信息标记为污点信息（tainted information），通过跟踪污点信息的刘翔，检测这些信息是否会影响某些关键的操作。</p>
<h4 id="基于逻辑推理的分析技术">基于逻辑推理的分析技术</h4>
<p>此类方法以数学推理为基础，该方法将源代码进行形式化的描述，并在形式化描述的基础上，利用推理、证明等数学方法验证或者发现形式化描述的一些性质，以此推断程序是否存在某种类型的漏洞。</p>
<h5 id="模型检测">模型检测</h5>
<p>为了提高分析的准确度，获取关于程序的更多性质，许多研究人员借用形式化方法来拓展基本分析技术，其中代表性的技术有模型检测（model checking）、定理证明等。模型检测使用状态歉意系统表示系统行为，用模态/时序逻辑公式描述系统的性质，通过系统性质是否符合预期来判断是否存在漏洞。<br>
此类方法在检查硬件设计错误方面简单明了且自动化程度较高，但是应用在软件程序分析与验证时存在状态空间爆炸的问题。另外分析对象是形式化描述，如果形式化描述与程序不完全一致，可能导致检查结果无法反应程序中真实错误的情况。</p>
<h5 id="定理证明">定理证明</h5>
<p>定理证明通过将验证问题转化为数学上的定理证明问题来判断待分析程序是否满足指定属性，是较为复杂但准确的方法。但是为了获取指定的属性以实现有效的证明，需要向程序源代码中添加特殊形式的注释，增加了程序员的工作量，无法广泛应用于大型程序中。</p>
<h3 id="二进制漏洞分析">二进制漏洞分析</h3>
<p>二进制漏洞分析技术是一种面向二进制可执行代码的软件安全性分析技术，通过对二进制可执行代码进行多层次（指令级、结构规划、形式化等）、多角度（外部接口测试、内部结构测试等）的分析，发现软件中的安全漏洞。分析主要涵盖的技术环节包括反汇编逆向分析、汇编代码结构化、中间表示、漏洞建模、动态数据流分析/污点分析、控制流分析/符号执行等。</p>
<h4 id="静态分析">静态分析</h4>
<p>二进制漏洞静态分析是以人为定义的漏洞模型为指导，在二进制可执行程序中进行漏洞检测的一种方法，包括基于模式的漏洞分析和二进制代码对比。<br>
基于模式的漏洞分析是一项较为简单、自动化程度较高且非常适用于安全漏洞检测的技术。<br>
二进制代码对比通过将二进制文件进行不同层次的对比，从得到的差异之间发现安全漏洞。根据对比的深度不同，可以分为字符级别比较、指令级别比较和结构化比较。</p>
<h4 id="动态分析">动态分析</h4>
<p>二进制漏洞动态分析是通过记录二进制程序的执行轨迹，并进一步分析程序在运行时的内存读写操作、函数调用关系、内存分配/释放等信息的一种漏洞检测方法，主要的技术为模糊测试。</p>
<h4 id="动静结合的分析技术">动静结合的分析技术</h4>
<p>动静结合的漏洞分析技术结合了动态漏洞分析技术的准确性和静态漏洞分析的路径完备性，代表性技术为动态污点分析和智能灰盒测试。<br>
动态污点分析作为一种新兴的程序分析技术，已经在恶意软件分析、网络协议逆向、软件漏洞挖掘等领域得到应用。<br>
智能灰盒测试是在传统模糊测试的基础上发展而来的一种在测试过程中引入目标系统的内在知识来辅助测试的漏洞分析技术，通过静态、动态等分析过程，获得一定程度的目标程序的结构、语义、控制流等辅助信息，然后有针对性地设计测试用例。灰盒测试一般使用符号执行和污点分析等技术，大大增加了代码的覆盖率，且有针对性地检测某些安全敏感点的行为也大大增加了漏洞发现的概率，提高了分析效率。</p>
<h3 id="运行系统漏洞分析">运行系统漏洞分析</h3>
<p>运行系统是多种软件的有机整体，运行系统的漏洞分析相较于单个软件的漏洞分析有着其特殊性。具体体现在：</p>
<ul>
<li>运行系统比单个软件更为复杂</li>
<li>黑盒（没有源代码和程序文档）</li>
<li>运行系统内部信息不公开，需要漏洞分析人员手动提取</li>
</ul>
<p>目前，漏洞分析人员通过信息搜集、漏洞检测和漏洞确认三个步骤对运行系统进行漏洞分析。</p>
<h4 id="信息收集">信息收集</h4>
<p>在此阶段，分析人员可以利用社会工程学、主机扫描技术、端口扫描技术等多项技术，通过人工或者一些自动化的工具手机有关运行系统架构、运行系统所部署机器的网络拓扑结构及其上面运行的操作系统类型版本、开启的端口及服务信息。</p>
<h4 id="漏洞检测">漏洞检测</h4>
<p>配置管理测试是对系统配置进行检测，常用工具有：</p>
<ul>
<li>MBSA</li>
<li>Metasploit</li>
<li>天珣安全配置审核系统</li>
</ul>
<p>通信协议验证是对系统中的通信协议潜在的安全漏洞进行检测，有形式化方法和攻击验证方法两种，常用的工具有：</p>
<ul>
<li>Nessus</li>
<li>Nmap</li>
</ul>
<p>授权认证检测主要检测系统授权机制，主要工具有：</p>
<ul>
<li>Nessus</li>
<li>WebScarab</li>
</ul>
<p>数据验证测试主要发现外部数据可能产生的安全漏洞，主要工具有：</p>
<ul>
<li>Acunetix Web Vulnerability Scanner(WVS)</li>
<li>AppScan</li>
<li>极光漏洞扫描工具</li>
<li>明鉴Web应用弱点扫描器</li>
</ul>
<p>数据安全性验证主要检查系统内部数据自身安全，该类技术通常采用密码分析、在线密码破解、模拟物理入侵等方式来验证数据在系统上的安全性，主要工具是 Wireshark.</p>
<h4 id="漏洞确认">漏洞确认</h4>
<p>在此阶段，分析人员对疑似漏洞列表中的漏洞进行逐一验证。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：符号执行</title>
    <url>/2022/01/21/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>软件漏洞分析技术第6章符号执行读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>符号执行
<ul>
<li>基本原理</li>
<li>方法实现</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Clang</li>
<li>KLEE</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>符号执行的分析过程如下：</p>
<ol>
<li>将变量用符号值表示</li>
<li>分析程序执行流程</li>
<li>将变量表示为符号和变量的表达式</li>
</ol>
<h2 id="实现方法">实现方法</h2>
<p>符号执行存在两种分析方式：</p>
<ol>
<li>正向分析</li>
<li>逆向分析</li>
</ol>
<p>还可以使用符号执行构造测试用例。</p>
<h2 id="典型工具">典型工具</h2>
<p><strong>Clang</strong>：Clang 能够分析和编译 C、C++、Objective C++ 等语言。该工具不仅是一个静态分析工具，还是一个轻量级编译器。<br>
<strong>KLEE</strong>：KLEE 可用于分析 Linux 系统下的 c 语言程序，在分析程序构造测试用例的同时，也可以用来对变量取值范围进行符号分析。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：软件架构安全分析</title>
    <url>/2022/01/23/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析技术第14章软件架构安全分析。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>软件架构安全分析
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>形式化分析</li>
<li>工程化分析</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>威胁建模工具</li>
<li>软件架构分析工具</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>软件架构是一系列相关的抽象模式，用于指导大型软件系统各个方面的设计。描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致第描述组件之间的通讯。</p>
<h2 id="方法实现">方法实现</h2>
<p>现在软件架构安全分析可以分为两类：</p>
<ol>
<li>形式化分析，分析结果精确、可量化，自动化程度高，但实用性差</li>
<li>工程化分析，实用性强，但自动化程度化</li>
</ol>
<p>常见的<strong>工程化分析技术</strong>：</p>
<ol>
<li>场景分析法</li>
<li>错误用例分析法</li>
<li>威胁建模法</li>
</ol>
<h2 id="实例分析">实例分析</h2>
<p>工程化分析实例，基于 Web 应用程序的威胁建模基本步骤：</p>
<ol>
<li>确定安全目标</li>
<li>创建 Web 应用程序概述</li>
<li>分解应用</li>
<li>确定威胁</li>
<li>确定漏洞</li>
</ol>
<h2 id="典型工具">典型工具</h2>
<p>威胁建模工具：</p>
<ol>
<li>图表</li>
<li>分析模型</li>
<li>描述环境</li>
<li>生成报告</li>
</ol>
<p>软件架构分析工具有 IBM 软件架构师工具包。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>软件漏洞分析技术：运行系统漏洞分析</title>
    <url>/2022/01/23/%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%EF%BC%9A%E8%BF%90%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>软件漏洞分析技术第15章运行系统漏洞分析读书笔记。</p>
<span id="more"></span>
<blockquote class="pullquote mindmap mindmap-md"><ul>
<li>运行系统漏洞分析
<ul>
<li>基本原理</li>
<li>方法实现
<ul>
<li>信息手机</li>
<li>配置管理漏洞检测</li>
<li>通信协议漏洞检测</li>
<li>授权认证漏洞检测</li>
<li>数据验证漏洞检测</li>
<li>数据安全性检测</li>
</ul>
</li>
<li>实例分析</li>
<li>典型工具
<ul>
<li>Nmap</li>
<li>Nessus</li>
<li>微软基线安全分析器</li>
<li>WVS</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="基本原理">基本原理</h2>
<p>运行系统的特点：</p>
<ol>
<li>运行系统是处于实际运行状态的系统</li>
<li>运行系统是多种软件的有机整体，各个软件之间具有一定的运行逻辑关系</li>
<li>运行系统的部署环境复杂多样，可能由不同子网范围内的不同操作系统的多台机器共同构成</li>
</ol>
<h2 id="方法实现">方法实现</h2>
<p>信息收集主要手段有：</p>
<ol>
<li>网络拓扑探测</li>
<li>操作系统探测</li>
<li>应用软件探测</li>
<li>基于爬虫的信息收集</li>
<li>公用资源搜索</li>
</ol>
<p>配置管理漏洞检测具体步骤有：</p>
<ol>
<li>分析运行系统的业务特性</li>
<li>测试运行系统各配置是否符合第一步建立的运行系统安全配置要求</li>
<li>分析人员将检查过程中发现的不符合安全配置要求的地方记录下来，形成配置安全测试评估报告</li>
</ol>
<p>通信协议漏洞检测检测方法有：</p>
<ol>
<li>形式化方法，通过数学方法说明软件系统属性</li>
<li>攻击验证方法</li>
</ol>
<p>授权认证漏洞检测中授权测试方法：</p>
<ol>
<li>路径遍历测试</li>
<li>绕过授权测试</li>
<li>提权测试</li>
</ol>
<p>授权认证漏洞检测中认证测试方法：</p>
<ol>
<li>加密信道测试</li>
<li>用户枚举测试</li>
<li>默认或可猜用户名测试</li>
<li>暴力破解测试</li>
<li>竞争条件测试</li>
</ol>
<p>数据验证漏洞检测方法：</p>
<ol>
<li>跨站脚本漏洞测试</li>
<li>SQL注入漏洞测试</li>
</ol>
<p>数据安全性漏洞检测：</p>
<ol>
<li>密码分析</li>
<li>在线密码破解</li>
<li>模拟物理入侵</li>
</ol>
<h2 id="实例与工具">实例与工具</h2>
<p>针对 Web 应用系统的实例分析基本步骤：</p>
<ol>
<li>信息收集</li>
<li>漏洞检测（暴力破解弱口令、配置错误、信息泄漏和漏洞利用）</li>
</ol>
<p><strong>Nmap</strong>是开源的网络发现和安全审计工具。<br>
<strong>Nessus</strong>是目前应用最广泛的系统漏洞扫描与分析软件爱你。<br>
<strong>微软基线安全分析器</strong>是一个易用的安全基线工具。<br>
<strong>WVS</strong>是一个自动化的 Web 应用程序安全测试工具。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>readings</category>
        <category>bug analysis</category>
      </categories>
      <tags>
        <tag>bug analysis</tag>
      </tags>
  </entry>
</search>
